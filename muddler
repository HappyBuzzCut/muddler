#!/usr/bin/perl -I .
#-#         ( A 90dies mud client written today ) 
#-#       o               v1.0a                   
#-#      o _____                __  __ _          
#-#    _||_| u |    _ _  _ _ __| /_| /| |  __ ____
#-#   (        |== / v \| | |  _ | _ || |/ -_) __/
#-#   /-()---()   |_|_|_|___/\___\___/|_|\__/_/   
use strict;
# use Monitor qw(monitor);
use Term::ReadKey;
use Text::ParseWords;
use Digest::MD5;
#use Pmc::Telnet qw( TELOPT_SGA TELOPT_TTYPE TELOPT_NAWS TELOPT_NEW_ENVIRON
#                     TELNET_IAC TELNET_SB TELNET_SE TELOPT_ECHO);
use Net::Telnet ();

use Carp;
my %key;                            # key presses hash table for fast lookups
my %history;                                                  # world history
my %socket;                                              # socket information
my %command;                            # command hash table for fast lookups
my %pending;                                            # unseen world output
my %address;                                                # world addresses 
my %help;
my @input;                                                    # input history

my %state = (
   line_pos => 0,                     # character position on the current line
   size_x => 24,                                 # size of screen horizontally
   size_y => 80,                              # size of the screen veritically
   input_size => 2,
   input_offset => 0,                        # lines scrolled off input buffer
   input_pos => -1,                                 # location in input history
   line => [],                                             # curent input line
   pending => {}
);


#----------------------------------------------------------------------------#
#                                                                            #
#  ansi support                                                              #
#    Routines taken from teenymush. This should probably be turned into a    #
#    module if i liked using multiple files.                                 #
#                                                                            #
#----------------------------------------------------------------------------#
#
# ansi_debug
#    Convert an ansi string into something more readable.
#
sub ansi_debug
{
    my $txt = shift;

    $txt =~ s/\e/<ESC>/g;
    return $txt;
}


#
# ansi_char
#    Returns one character of the current string. Due to the nature of the
#    ansi functions, this will only return characters not in ansi character
#    strings. While this is silly to use a function to do this, this helps
#    abstract the data set for situations in which the ansi functions are
#    replaced by standard string functions.
#
sub ansi_char
{
   my ($data,$pos) = @_;

   return @{$$data{ch}}[$pos];
}


sub is_ansi_string
{
   my $txt = shift;

   if(ref($txt) ne "HASH" ||
      !defined $$txt{ch} ||
      !defined $$txt{snap} ||
      !defined $$txt{code}) {
      return 0;
   } else {
      return 1;
   }
}


sub ansi_reset
{
   my ($data,$pos) = @_;

   my $string = (is_ansi_string($data)) ? $data : ansi_init($data);

   printf("Ansi_reset: returning\n") if $pos < 0;
   return $string if $pos < 0;                               # sanity check

   my $code = $$string{code};
   my $array = $$code[$pos];

   # check to see if the last code is a reset, or no codes at all
   if($#$array == -1 || $$array[$#$array] ne "\e[0m") {
      push(@$array,"\e[0m");
   }
   return $string;
}
#
# ansi_add
#   Add a character or escape code to the data array. Every add of a
#   character results in a new element, escape codes are added to existing
#   elements as long as a character has not been added yet. The ansi state
#   is also kept track of here.
#
sub ansi_add
{
   my ($data,$type,$txt) = @_;

   my $ch   = $$data{ch};                      # make things more readable
   my $code = $$data{code};
   my $snap = $$data{snap};

   if($#$ch == -1 || $$ch[$#$ch] ne undef) {
      $$ch[$#$ch+1] = undef;
      $$code[$#$ch] = [];
      $$snap[$#$ch] = [];
   }

   if($type) {
     for my $c (split(//,$txt)) {                 # add multiple characters
        $$ch[ $#$ch + ((@$ch[$#$ch] ne undef) ? 1 : 0) ] = $c;
        @$code[$#$ch] = [] if(!defined @$code[$#$ch]);
        @$snap[$#$ch] = [ @{@$data{state}} ];
     }
   } else {                                           # add escape sequence
      push(@{$$code[$#$ch]},$txt);
      if($txt eq "\e[0m") {
         $$data{state} = [];
      } else {
         push(@{$$data{state}},$txt);
      }
   }
}


#
# ansi_init
#    Read in a string and convert it into a data structure that can be
#    easily parsed / modified, i hope.
#
#     {
#       code => [ [ array of arrays containing escape codes ] ]
#       ch   => [ Array containing each character one by one ]
#       snap => [ [ array of arrays containing all active escape codes
#                   at the time the character was encountered ] ]
#       state=> [ internal, current state of active escape does ]
#     }
#
sub ansi_init
{
   my $str = shift;

   my $data = { ch => [], code => [], state  => [], snap   => [] };

   while($str =~ /\e\[([\d;]*)([a-zA-Z])/) {
      $str = $';
      ansi_add($data,1,$`) if $` ne undef;
      ansi_add($data,0,"\e[$1$2");
   }
   ansi_add($data,1,$str) if($str ne undef);

   return $data;
}

#
# ansi_clone
#   Clone the ansi escape codes at a particular position to the new
#   string.
#
sub ansi_clone
{
   my ($str,$pos,$txt) = @_;

   if(ref($str) ne "HASH") {
      $str = ansi_init($str);
   }

   my $snap = $$str{snap};

   if($#$snap >= 0 && $#$snap > $pos) {
      return join('',@{@$snap[$pos]}) . $txt . "\e[0m";
   } else {
      return $txt;
   }
}

#
# ansi_string
#    Take ansi data structure and return
#        type => 0 : everything but the escape codes
#        type => 1 : original string [including escape codes]
#
sub ansi_string
{
   my ($data,$type) = @_;
   my $buf;

   for my $i (0 .. $#{$$data{ch}}) {
      $buf .= join('', @{@{$$data{code}}[$i]}) if($type);
      $buf .= @{$$data{ch}}[$i];
   }
   return $buf;
}

#
# ansi_substr
#    Do a substr on a string while preserving the escape codes.
#
#    no-ansi flag : do not copy over escape sequences
#
sub ansi_substr
{
   my ($txt,$start,$count,$noansi) = @_;
   my ($result,$data);
   my $last = -1;

   if(ref($txt) eq "HASH") {
      $data = $txt;
   } else {
      $data = ansi_init($txt);
   }

   $start = 0 if($start !~ /^\s*\d+\s*$/);                  # sanity checks
   if($count !~ /^\s*\d+\s*$/) {
      $count = ansi_length($txt);
   } else {
      $count += $start;
   }
   return undef if($start < 0);                         # no starting point

   # loop through each "character" w/attached ansi codes
   for(my $i = $start;$i < $count && $i <= $#{$$data{ch}};$i++) {
      if(!$noansi) {
         my $code=join('',@{@{$$data{($i == $start) ? "snap" : "code"}}[$i]});
         $result .= $code . @{$$data{ch}}[$i];
      } else {
         $result .= @{$$data{ch}}[$i];
      }
      $last = $#{@{$$data{snap}}[$i]};
   }

   # are attributes turned on on last character? if so, reset them.
   return $result . (($last == -1) ? "" : (chr(27) . "[0m"));
}

#
# ansi_length
#    Return the length of a string without counting all those pesky escape
#    codes.
#
sub ansi_length
{
   my $txt = shift;
   my $data = shift;

   if(ref($txt) eq "HASH") {                           # already inited txt?
      $data = $txt;
   } else {
      $data = ansi_init($txt);
   }

   if($#{$$data{ch}} == -1) {                                       # empty
      return 0;
   } elsif(@{$$data{ch}}[-1] eq undef) {               # last char pos empty?
      return $#{$$data{ch}};
   } else {
      return $#{$$data{ch}} + 1;                        # last char populated
   }
}
#
# ansi_remove
#    remove any escape codes from the string
#
sub ansi_remove
{
#   my $txt = ansi_init(shift);
#   return ansi_print($txt,0);

   my $txt = shift;
   $txt =~ s/\e\[[\d;]*[a-zA-Z]//g;
   return $txt;
}


#----------------------------------------------------------------------------#
#                                                                            #
#  pmc support                                                               #
#                                                                            #
#----------------------------------------------------------------------------#

# sub TELQUAL_IS   { 0; }
# sub TELQUAL_SEND { 1; }
# sub TELOPT_MXP   { 91; }
# sub TELOPT_MSP   { 90; }
# 
# sub negotiation {
#     my ($conn, $option, $is_remote, $is_enabled, $was_enabled,
#         $buf_position)= @_;
#     $is_remote||=0;
#     $is_enabled||=0;
#     $was_enabled||=0;
#     my ($noecho, $linemode);
# 
# #    debug("negotiation: $option rem:$is_remote is_en:$is_enabled ".
# #          "was_en:$was_enabled");
# 
#     if ($option==TELOPT_TTYPE) {
#         send_iac($conn,chr(TELNET_SB).
#                  chr(TELOPT_TTYPE).
#                  chr(TELQUAL_IS).
#                  $ENV{TERM}.
#                  chr(TELNET_IAC).
#                  chr(TELNET_SE)
#                 );
#     } elsif($option == TELOPT_NAWS) {
#         send_naws($conn,1);
#     } elsif ($option==TELOPT_ECHO) {
#         if ($is_enabled) {
#             $noecho=1;
#         } else {
#             $noecho=0;
#         }
#         switch_echo();
#     } elsif ($option==TELOPT_SGA) {
#         if ($linemode && $is_enabled) {
#             debug('char-mode');
#             ReadMode(4);
#         } elsif (!$is_enabled && !$linemode) {
#             debug('line-mode');
#             ReadMode(0);
#         }
#         $linemode= !$is_enabled;
#     } elsif ($option==TELOPT_MXP || $option==TELOPT_MSP) {
#     } else {
#     }
# }
# 
# sub send_iac {
#     my ($conn,$neg) = @_;
# 
#     syswrite $conn, chr(TELNET_IAC).$neg, length($neg)+1, 0;
# }
# 
# sub check_mcp_naws {
#    return 0;
# }
# 
# sub send_naws {
#     my ($conn,$from_telopt)= @_;
# 
# #    my ($height,$width)= $term->get_screen_size();
#     my ($height,$width) = (24,80);
#     if (check_mcp_naws() && !$from_telopt) {
#         mcp_send('dns-com-vmoo-client-screensize',
#                 jols => $width, rows => $height);
#     } else {
#         send_iac($conn,chr(TELNET_SB).chr(TELOPT_NAWS).chr($width/256).
#                  chr($width%256).chr($height/256).chr($height%256).
#                  chr(TELNET_IAC).chr(TELNET_SE));
#     }
# }

#----------------------------------------------------------------------------#
#                                                                            #
#  tcp code                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

#
# BEGIN statement with including code, and most of socket_connect were
# copied from from: http://aspn.activestate.com/ASPN/Mail/Message/
# perl-win32-porters/1449297.
#
# BEGIN {
#    # This nonsense is needed in 5.6.1 and earlier -- I'm too lazy to
#    # test if it's been fixed in 5.8.0.
#    if( $^O eq 'MSWin32' ) {
#       *EWOULDBLOCK = sub () { 10035 };
#       *EINPROGRESS = sub () { 10036 };
#       *IO::Socket::blocking = sub {
#           my ($self, $blocking) = @_;
#           my $nonblocking = $blocking ? "0" : "1";
#           ioctl($self, 0x8004667e, $nonblocking);
#       };
#    } else {
#       require Errno;
#       import  Errno qw(EWOULDBLOCK EINPROGRESS);
#    }
# }

# sub socket_connect
# {
#    my ($world,$host,$port,$ssl) = ( lc(shift), @_ );
# 
#    if(defined @socket{$world} && @socket{$world}->{sock}) {
#       return echo("%% Already connected to %s",$world);
#    }
# 
#    @history{$world} = [];
#    @pending{$world} = [] if !defined @pending{$world};
#    @socket{$world} = { name      => $world,
#                        host      => $host,
#                        port      => $port,
#                        more      => 0,
#                        more_last => 0,
#                        last_read => -1,
#                        lnum      => 0,
#                      };
#    @state{world} = $world;
#    @socket{$world}->{pos} = scalar keys %socket;
# 
#    my $s = new Pmc::Telnet( $host, $port, $ssl, Timeout => 10);
#    key_log("name=$world,host=$host,port=$port");
# 
#    if(!$s) {
#       draw_bar();
#       return echo("%% Connection Failed.");
#    }
# 
#    $s->option_callback(\&negotiation);
#    $s->option_accept( Do   => TELOPT_SGA,
#                       Do   => TELOPT_TTYPE,
#                       Do   => TELOPT_NAWS,
#                       Do   => TELOPT_ECHO,
#                       Dont => TELOPT_MXP,
#                       Dont => TELOPT_MSP,
#                       Wont => TELOPT_MXP,
#                       Wont => TELOPT_MSP,
#                       Will => TELOPT_SGA,
#                       Will => TELOPT_TTYPE,
#                       Will => TELOPT_NAWS,
#                       Will => TELOPT_ECHO);
#    @socket{$world}->{sock} = $s;
#    echo("%% Connection to %s succeeded.",$world);
#    if(defined @address{$world}->{user} && defined @address{$world}->{pass}) {
#       out($world,
#            "connect %s %s\n",
#            @address{$world}->{user},
#            @address{$world}->{pass}
#           );
#    }
#    draw_bar();
# }

sub socket_connect
{
   my ($world,$host,$port,$ssl) = ( lc(shift), @_ );

   if(defined @socket{$world} && @socket{$world}->{sock}) {
      return echo("%% Already connected to %s",$world);
   }

   @history{$world} = [];
   @pending{$world} = [] if !defined @pending{$world};
   @socket{$world} = { name      => $world,
                       host      => $host,
                       port      => $port,
                       more      => 0,
                       more_last => 0,
                       last_read => -1,
                       lnum      => 0,
                     };
   @state{world} = $world;
   @socket{$world}->{pos} = scalar keys %socket;

   my $s = Net::Telnet->new(host => $host,
                            port => $port,
                            binmode => 1,
                            Timeout => 10,
                            Errmode => "return");
#   my $s = new Pmc::Telnet( $host, $port, $ssl, Timeout => 10);
   key_log("name=$world,host=$host,port=$port,sock=$s");
#   key_log("INPUT: '%s'\n",$s->getline(Timeout=>20));

   if(!$s) {
      draw_bar();
      return echo("%% Connection Failed.");
   }

#    $s->option_callback(\&negotiation);
#    $s->option_accept( Do   => TELOPT_SGA,
#                       Do   => TELOPT_TTYPE,
#                       Do   => TELOPT_NAWS,
#                       Do   => TELOPT_ECHO,
#                       Dont => TELOPT_MXP,
#                       Dont => TELOPT_MSP,
#                       Wont => TELOPT_MXP,
#                       Wont => TELOPT_MSP,
#                       Will => TELOPT_SGA,
#                       Will => TELOPT_TTYPE,
#                       Will => TELOPT_NAWS,
#                       Will => TELOPT_ECHO);
   @socket{$world}->{sock} = $s;
   echo("%% Connection to %s succeeded.",$world);
   if(defined @address{$world}->{user} && defined @address{$world}->{pass}) {
      out($world,
           "connect %s %s\n",
           @address{$world}->{user},
           @address{$world}->{pass}
          );
   }
   draw_bar();
}

sub socket_handle_input
{
   for my $world (keys %socket) {
      if(@socket{$world}->{sock}) {
         if(@socket{$world}->{sock}->eof()) {
            delete @socket{$world}->{sock};
            pending($world,"% Connection closed to ". name($world));
            draw_bar();
         } else {                 # favor keyboard input not socket in timeout
            # read all input
            for(my $count=0;$count < 200;$count++) {
               if(my $input = @socket{$world}->{sock}->getline(Timeout=>0)) {
                  pending($world,$input);
               } else {
                  last;
               }
            }
#            my @lines = @socket{$world}->{sock}->getlines(Timeout=>5);
#            if($#lines >= 0) {
#               for my $i (0 .. $#lines) { 
#                  pending($world,@lines[$i]);
#               }
#            }
         }
      }
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  console code                                                              #
#                                                                            #
#----------------------------------------------------------------------------#

#
# in_hist
#    Is the current world reviewing the history buffer?
#
sub in_hist
{
   if(no_world() || !defined @socket{@state{world}}) {
      return 0;
   } elsif(defined @socket{@state{world}}->{hist_pos}) {
      return 1;
   } else {
      return 0;
   }
}

#
# hist_pos
#    Return if the history buffer position, set it, or delete it.
#
sub hist_pos
{
   my $action = shift;

   if(no_world()) {
      return;
   } elsif($action eq "delete") {
      delete @socket{@state{world}}->{hist_pos};
   } elsif($action ne undef) {
      @socket{@state{world}}->{hist_pos} = $action;
   } else {
      return @socket{@state{world}}->{hist_pos};
   }
}

#
# has_pending
#    Does the currently opened world have any pending output
#
sub has_pending
{
   return ($#{@pending{@state{world}}} >= 0) ? 1 : 0;
}

#
# no_world
#   test to see if no worlds have been opened yet.
#
sub no_world
{
   return (!defined @state{world} || @state{world} eq undef) ? 1 : 0;
}

#
# echo
#    Echo output to the console. If there is pending output or we're in the
#    history buffer, through the output into the pending queue.
#
sub echo
{
   my ($fmt,@args) = @_;

   if(@state{world} eq undef || !has_pending()  && !in_hist()) {
      echo_output($fmt,@args);
   } else {
      key_log("Pending_adds: %s",sprintf($fmt,@args));
      pending(@state{world},sprintf($fmt,@args),0,1);
   }
}

#
# echo_output
#    Echo something to the screen and also log that output into the history
#    see echo_nolog if it shouldn't be logged to the current history.
#
#    This subroutine support an output optimization via optimize_start /
#    optimize_end when multiple lines may be sent to the output window.
#    This will disable moving the cursor back to the input window when
#    done which will send less output.
#
sub echo_output
{
   my $txt;

   if(ref(@_[0]) eq "HASH") {             # probably directly from pending()
      $txt = shift;
   } else {
      my ($fmt,@args) = @_;
      $txt = { txt       => sprintf($fmt,@args),
               ts        => time(),                              # add entry
               gagged    => 0,                            # was line gagged?
               pend_code => code(),
               internal  => 1,
             };
      if(defined @state{world} && defined @socket{@state{world}}) {
         $$txt{td} = @socket{@state{world}}->{lnum}++,
      }
   }

   history(@state{world},$txt) if defined @state{world};

   if(@state{optimize_output} <= 1) { 
      update_scroll_region("output");
      xy(output_end(),1);
      @state{optimize_output} = 2 if(@state{optimize_output} == 1);
   }

#   key_log("echo output: $$txt{txt} %s",code());
   printf("\n%s",$$txt{txt});

   if(@state{optimize_output} == 0) {
      update_scroll_region("input");
      xy(input_x(),input_y());
   }
}

#
# echo_nolog
#    The same thing as echo_output but does not log anything. This should
#    be a flag or something to echo_output but a reasonable interface has
#    not been determined.
#
#    This subroutine support an output optimization via optimize_start /
#    optimize_end when multiple lines may be sent to the output window.
#    This will disable moving the cursor back to the input window when
#    done which will send less output.
#
sub echo_nolog
{
   my $txt;

   if(ref(@_[0]) eq "HASH") {
      $txt = shift;
   } else {
      my ($fmt,@args) = @_;
      $txt = { txt    =>  sprintf($fmt,@args),
               ts     => time(),                             # add entry
               gagged => 0,                              # was line gagged?
             };
      if(defined @state{world} && defined @socket{@state{world}}) {
         $$txt{td} = @socket{@state{world}}->{lnum}++,
      }
   }

#   pending($txt);
 
   if(@state{optimize_output} <= 1) { 
      update_scroll_region("output");
      xy(output_end(),1);
      @state{optimize_output} = 2 if(@state{optimize_output} == 1);
   }
   printf("\n%s",$$txt{txt});

   if(@state{optimize_output} == 0) {
      update_scroll_region("input");
      xy(input_x(),input_y());
   }
}


#
# pausable_check
#    Check to see if the socket should have "more" turned on based upon
#    activity, weather conditions, and whatever else I think of.
#
sub more_check
{
   my $w = lc(shift);
   my ($last, $count);

   return if($w eq undef || !defined @history{$w} || !defined @pending{$w});

   if($#{@pending{$w}} > @state{size_y} * .90) {
      @socket{$w}->{more} = 1;
      return;
   }

   my $pend = @pending{$w};
   for my $i (0 .. $#$pend) {
      if($last ne undef && $$pend[$i]->{ts} - $last < 3) {
         $count++;
      }
      $last = $$pend[$i]->{ts};
   }

   if($count >= 5) {
      @socket{$w}->{more} = 1;
      return;
   }

   my $hist = @history{$w};
   for(my $i=$#$hist;$i >= 0 && time() - $$hist[$i]->{ts} > 300;$i--) {
      if($last ne undef && $$hist[$i]->{ts} - $last < 3) {
         $count++;
      }
      $last = $$hist[$i]->{ts};
   }

   if($count >= 5) {
      @socket{$w}->{more} = 1;
      return;
   }
}

#
# more_update
#
#    Manage the more and more_needed. This should be called after more
#    has been set and after a page full of lines have been shown.
#
#    Events should flow like this:
#
#       o Signal more should be turned on by setting the more variable.
#       o Show a page full of lines
#       o Require that a tab be pressed by setting the more_needed variable
#         before any more pending output is shown.
#
sub more_update
{
   my $w = shift;

   return if(!defined @pending{$w} || !more($w));

   draw_bar();
   if($#{@pending{$w}} >= 0) {
      @socket{$w}->{more_needed} = 1;
   } else {
      @socket{$w}->{more_needed} = 0;
      @socket{$w}->{more} = 0;
   }
}

#
# paused
#    More might be on but should new output be paused?
#
sub paused
{
   my $w = shift;

   if(in_hist()) {
      return 1;
   } elsif(@socket{$w}->{more} == 1 && @socket{$w}->{more_needed} == 1) { 
      return 1;
   } else {
      return 0;
   }
}

#
# on_world
#   Determine if the current world is the one specified.
#
sub on_world
{
   return (@state{world} eq @_[0]) ? 1 : 0;
}

#
# more
#    Show the status for the current world and optionally fix it.
#
sub more
{
  my $world = shift;
  $world = @state{world} if($world eq undef);

  if(in_hist()) {             # in history buffer is just a version of more
     return 1;
  } elsif(@socket{$world}->{more} == 1) {
     if($#{@pending{$world}} == -1) {
        delete @socket{$world}->{more};
        return 0;
     }
     return 1;
   } else {
     return 0;
   }
}

#
# recent
#   Scan through the most recent output from the world and determine how
#   many lines have happened in $howlong seconds. This is used by to determine
#   if more should be turned on.
#
sub recent
{
   my ($world,$howlong) = @_;
   my $count = 0;

   my $array = @pending{$world};
   for(my $i = $#$array;$i >= 0 && time() - $$array[$i]->{ts} < $howlong; $i--){
      $count++;
   }

   my $array = @history{$world};
   for(my $i = $#$array;
       $i >= 0 && $i >= @socket{$world}->{more_last} && 
       time() - $$array[$i]->{ts} < $howlong;
       $i--){
      # always count original to make counting easier but not gagged.
      # In the situation of a text being replaced, we technically we should
      # count just the modifed version but then you have figure out how to
      # count the original version when not modified. Gagged output should
      # never be "original".
      if($$array[$i]->{original} || !$$array[$i]->{gagged}) { # don't count 
         $count++;
      }
   }
   return $count;
}

#
# replace
#    This should be replaced by something more generic. Currently it is
#    being used to remove the nospoof flag output by mushes.
#
sub replace
{
   my ($world,$txt) = @_;

   if($txt =~ /^\[([^\]]+)\(([^\]]+)\)([^\]]*)\] / ||
      $txt =~ /^\[([^:]+):\] /)  {
      return $';
   }
   return undef;
}

#
# pending_add
#    Add a line to the pending input buffer and determine if more needs
#    to be turned on. This function probably should have been run against
#    unwrapped text but its probably more accurate to treat a really big
#    line as multiple hits instead of just one for weighted accuracy.
#
sub pending_add
{
   my ($world,$line,$gagged,$original) = @_;

   my $array = @pending{$world};

   # this should be a push() but i muffed something up and it was
   # screwing up the array.. so i just rewrote it this way since i didn't
   # see the obvious problem.
   $$array[$#$array+1] = { txt       =>  $line,
                           id        => @socket{@state{world}}->{lnum},
                           ts        => time(),             # add entry
                           gagged    => $gagged,     # was line gagged?
                           pend_code => code(),
                           original  => $original
                          };

   return if !$original; # don't count the text twice, so just count the
                         # original entry.

   if(!more($world) && on_world($world) && 
      recent($world,30)  > @state{size_x} * .55) {
      @socket{$world}->{more} = 1;
      @socket{$world}->{more_needed} = 1;
  }
}

#
# pending
#    add a line of input into the pending queue
#
sub pending
{
   my ($world,$txt,$gagged) = @_;
   $txt =~ s/\r|\n//g;

   return if @state{world} eq undef;
   @pending{$world} = [] if !defined @pending{$world};

   if($txt eq undef) {
      pending_add($world,"");
   } else {
      @socket{@state{world}}->{lnum}++;

      my $modified=replace($world,$txt);
      if($modified ne undef) {
         for my $line (ansi_wrap($modified)) {
            pending_add($world,$line,0,0);
         }
      }

      for my $line (ansi_wrap($txt)) {
         pending_add($world,$line,($modified eq undef) ? 0 : 1,1);
      }
   }

   if(on_world($world) && !paused($world)) {
      show_output($world);
   } else {
      @state{activity}->{$world} = 1;
   }
}

sub history
{
   my ($world,$data) = @_;

   if(ref($data) ne "HASH") {
      key_log("Invalid data type found[%s]: %s\n",code(),$data);
   } elsif(!defined $$data{pend_code}) {
      key_log("No pending code[%s]: %s\n",code(),print_var($data));
   } else {
      $$data{history_code} = code();
      push(@{@history{$world}},$data);
   }
}

sub show_output
{
   my $flag = shift;
   my $w = @state{world};
   my $count = 0;

   return if $w eq undef;
   more_check($w);
   return if(paused($w));

   optimize_start();
   while($#{@pending{$w}} >= 0 && $count < @state{size_x} - 3) {
      my $txt = shift(@{@pending{$w}});

      if(!$$txt{gagged}) {
         echo_output($txt);
      } else {
         history($w,$txt);
      }
      $count++;
   }
   delete @state{activity}->{$w} if defined @state{activity}->{$w};

   more_update($w);
   optimize_end();
}

sub line_start_pos
{
   return @state{size_x} - 2;
}

#
# return the X position of the input cursor
#
sub input_x
{
   my $x = input_start() + 
           sprintf("%d",(@state{line_pos} - 
                        ((@state{size_y} - 1) * @state{input_offset})) /
                        (@state{size_y} - 1));
   

   if($x > @state{size_x}) {
      return @state{size_x};
   } else {
      return $x;
   }
}

#
# return the Y position of the input cursor
#
sub input_y
{
   return 1 + (@state{line_pos} % (@state{size_y} - 1));
}

#
# define all functions here so they can be reloaded.
#
sub key_init
{
   delete @key{keys %key};
   @key{def}             = sub { return key_default(@_);             };
   @key{2}               = sub { return key_left(@_);                };
   @key{4}               = sub { return key_dump(@_);                };
   @key{6}               = sub { return key_right(@_);               };
   @key{9}               = sub { return key_tab(@_);                 };
   @key{10}              = sub { return key_return(@_);              };
   @key{12}              = sub { return key_ctl_l(@_);               };
   @key{14}              = sub { return key_ctl_n(@_);               };
   @key{16}              = sub { return key_ctl_p(@_);               };
   @key{18}              = sub { return key_ctl_r(@_);               };
   @key{21}              = sub { return key_ctl_u(@_);               };
   @key{23}              = sub { return key_ctl_w(@_);               };
   @key{27}              = sub { return key_escape(@_);              };
   @key{127}             = sub { return key_delete(@_);              };
   @key{multi}           = sub { return key_multi(@_);               };
   @key{multi_119}       = sub { return key_esc_w(@_);               };
   @key{multi_113}       = sub { return key_esc_q(@_);               };
   @key{multi_91_53_126} = sub { return key_pgup(@_);                };
   @key{multi_91_54_126} = sub { return key_pgdn(@_);                };
   @key{multi_91_65}     = sub { return key_up(@_);                  };
   @key{multi_91_66}     = sub { return key_down(@_);                };
   @key{multi_91_67}     = sub { return key_right(@_);               };
   @key{multi_91_68}     = sub { return key_left(@_);                };
}



sub output_end
{
   return @state{size_x} - @state{input_size} - 1;
}

sub ansi_wrap
{
   my $txt = shift;
   $txt =~ s/[\n\r]+$//g;
   my $str = ansi_init($txt);
   my ($start,$last,$len,@out) = (0);

   for my $i (0 .. $#{$$str{ch}}) {
      if(ansi_char($str,$i) =~ /[ ,\/\\]/ && $i-$start <= @state{size_y} - 1) {
         $len = $i + 1;                           # scan for breaking points
      }

      if($i - $start >= @state{size_y} - 2) {       # past max, use last point
         # use $len unless at end of string or no breakpoints found
         my $cut = (ansi_length($str) == $i+1 || $len eq undef) ? ($i+1) : $len;
         push(@out,ansi_substr($str,$start,$cut - $start));
         $start = $cut;
         $len = undef;
      }
   }

   # add left overs.
   push(@out,ansi_substr($str,$start)) if($start < $#{$$str{ch}});
   return @out;
}

sub rewrap
{
   my ($world,$hist,$txt) = @_;

   if(!defined @history{$world} && !defined @history{$world}->[$hist]) {
      return;
   }

   # input already defined, use it
   if(defined @history{$world}->[$hist]->{txt}) { 
      $txt = join("",@{@history{$world}->[$hist]->{txt}});
   }
   $txt =~ s/([\r\n]+)$//g;                         # remove ending return(s)

   @history{$world}->[$hist]->{txt} = ansi_wrap($txt); # update entry
   @history{$world}->[$hist]->{size} = @state{size_y};
  
   if($#{@history{$world}->[$hist]->{txt}} == -1) {
      @history{$world}->[$hist]->{txt} = [ "" ];
   }
}

sub redraw_output
{
   my ($flag) = @_;                        # don't show internal messages?
   my ($y,@out,$paused);
   my ($start,$last) = @_;
   my $count;

   my $w = @state{world};

   more_check($w);
   if($w ne undef) {
      if(!paused($w)) {
         # populate history with some new entries
         
         my $pend = @pending{$w};
            for(my $i=0;$#$pend >= 0 && $count <= output_end() * 0.55;$i++) {
            $count++ if(!$$pend[$#$pend]->{gagged});
            history($w,shift(@$pend));
         }
         more_update($w);
      }

      # show old history + recently added entries
      my $hist = @history{$w};

      # find starting point in history or at bottom
      $start = (in_hist()) ? hist_pos() : $#$hist;

      if($start > $#$hist) {
         key_log("### HIST IS TO BIG: $start $#$hist");
      }
      
      for(my $i=$start;$#out <= output_end()-1 && $i >= 0;$i--) {
         if(!$$hist[$i]->{gagged} && (!$flag ||
            $flag && $$hist[$i]->{internal} == 0)) {
            if($$hist[$i]->{internal} <= 1) {
               unshift(@out,@{$$hist[$i]}{txt});
            }
            $$hist[$i]->{internal}++ if($$hist[$i]->{internal} == 1);
         }
      }
   }

   for my $i (1 .. (output_end() - $#out + 1)) { # fill in any blank lines
      unshift(@out,"\033[K");
   }

   # send the screen
   optimize_start();
   for my $i (0 .. $#out) { 
      echo_nolog("%s",@out[$i]);
   }
   optimize_end();

   # move cursor back to input area
   xy(input_x(),input_y());
}

sub redraw_input
{
   update_scroll_region("input",1);
   xy(input_start(),1,1);
   my $start = @state{input_offset}+1;
   my $end = $start + @state{input_size} - 1;
   for my $i ($start .. $end) {
      printf("%s\033[K%s",input_line($i),($i != $end) ? "\n" : "");
   }
   xy(input_x(),input_y(),1);
}

sub redraw_screen
{
   my $flag = shift;

   key_log("redraw_screen: start");
   my $clear = shift;
   printf("\033[r\033[2J") if $clear;
   clear_screen();
   redraw_output($flag);
   draw_bar(1);
   redraw_input();
   key_log("redraw_screen: end`");
}

sub scan_history
{
   my $inc = shift;
   my $count = 0;
   my $pos;
   
    if($inc > 0 && (!in_hist() || hist_pos() == $#{@history{@state{world}}})) {
       hist_pos("delete");
       return 1;
    } elsif(abs($inc) != 1) {
       die("scan_history incrament must be -1 or +1");
    } elsif($inc < 0 && !in_hist()) {
       $pos = $#{@history{@state{world}}};
    } else {
       $pos = hist_pos();
    }
      
   my $hist = @history{@state{world}};
   while($pos > 0 && $pos <= $#$hist && $count <= output_end() - 5) {
      if(!$$hist[$pos]->{gagged} && $$hist[$pos]->{internal} == 0) {
         @state{hist_start} += $inc;
         $count++;
      }
      $pos += $inc;
   }

   $pos++ if($pos == 0);
   $pos = $#$hist if ($pos > $#$hist);

   if($pos == $#$hist && $inc > 0) {
      hist_pos("delete");
      return 1;
   } elsif($count == 0) {
      # do nothing;
      return 0;
   } else {
      hist_pos($pos);
      return 1;
   }
}

sub key_pgup
{
   my $w = @state{world};
   my $count = -1;

   if(scan_history(-1)) {
      redraw_output();
   }
   draw_bar();
}

sub key_pgdn
{
   my $w = @state{world};

   if(scan_history(1)) {
      redraw_output();
   }
   draw_bar();
}

sub key_dump
{
   my $file;

   key_log("Dumping files");

   for my $key (keys %history) {
      open($file,"> history.$key.log") || return;
      printf($file "%s\n",print_var(@history{$key}));
      close($file);
   }

   for my $key (keys %pending) {
      open($file,"> pending.$key.log") || return;
      printf($file "%s\n",print_var(@pending{$key}));
      close($file);
   }
}

#
# key_ctl_p
#    Move down into the keyboard input history
#
sub key_ctl_p
{
   # current input has data, lets store it
   if($#{@state{line}} >= 0 && @state{input_pos} == -1) { # store current input
      unshift(@input,@state{line});
      @state{input_pos}++;
   } 
   if(@state{input_pos} < $#input) {           # move down in keyboard history
      @state{line} = @input[++@state{input_pos}];
      @state{line_pos} = $#{@input[@state{input_pos}]} + 1;
      redraw_input();
   }
}

#
# key_ctl_p
#    Move up in the keyboard input history
#
sub key_ctl_n
{
   if(@state{input_pos} == 0) {            # input empty, start with new line
      @state{line} = [];
      @state{line_pos} = 0;
      @state{input_pos} = -1;
      redraw_input();
   } elsif(@state{input_pos} > 0) {         # input availible, move up in hist
      @state{line} = @input[--@state{input_pos}];
      @state{line_pos} = $#{@input[@state{input_pos}]} + 1;
      redraw_input();
   }
}

sub key_ctl_r
{
   key_log("Reloading code");
   reload_code();
}

sub key_ctl_l
{
   key_log("ctl_l: %s,%s",input_x(),input_y());
   redraw_screen(@state{world},1);
}

sub key_tab
{
   return if @state{world} eq undef;

   if(in_hist()) {                        # same as key_pgdn, just call it
      key_pgdn();
   } else {
      delete @socket{@state{world}}->{more_needed};
      @socket{@state{world}}->{more_last} = $#{@history{@state{world}}};
      show_output(@state{world});
      if($#{@pending{@state{world}}} == 1) {
         delete @socket{@state{world}}->{more};
      }
   }
}

# key_ctl_u
#    Clear keyboard input
#
sub key_ctl_u
{
   @state{line} = [];
   @state{line_pos} = 0;
   delete @state{input_offset};
   xy(input_start(),1);
   printf("\033[J");
}

sub key_ctl_w
{
   my $count = 0;
   my $found = 0;

#   key_log("control_w: pressed: '%s'",@state{line_pos});
   for(my $i = @state{line_pos};$i >= 0;$i--) {
      if(@state{line}->[$i] ne " ") {
         $count++;
         if(@state{line}->[$i] ne undef) {
            $found = 1;
         }
      } elsif(@state{line}->[$i] eq " " && !$found) {
         $count++;
      } else {
         last;
      }
   }
   for my $i (2 .. $count) {
      key_delete();
   }
}

sub key_escape
{
   @state{multikey} = [];
}

sub out
{
   my $world = shift;
   my ($fmt,@args) = @_;

   $world = @state{world} if($world eq undef);
   if(defined @socket{$world} && defined @socket{$world}->{sock}) {
      my $sock = @socket{@state{world}}->{sock};
#      key_log("$world> $fmt",@args);
      printf($sock "$fmt",@args);
      @socket{$world}->{last_send} = time();
   }
}

#
# key_return
#    The return key has been pressed, now what?
#
sub key_return
{
   my $array = @state{line};
   my $input = join('',@$array);

   if($input =~ /^\/([^ ]+)\s*/) {
      if(defined @command{lc($1)}) {
         &{@command{lc($1)}}($');
      } else {
         echo("%% %s: no such command or macro",lc($1));
      }
   } elsif(no_world()) {
     # do nothing
   } elsif(defined @socket{@state{world}}->{sock}) {
      out(@state{world},"%s\n",$input);
   }
   unshift(@input,@state{line});                        # store keyboard history
   @state{input_pos} = -1;                        # reset keyboard history pos
   @state{line} = [];
   @state{line_pos} = 0;
   delete @state{input_offset};

   # just entered input, don't be so quick to show the more
   if(!no_world()) {
      @socket{@state{world}}->{more_last} = $#{@history{@state{world}}};
   }
   input_clear();
   xy(input_x(),input_y());
}

sub input_lines
{
    my $result = sprintf("%d",($#{@state{line}} + 1) / (@state{size_y} - 1));
    return $result + 1 if(($#{@state{line}} + 1) % (@state{size_y} - 1) >= 1);
    return $result;
}

sub input_online
{
    my $result = sprintf("%d",@state{line_pos} / (@state{size_y} - 1));
    return $result + 1 if(@state{line_pos} % (@state{size_y} - 1) >= 1);
    return $result;
}


sub key_delete
{
   my $ch = shift;
   update_scroll_region("input");
   
   if(@state{line_pos} < 1) {                        # nothing left to delete
      return;
   } elsif(@state{line_pos} < $#{@state{line}}) {          # delete in middle
      splice(@{@state{line}},@state{line_pos}-1,1);
      xy(input_x(),input_y()-1);
      printf("\033[P");
      @state{line_pos}--;
      xy(input_x(),input_y());
     
      for my $i ((input_online()+1) .. input_lines()) {
         xy(input_start() + $i - 2,79);
         printf("%s",@state{line}->[(@state{size_y}-1) * ($i-1) - 1]);
         xy(input_x() + $i - 1,0);
         printf("\033[P");
      }
      xy(input_x(),input_y());
   } elsif(@state{line_pos} >= 1) {                           # delete at EOL
      @state{line_pos}--;
      pop(@{@state{line}});
      xy(input_x(),input_y());
      printf("\033[P");
      xy(input_x(),input_y());
   }
}

#
# key_default
#    Default key handler for all normal characters.
#
sub key_default
{
   my $ch = shift;
   my $out;

   update_scroll_region("input");

   splice(@{@state{line}},@state{line_pos},0,$ch);         # add ch to buffer
   @state{line_pos}++;                          # move cursor position over 1
   printf("%s",$ch);                                     # print out new char

   # redraw all characters in front of current character as the terminal
   for my $i (@state{line_pos} .. $#{@state{line}}) {

      # determine if character would be off the screen, if so done.
      if($i >= ((@state{size_y}-1) * @state{input_size}) + 
               (@state{input_offset} * (@state{size_y}-1))) {
         last;
      }

      # determine if we should drop down a line before next character
      if($i % (@state{size_y}-1) == 0 && $i != 0) {
         $out .= "\n";
      }
      $out .= @state{line}->[$i];                   # add next char in buffer
   }
   printf("%s",$out);                                   # output generated txt
   $out =~ s/\n/<N>/g;

   # if the input has gotten bigger then the input window, send a return now
   # plus the next line.
   if(($#{@state{line}} + 1 >= @state{input_size} * (@state{size_y}-1)) &&
      @state{line_pos} % (@state{size_y} - 1) == 0) {
      printf("\n%s",input_line(input_online()+1));
      @state{input_offset}++;
   }
   xy(input_x(),input_y());
}

sub key_left
{
   my $ret = "\n";
   if(@state{input_offset} > 0 && @state{line_pos} % (@state{size_y}-1)==0 &&
      input_x() == input_start()) {
      @state{input_offset}--;
      for my $i (input_online() .. input_lines()) {
         last if(@state{input_size} < $i - @state{input_offset});
         my $start = ($i-1) * (@state{size_y} -1);
         my $stop = $start + @state{size_y}-2;

         # only draw lines that are currently visible.
         if(@state{input_size} < $i + 1 - @state{input_offset}) {
            $ret = undef;                          # last line? no return
         }
         printf("\033[J%s$ret",join('',@{@state{line}}[$start .. $stop]));
      }
   }
   if(@state{line_pos} >= 1) {
      @state{line_pos}--;
      xy(input_x(),input_y());
   }
}

#
# input_line
#   Returns the keyed in input for a line on the screen.
#
sub input_line
{
   my $start = (@_[0] - 1) * (@state{size_y} -1);
   my $stop = $start + @state{size_y}-2;
   return join('',@{@state{line}}[$start .. $stop]);
}

sub name
{
   my $name = lc(shift);

   return undef if($name eq undef && @state{world} eq undef);
   $name = @state{world} if $name eq undef;

   if(defined @address{$name}) {
      return ((defined @socket{$name}->{sock}) ? "" : "!") .
             @address{$name}->{name};                      # correct case?
   } else {
      return "(Unnamed)";
   }
}

sub key_up
{
   return if not defined @state{world};
   my $pos = @socket{@state{world}}->{pos};
   $pos++;
   $pos = 1 if $pos > scalar keys %socket;

   switch_world((sort {@socket{$a}->{pos} cmp @socket{$b}->{pos}} 
                    keys %socket)[$pos-1])
}

sub key_down
{
   return if not defined @state{world};
   my $pos = @socket{@state{world}}->{pos};
   if($pos == 1) {
      $pos = scalar keys %socket;
   } else {
      $pos--;
   }

   switch_world((sort {@socket{$a}->{pos} cmp @socket{$b}->{pos}} 
                 keys %socket)[$pos-1]);
}

sub key_right
{
   if(@state{line_pos} <= $#{@state{line}}) {
      if(@state{line_pos} % (@state{size_y}-1)==78 &&
         input_x() == @state{size_x}) {
         @state{input_offset}++;
         printf("\n%s",input_line(input_online()+1));
      }
      @state{line_pos}++;
      xy(input_x(),input_y());
   }
}

sub switch_world
{
   my $world = shift;

   return if $world eq undef;
   @state{world_last} = @state{world};
   @state{world} = $world;
   delete @state{activity}->{$world};
   redraw_output();
   draw_bar();
}

#
# key_esc_w
#   Go to the next active world
#
sub key_esc_w
{
   return if not defined @state{world};

   # try next active world
   my $new = (keys %{@state{activity}})[0];

   # fall back to previous world the client was showing.
   $new = @state{world_last} if($new eq undef && defined @state{world_last});

   # nothing found, do nothing.
   return if $new eq undef;

   switch_world($new);
}

#
# update_scroll_region
#   Send the escape sequence to set a scroll region in the terminal.
#   The region will not be set if the region is already in affect unless
#   $force is true.
#
sub update_scroll_region
{
   my ($region,$force) = @_;
   my ($start,$stop);

   if($region eq "input") {                           # supported region input
      $start = @state{size_x} - @state{input_size} + 1;
      $stop  = @state{size_x};
   } elsif($region eq "output") {                    # supported region output
      $start = 1;
      $stop = output_end();
   } else {                                              # unsupported region
      die("Invalid region '$region' specified.");
   }

   if(@state{region} ne "$start,$stop" || $force) {           # do the work
      printf("\033[%s;%sr",$start,$stop);
#      key_log("USR[$region]: $start,$stop");
      @state{region} = "$start,$stop";
   }
}

sub is_in
{
   my ($txt,@list) = @_;

   for my $i (0 .. $#list) {
      return 1 if($txt eq @list[$i]);
   }
   return 0;
}

#
# key_multi
#   Process multiple character keys. key_escape will start the sequence
#   off and this will grab characters till it makes a match or no match
#   can be made.
#
sub key_multi
{
   my $ch = shift;

   my $array = @state{multikey};
   push(@$array,ord($ch));
   if(defined @key{"multi_" . join('_',@$array)}) {
       return &{@key{"multi_" . join('_',@$array)}}($ch);
   }

   if($#$array == 0) {                         # second character recieved
      return if($ch eq "[");
   } elsif($#$array == 1) {                       # third character recieved
      return if(is_in(ord($ch),53,54));                    # pgup/pgdn 4 char
   }

   delete @state{multikey};                              # no match or error, 
   key_process($ch);                          # process character generically
}

#
# key_process
#    Process input one key at a time while allowing for multi character
#    keys that begin with a escape and are followed by an arbitrary number
#    of letters afterwards (1 to 2?).
#
sub key_process
{
   my $input = shift;
   return unless defined $input;

   for my $ch (split(//,$input)) {
#      key_log("ch: '%s' -> '%s'",ord($ch),$ch);
      if(defined @key{ord($ch)}) {
         &{@key{ord($ch)}}($ch);
      } elsif(defined @state{multikey} && $#{@state{multikey}} <= 2) {
         &{@key{multi}}($ch);
      } else {
         &{@key{def}}($ch);
      }
   }
}

sub clear_screen
{
#    xy(1,1);
    for my $line (1 .. @state{size_x}) {
       if($line == @state{size_x}) {
          printf("\033[K");
       } else {
          printf("\033[K\n");
       }
    }
}

#
# x,y
#    Move the cursor to a location. This should be able to be optimized
#    when we are sure we always know where the cursor is all the time.
#
sub xy
{
   my ($x,$y,$use_the_force_luke) = @_;

#   if(@state{prev_xy} ne "$x,$y" || $use_the_force_luke) {
      printf("\033[%s;%sH",$x,$y);
#      key_log("POS: '%s','%s' [%s]",$x,$y,code());
#      @state{prev_xy} = "$x,$y";
#   }
}

#
# more_bar
#    Determine what the more text should look like on the bar.
#
sub more_bar
{
   if(!defined @state{world} || @state{world} eq undef) {
      return;
   } elsif(in_hist()) {
      return sprintf("\033[7mHist %4s\033[0m",hist_pos());
   } elsif($#{@pending{@state{world}}} >= 0) {
      return sprintf("\033[7mMore %4s\033[0m",$#{@pending{@state{world}}} + 1);
   }
}

sub more_count
{
   if(@state{world} ne undef) {
      return $#{@pending{@state{world}}} + 1;
   }
}

#
# draw_bar
#    draw/redraw the input bar if need.
#
sub draw_bar
{
   my $force = shift;
   my $new = time();
   my ($hr,$min,$active) = ((localtime($new))[2,1]);
   $hr -= 12 if($hr > 12);

   if($force || "$hr$min" ne @state{bar_time} ||
      @state{bar_activity} ne scalar keys %{@state{activity}} ||
      @state{bar_name} ne name(@state{world}) ||
      @state{bar_more} ne more_count() ||
      @state{bar_pos} ne hist_pos()) {
      @state{bar_time} = "$hr$min";
      @state{bar_name} = name(@state{world});
      @state{bar_more} = more_count();
      @state{bar_pos} = hist_pos();
      my $more = more_bar();

      @state{bar_activity} = scalar keys %{@state{activity}};

      xy(@state{size_x} - @state{input_size},0);

      if(defined @state{activity}->{@state{world}}) {
         delete @state{activity}->{@state{world}};
      }
      if(scalar keys %{@state{activity}} > 0) {
         $active = sprintf("(Active: %d)",scalar keys %{@state{activity}});
      }

      printf("%s%s_%s%s_%s______%s:%02d",
             "_" x (9 - ansi_length($more)),
             $more,
             name(),
             "_" x (@state{size_y} - length(name()."$active$hr")-20),
             $active,
             $hr,
             $min
            );
      update_scroll_region("input");
      xy(input_x(),input_y());
   }
}

#
# input_start
#    Return the starting line number of the input window.
#
sub input_start
{
   return @state{size_x} - @state{input_size} + 1;
}

#
# input_end
#    Return the line ending line of the console. This function exists
#    mostly to make things more readable.
#
sub input_end
{
   return @state{size_x};
}

#
# revert_console
#    Send whatever is needed to reset the terminal to normal operation.
#    i.e. turning off scroll regions.
#
sub revert_console
{
   ReadMode 'normal';
   printf("\033[r");
   xy(24,1);
}


#
# key_log
#    This script was originally called "key" as i was just focused on
#    the keyboard input window.
#
#    This function logs to a key.log file so that it can be tailed
#    so the output can be seen without screwing up the console output.
#
sub key_log
{
   my ($fmt,@args) = @_;
   my $file;

   my $msg = sprintf("$fmt",@args);
   $msg .= "\n" if($msg !~ /\n/);
   open($file,">> key.log");
   printf($file "%s",$msg);
   close($file);
}

#
# code
#    Provide just the list of line numbers from perl's stack of what sub-
#    routines or optionally the full output. The line numbers will be
#    adjusted as code is reloaded because the numbers will change.
#
sub code
{
   my $type = shift;
   my @stack;

   my $prev = @state{chksum};
   if(!$type || $type eq "short") {
      for my $line (split(/\n/,Carp::shortmess)) {
         if($line =~ /at ([^ ]+) line (\d+)\s*$/) {
            my ($fun,$ln) = ($1,$2);
            if(defined $$prev{$fun}) {
#               key_log("code: $line");
               push(@stack,(@{$$prev{$fun}}{line} + $ln) . "[$fun]");
            } else {
#               key_log("!code: $line");
               push(@stack,"$ln*");
            }
         }
      }
      return join(',',@stack);
   } else {
      return Carp::shortmess;
   }
}

sub input_clear
{
   update_scroll_region("input");
   my $start = @state{size_x} - @state{input_size} + 1;
   xy($start,0);
   for my $i ($start .. @state{size_y}) {
      printf("\033[K\n");
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  commands                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

sub command_init
{
   delete @command{keys %command};
   @command{world}       = sub { return cmd_world(@_);                     };
   @command{quit}        = sub { return cmd_quit(@_);                      };
   @command{reload}      = sub { return cmd_reload(@_);                    };
   @command{dc}          = sub { return cmd_dc(@_);                        };
   @command{listsockets} = sub { return cmd_dc(@_);                        };
   @command{l}           = sub { return cmd_listsockets(@_);               };
   @command{recall}      = sub { return cmd_recall(@_);                    };
   @command{version}     = sub { return cmd_version(@_);                   };
   @command{help}        = sub { return cmd_help(@_);                      };
}

sub key_esc_q
{
   my $spell;
   my $input = join('',@{@state{line}});
   $input =~ s/[^a-zA-Z0-9 ]+//g;
   open($spell,"echo $input | /home/adrick/mush/tfspell |") ||
      return echo("%% Unable to run tfspell");
   while(<$spell>) {
      $_ =~ s/\r|\n//g;
      echo("%% $_") if($_ !~ /^\s*$/);
   }
   close($spell);
}

#
# glob2re
#    Convert a global pattern into a regular expression
#
sub glob2re
{
    my ($pat) = trim(shift);

    return "^\s*\$" if $pat eq undef;
    $pat =~ s{(\W)}{
        $1 eq '?' ? '(.)' :
        $1 eq '*' ? '(*PRUNE)(.*?)' :
        '\\' . $1
    }eg;

    $pat =~ s/\\\(.\)/?/g;

#    return "(?mnsx:\\A$pat\\z)";
    return "(?msix:\\A$pat\\z)";
}


sub cmd_help
{
#-# ------------------------------------------------------------------------
#-# /help [<command>]
#-#      Shows the help for the specified command.
#-#
#-# Availible Commands:
#-#      /version, /world, /recall, /listsockets, /quit, /reload
#-# ------------------------------------------------------------------------
   my $cmd = shift;

   if(!defined @state{help}) {
      echo("% No help loaded.");
   } elsif(trim($cmd) eq undef) {
      echo("\n%s",@state{help}->{cmd_help});
   } elsif(defined @state{help}->{"cmd_" . lc(trim($cmd))}) {
      echo("\n%s",@state{help}->{"cmd_" . lc(trim($cmd))});
   } else {
      echo("%% Help on subject %s not found.",lc(trim($cmd)));
   }
}

sub cmd_version
{
#-# ------------------------------------------------------------------------
#-# /version
#-#      Shows the current version at startup of muddler. This is currently
#-#      not refreshed when the code is reloaded.
#-# ------------------------------------------------------------------------
   for my $line (split(/\n/,@state{version})) {
      echo("%s",center($line));
   }
}

sub cmd_recall
{
#-# ------------------------------------------------------------------------
#-# /recall [<count>] <pattern>
#-#      Does a recall of ten lines from the current world's history
#-#      buffer that matches pattern. The amount of lines can be
#-#      changed by specifying a count.
#-#
#-# Patterns:
#-#      Patterns may contain text that will be matched as is but also
#-#      May contain * as a wild card or ? to match a single character.   
#-#
#-# Example:
#-#      /recall *pages*
#-# ------------------------------------------------------------------------
   my $txt = shift;
   my ($count,$pat)  = 10;

   return echo("%% Not connected to a world.") if(no_world());

   if($txt =~ /^(\d+) /) {
      $count = $1;
      $pat = $';
   } else {
      $pat = $txt;
   }

   $pat = glob2re($pat);
   key_log("PAT: $pat");
   for(my $i=$#{@history{@state{world}}};$i >= 0 && $count > 0;$i--) {
      eval {
         key_log("TXT: '%s'",@history{@state{world}}->[$i]->{txt});
         if(!@history{@state{world}}->[$i]->{gagged} &&
            ansi_remove(@history{@state{world}}->[$i]->{txt}) =~ /$pat/) {
            echo_nolog("%s",@history{@state{world}}->[$i]->{txt});
            $count--;
         }
      };
   }
}

sub cmd_listsockets
{
#-# ------------------------------------------------------------------------
#-# /list_sockets
#-#      Shows all open connections and some minimal data about them.
#-# ------------------------------------------------------------------------
   echo("%-16s %-26s %-5s","NAME","HOST","PORT");
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock}) {
         echo("%-16s %-26s %-5s", @address{$w}->{name}, @address{$w}->{host},
             @address{$w}->{port});
      }
   }
}
sub cmd_quit
{
#-# ------------------------------------------------------------------------
#-# /quit
#-#      Exits out of muddler
#-# ------------------------------------------------------------------------
   revert_console();
   exit(1);
}

sub cmd_reload
{
#-# ------------------------------------------------------------------------
#-# /reload
#-#      Reloads the perl code for muddler without dropping connections.
#-#      As long as no new variables are set, there is a 80% chance
#-#      that the client will continue and not have issues.
#-# ------------------------------------------------------------------------
   reload_code();
}

sub cmd_world
{
#-# ------------------------------------------------------------------------
#-# /world <world>
#-#      Connects to the specified world if not connected or switches over
#-#      to that world if it is connected.
#-#
#-# Ex: /world puggy
#-# ------------------------------------------------------------------------
   my $txt = lc(trim(shift));

   key_log("cmd_world: called\n");
   if(!defined @address{$txt}) {
      key_log("# non-existing world");
      return echo("% CONNECT: no such world '%s'",$txt);
   } elsif(defined @socket{$txt} && defined @socket{$txt}->{sock}) {
      key_log("# existing world");
      switch_world($txt);
   } else {
      socket_connect(@address{$txt}->{name},
                     @address{$txt}->{host},
                     @address{$txt}->{port},
                    );
   }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  misc code                                                                 #
#                                                                            #
#----------------------------------------------------------------------------#

END {
  revert_console();
}

sub center
{
    my $txt = shift;

    return sprintf("%s%s",(" " x ((@state{size_y} - length($txt)-1) / 2)),$txt);
}

sub optimize_start
{
   @state{optimize_output} = 1;
}

sub optimize_end
{
   @state{optimize_output} = 0;
   update_scroll_region("input");
   xy(input_x(),input_y());
}

sub show_banner
{
   open(PROG,$0) || return;

   optimize_start();
   while(<PROG>) {
      s/\n|\r//g;
      if($. > 24) {                                  # read only 24 lines
         last;
      } elsif(/^#-#   /) {
         @state{version} .= "$'\n";
         echo("%s",center($'));
      } elsif($. > 100) {                              # read only 50 lines
         last;
      }
   }

   @state{version} =~ s/\n$//g;
   close(PROG);
   for my $i (0 .. 2) {
      echo("%s","");
   }
   optimize_end();
}

sub read_tfworlds
{
   my $fn = shift;
   my ($file, $bad);

   open($file,$fn) ||
      return echo("%% Unable to open '%s' for reading",$fn);

   while(<$file>) {
      s/\r|\n//g;
      if(/^\/test addworld\((.*)\)$/) {
         my @data = quotewords(',',0,$1);
         @address{lc(trim(@data[0]))} = {};
         @address{lc(trim(@data[0]))}->{host} = trim(@data[2]);
         @address{lc(trim(@data[0]))}->{port} = trim(@data[3]);;
         @address{lc(trim(@data[0]))}->{user} = trim(@data[4]);;
         @address{lc(trim(@data[0]))}->{pass} = trim(@data[5]);;
         @address{lc(trim(@data[0]))}->{name} = trim(@data[0]);
      } else {
         $bad++;
         echo("%% Unknown data: '%s'",$_);
      }
   }
   close($file);
   echo("%% %d worlds read from tfworlds file.",scalar keys %address);
}

sub get_checksums
{
   my ($file,$pos,%data);
   my $ln = 1;

   open($file,$0) ||
     return echo("%% Unable to read source file, /reload will be disabled");

   for my $line (<$file>) {
      if($pos eq undef && $line =~ /^sub\s+([^ \n\r]+)\s*$/) {
         $pos = $1;
         @data{$pos} = { chk => Digest::MD5->new };
         @data{$pos}->{chk}->add($line);
         @data{$pos}->{src} .= qq[#line 0 "$pos"\n] . $line;
         @data{$pos}->{line} = $ln;
         if($pos =~ /^cmd_/) {
            @state{help} = {} if not defined @state{help};
            delete @state{help}->{$pos} if defined @state{help}->{$pos};
         }
      } elsif($pos ne undef && $line =~ /^}\s*$/) {
         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk}->add($line);
         @data{$pos}->{chk} = @data{$pos}->{chk}->hexdigest;
         @data{$pos}->{done} = 1;
         if($pos =~ /cmd_/) {
            @state{help}->{$pos} =~ s/\n$//;
         }
         $pos = undef;
      } elsif($pos ne undef) {
         if($pos =~ /cmd_/) {
            if($line =~ /^#-# -+$/) {
               # header ignored
            } elsif($line =~ /^#-# {0,1}/) {
               @state{help}->{$pos} .= $';
            }
         }

         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk}->add($line);
      }
      $ln++;
   }
   close($file);

   for my $pos (keys %data) {
      if(!defined @data{$pos}->{done}) {
         echo("% Warning: Did not find end to %s",$pos);
      }
   }
   return \%data;
}

#
# reload_code
#    As long as the global variables do not change, the code can be
#    reloaded without dropping any connections.
#
sub reload_code
{
   my $count = 0;
   my $new = get_checksums();
   my $old = @state{chksum};
   $old = {} if $old eq undef;

   key_log("reload_code: start");
   for my $key (keys %$new) {
      if((@state{state} eq "init" || 
         (!defined $$old{$key} || $$old{$key}->{chk} ne $$new{$key}->{chk}))
         && $key ne "muddler") {
         
         key_log("%% Reloading: %s",$key) if @state{state} ne "init";
#         echo("%% Reloading: %s",$key) if @state{state} ne "init";
         eval($$new{$key}->{src});
         $count++;
         if($@) {
            echo("%% Error reloading $key: %s",$@);
            $$new{$key}->{chk} = -1;
         } else {
            echo("%% Reloading: %s [done]",$key) if @state{state} ne "init";
         }
      }
   }
   @state{chksum} = $new;
   command_init();
   key_init();
   key_log("reload_code: done");
   if($count == 0) {
      echo("%% No changes found to reload.");
   }
}

#
# ignoreit
#    Ignore certain hash key entries at all depths or just the specified
#    depth.
#
sub ignoreit
{
   my ($skip,$key,$depth) = @_;


   if(!defined $$skip{$key}) {
      return 0;
   } elsif($$skip{$key} < 0 || ($$skip{$key} >= 0 && $$skip{$key} == $depth)) {
     return 1;
   } else {
     return 0;
   }
}

#
# print_var
#    Return a "text" printable version of a HASH / Array
#
sub print_var
{
   my ($var,$depth,$name,$skip,$recursive) = @_;
   my ($PL,$PR) = ('{','}');
   my $out;

   if($depth > 4) {
       return (" " x ($depth * 2)) .  " -> TO_BIG\n";
   }
   $depth = 0 if $depth eq "";
   $out .= (" " x ($depth * 2)) . (($name eq undef) ? "UNDEFINED" : $name) .
           " $PL\n" if(!$recursive);
   $depth++;

   for my $key (sort ((ref($var) eq "HASH") ? keys %$var : 0 .. $#$var)) {

      my $data = (ref($var) eq "HASH") ? $$var{$key} : $$var[$key];

      if((ref($data) eq "HASH" || ref($data) eq "ARRAY") &&
         !ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s $PL\n"," " x ($depth*2),$key);
         $out .= print_var($data,$depth+1,$key,$skip,1);
         $out .= sprintf("%s$PR\n"," " x ($depth*2));
      } elsif(!ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s = %s\n"," " x ($depth*2),$key,$data);
      }
   }

   $out .= (" " x (($depth-1)*2)) . "$PR\n" if(!$recursive);
   return $out;
}


#
# remove any space at the begining or end of a string
#
sub trim
{
   my $txt = shift;

   $txt =~ s/^\s+|\s+$//g;
   return $txt;
}

sub tick
{
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock} && time()-@socket{$w}->{last_send} > 300){
#         key_log("tick: $w [%s]",time()-@socket{$w}->{last_send});
         if($w eq "del") {
            out($w,"score\n");
         } else {
            out($w,"think\n");
         }
         @socket{$w}->{last_send} = time();
      }
   }

   my $prev = "@state{size_y},@state{size_x}";
   (@state{size_y},@state{size_x}) = GetTerminalSize();
   if($prev ne "@state{size_y},@state{size_x}") {
      redraw_screen();
   }
}


sub muddler
{
   @state{state} = "init";
   (@state{size_y},@state{size_x}) = GetTerminalSize();

   `del key.log`;
   @state{activity} = {};
   @state{chksum} = get_checksums();
   key_log("### START ###");
   $| = 1;                                                  # unbuffer stdout
   ReadMode 'cbreak';
   key_init();
   command_init();
   redraw_screen();
   show_banner();
   read_tfworlds("@ENV{HOME}/.tfworlds");
   reload_code();
#   Monitor::monitor(@pending{alpha}, "array");
   @state{state} = "post-init";

    while(1) {

      eval { # this is probably not needed, ReadKey seems to be protecting
             # everything which doesn't make me happy.

         socket_handle_input();
         key_process(ReadKey(0.25));
         if($@) {
           key_log("Crash? $@");
         }
         draw_bar();

         if(time() - @state{tick_last} >= 10) {
            tick();
            @state{tick_last} = time();
         }

      };
      if($@) {
         key_log("Fatal: $@");
      }
   }
}

sub read_file
{
   my $fn =shift;
   my $file;

   open($file,$fn) || 
      die("Could not open '$fn' for reading");
   my $result = join("",<$file>);
   close($file);
   return $result;
}
muddler();
# 
# my $txt = <<__EOF__;
# +-----+-------------------+------------+------------+-------------------------+
# | Obvious Exits:          |                         |                         |
# | Ecksperta <104>         | Eternal Peace <EP>      |                         |
# \\-------------------------+-------------------------+-------------------------/
# __EOF__
# # #my $txt = "  QR Code, a pair of dice, whatchamadingy, HIGHlow Park Map, 'object', Mayan calendar, Pog(tm), BFG - Brazil's Fat Globals, Vending Machine, Holiday Hawk, christmas knob, Newspaper of Shame, Mood Ring, charset sampler, Mandelbrot, taco soup, Hypnotoad, SIGN: Feed the Adrick, Oracle, temperature converter, Rowex-sized Deep Fryer, SIGN: Don't Feed the Adrick, Ball-O-Shame, metroid, kebab, Sign: cHia Blog Zone and Narcissism Station, Deadbolt, the goat, can of Dr. Pepper, Kitty, the Godpidgeon, RPG Dice, A pack of dingos, Ominous HAT rack, Lucien, hug-o-matic wearing an Eratl mask, pickles the quote-o-matic, Pog Jr., pony, Boggle, AcroPhobia, Yahtzee Object From Hell, and Fake shelf";
# # 
# 
# 
# for my $line (split(/\n/,read_file("../mush/iweb.txt"))) {
# #   printf("#$line#\n");
#    for my $sub (ansi_wrap($line)) {
#       printf("#$sub#\n");
#    }
# }
