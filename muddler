#!/usr/bin/perl
#-#                      ___   ___ __                
#-#     _____  __ __  __| _/__| _/|  |  ___________ 
#-#    /     \|  |  \/ __ |/ __ | |  | / __ \_  __ \
#-#   |  Y Y  \  |  / /_/ / /_/ | |  |_\  __/|  | \/
#-#   |__|_|__/____/\____/\_____/ |____/\___/|__|   
#-#       A 1990dies mud client written yesterday   

use Text::Wrap;
use strict;
use Term::ReadKey;
use Carp;
use IO::Select;
use IO::Socket;
use Pmc::Telnet qw( TELOPT_SGA TELOPT_TTYPE TELOPT_NAWS TELOPT_NEW_ENVIRON TELNET_IAC TELNET_SB TELNET_SE TELOPT_ECHO);

my (%state,                                        #!# screen size / stats
    %sock,                                         #!# sock data
    %sock_world,                                   #!#
    %pending,                                      #!#
    %world,                                        #!#
    %world_history,                                #!# world(s) output buffer
    %command,                                      #!# internal commands
    %world);                                       #!# world definitions

sub init
{
   $| = 1;                                                  # unbuffer stdout
   ReadMode 'cbreak';                               # set no-echo, unbuffered
   printf("\033[2J");
 
   # get screen size and size accordingly
   (@state{size_y},@state{size_x}) = GetTerminalSize();
   @state{size_x}   = 24               if(@state{size_x} eq undef);
   @state{size_y}   = 80               if(@state{size_y} eq undef);
   $Text::Wrap::columns = 80;

   @state{kbbuffer} = [];
   @state{size_i}   = 2;
   @state{key_x}    = @state{size_x} - @state{size_i} + 1;
   @state{key_y}    = 1;
   @state{pos_x}    = @state{size_x} - @state{size_i} + 1;
   @state{pos_y}    = 1;

   clear_screen();
   update_bar();
   display_cursor();

   # read banner from top of script, this is probably silly but then banner
   # doesn't need to be escaped out.

   open(PROG,$0) || return;

   while(<PROG>) {
      s/\n|\r//g;
      if(/^#-#   /) {
         center($');
      } elsif($. > 50) {                              # read only 50 lines
         close(PROG);
         last;
      }
   }
   close(PROG);

   out_nolog(' ');
   center("Keys: Control-U    Erase keyboard line ");
   center("      Arrow Up     Switch Worlds Up 1  ");
   center("      Arrow Down   Switch Worlds Down 1");
   out_nolog();
   center("Commands: /dc             Disconnect from current world");
   center("          /world <world>  Connect / switch to <world>  ");
   center("          /dc             Disconnect from current world");
   center("          /reload         Reload the client's code     ");
   center("          /quit           Exit out of muTalk           ");
   out_nolog();                                                           

   read_tfworlds(".tfworlds");
   out_nolog("%% %d worlds loaded from .tfworlds file.",scalar keys %world);
};

#----------------------------------------------------------------------------#
#                                                                            #
#  commands                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#
@command{world}  = sub { return cmd_world(@_);                              };
@command{quit}   = sub { return cmd_quit(@_);                               };
@command{reload} = sub { return cmd_reload(@_);                             };
@command{dc}     = sub { return cmd_dc(@_);                                 };

sub cmd_dc
{
   my $sock = @state{focus};

   if(defined @sock{@state{focus}} && defined @sock{@state{focus}}->{sock}) {
      delete @sock{@state{focus}}->{sock};
      out_nolog("%% Connection closed to %s",@state{focus});
      update_bar(1);
   } else {
      out_nolog("%s",'%% Not Connected');
   }
}

sub cmd_reload
{
   my $file;
#   my $data = qq[#line 1 "$file"\n];
   my $data;
   my $before = length($data);

   open($file,$0) ||
     return err("%% Unable to read $0." );

   for my $line (<$file>) {
     #
     # ignore lines with #!#, This is the manual signal that these lines
     # should never be reloaded.
     $line =~ s/\r|\n//g;

     if(($line !~ /#!#/ && $line !~ /^#!/) || $line =~ /#!# ALWAYSLOADS/) {
        $data .= "$line\n";
     } else {
        $data .= "\n";
     }
   }
   close($file);
   out_nolog("%% Re-read %s containing %s bytes of data.",
             $0,
             length($data) - $before
            );

   open(CODE,"> code.txt") ||
      die("Could not open code.txt for writing");
   printf(CODE "%s",$data);
   close(CODE);

   eval($data);

   if($@) {
      out_nolog("----[ Compile Error ]----------");
      for my $line (split(/\n/,$@)) {
         out_nolog("%s",$line);
      }
   }
}

sub world_lookup
{
   my $txt = shift;
   my @partial;

   for my $key (keys %world) {
      if(lc($key) eq lc($txt)) {
         return $key;
      } elsif(lc($key) eq substr(lc($key),1,length($txt))) {
         push(@partial,$key);
      }
   }
   return ($#partial > 0) ? undef : @partial[0];
}


sub snd
{
   my ($world,$fmt,@arg) = @_;

   if(defined @sock{$world}
      && defined @sock{$world}->{sock}) {
      my $s = @sock{$world}->{sock};
      printf($s "$fmt\r\n",@arg) if $s;
   }
}

sub cmd_world
{
   my $txt = trim(shift);

   if((my $world = world_lookup($txt)) ne undef) {
      if(defined @sock{$world} && defined @sock{$world}->{sock}) {
         set_focus($world);
      } else {
         socket_connect($world,@world{$world}->{host},@world{$world}->{port});
         update_bar(1);

            out_nolog("%% attempt Sending conect '%s' '%s'",
                 @world{$world}->{user},
                 @world{$world}->{pass});
         if(@world{$world}->{user} ne undef &&
            @world{$world}->{pass} ne undef) {
            snd($world,"connect %s %s",
                 @world{$world}->{user},
                 @world{$world}->{pass}
                );
            out_nolog("%% Sending conect");
         }
      }
   } else {
      out_nolog('%% No such world "%s" exists',$txt);
   }
}

sub cmd_quit
{
   revert_console();
   exit(0);
}

sub read_tfworlds
{
   my $fn = shift;
   my ($file, $bad);

   open($file,$fn) ||
      return out_nolog("%% Unable to open '%s' for reading",$fn);
 
   while(<$file>) {
      s/\r|\n//g;
      if(/^\/test addworld\("([^"]+)", "([^"]*)", "([^"]*)", "([^"]*)", "([^"]*)", "([^"]+)"\)$/) {
         @world{$1} = {};
         @world{$1}->{host}     = $3;
         @world{$1}->{port}     = $4;
         @world{$1}->{user}     = $5;
         @world{$1}->{pass}     = $6;
       } elsif(/^\/test addworld\(\s*"([^"]*)"\s*,\s*"([^"]*)"\s*,\s*"([^"]*)"\s*,\s*"([^"]*)"\s*\)\s*$/) {
         @world{$1} = {};
         @world{$1}->{host}     = $3;
         @world{$1}->{port}     = $4;
      } else {
         $bad++;
         out_nolog("%% Unknown data: '%s'",$_);
      }
   }
}

sub code
{
   my $type = shift;
   my @stack;

   if(!$type || $type eq "short") {
      for my $line (split(/\n/,Carp::shortmess)) {
         if($line =~ /at ([^ ]+) line (\d+)\s*$/) {
            push(@stack,"$1:$2");
         }
      }
      return join(',',@stack);
   } else {
      return Carp::shortmess;
   }
}

sub next_world
{
   my ($first, $next);

   for my $world (sort keys %sock) {
      $first =  $world if($first eq undef);
      return $world if($next);
      $next = 1 if(@state{focus} eq $world);
   }
   return $first;
}

sub prev_world 
{
   my $prev;

   for my $world (sort keys %sock) {
      if(@state{focus} eq $world && $prev ne undef) {
         return $prev;
      }
      $prev = $world;
   }
   return $prev;
}

#----------------------------------------------------------------------------#
#                                                                            #
#  pmc support                                                               #
#                                                                            #
#----------------------------------------------------------------------------#

sub TELQUAL_IS { 0; }
sub TELQUAL_SEND { 1; }
sub TELOPT_MXP { 91; }
sub TELOPT_MSP { 90; }

sub negotiation {
    my ($conn, $option, $is_remote, $is_enabled, $was_enabled,
        $buf_position)= @_;
    $is_remote||=0;
    $is_enabled||=0;
    $was_enabled||=0;
    my ($noecho, $linemode);

#    debug("negotiation: $option rem:$is_remote is_en:$is_enabled ".
#          "was_en:$was_enabled");

    if ($option==TELOPT_TTYPE) {
        send_iac($conn,chr(TELNET_SB).
                 chr(TELOPT_TTYPE).
                 chr(TELQUAL_IS).
                 $ENV{TERM}.
                 chr(TELNET_IAC).
                 chr(TELNET_SE)
                );
    } elsif($option == TELOPT_NAWS) {
        send_naws($conn,1);
    } elsif ($option==TELOPT_ECHO) {
        if ($is_enabled) {
            $noecho=1;
        } else {
            $noecho=0;
        }
        switch_echo();
    } elsif ($option==TELOPT_SGA) {
        if ($linemode && $is_enabled) {
            debug('char-mode');
            ReadMode(4);
        } elsif (!$is_enabled && !$linemode) {
            debug('line-mode');
            ReadMode(0);
        }
        $linemode= !$is_enabled;
    } elsif ($option==TELOPT_MXP || $option==TELOPT_MSP) {
    } else {
    }
}

sub send_iac {
    my ($conn,$neg) = @_;

    syswrite $conn, chr(TELNET_IAC).$neg, length($neg)+1, 0;
}

sub check_mcp_naws {
   return 0;
}

sub send_naws {
    my ($conn,$from_telopt)= @_;

#    my ($height,$width)= $term->get_screen_size();
    my ($height,$width) = (24,80);
    if (check_mcp_naws() && !$from_telopt) {
        mcp_send('dns-com-vmoo-client-screensize',
                jols => $width, rows => $height);
    } else {
        send_iac($conn,chr(TELNET_SB).chr(TELOPT_NAWS).chr($width/256).
                 chr($width%256).chr($height/256).chr($height%256).
                 chr(TELNET_IAC).chr(TELNET_SE));
    }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  tcp code                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

#
# BEGIN statement with including code, and most of socket_connect were
# copied from from: http://aspn.activestate.com/ASPN/Mail/Message/
# perl-win32-porters/1449297.
#
BEGIN {
   # This nonsense is needed in 5.6.1 and earlier -- I'm too lazy to
   # test if it's been fixed in 5.8.0.
   if( $^O eq 'MSWin32' ) {
      *EWOULDBLOCK = sub () { 10035 };
      *EINPROGRESS = sub () { 10036 };
      *IO::Socket::blocking = sub {
          my ($self, $blocking) = @_;
          my $nonblocking = $blocking ? "0" : "1";
          ioctl($self, 0x8004667e, $nonblocking);
      };
   } else {
      require Errno;
      import  Errno qw(EWOULDBLOCK EINPROGRESS);
   }
}

sub socket_connect
{
   my ($world,$host,$port,$ssl) = @_;

   return if(!defined @world{$world});
   if(defined @sock{$world} && defined @sock{$world}->{sock}) {
      return out_nolog("%% Already connected to %s",$world);
   }
   clear_screen();
   @state{focus} = $world;
   @sock{$world} = {} if !defined @sock{$world};
   @sock{$world}->{host} = $host;
   @sock{$world}->{port} = $port;

   my $s = new Pmc::Telnet( $host, $port, $ssl, Timeout => 10);

   if(!$s) {
      return out_nolog("%% Connection Failed.");
   }

   $s->option_callback(\&negotiation);
   $s->option_accept( Do   => TELOPT_SGA,
                      Do   => TELOPT_TTYPE,
                      Do   => TELOPT_NAWS,
                      Do   => TELOPT_ECHO,
                      Dont => TELOPT_MXP,
                      Dont => TELOPT_MSP,
                      Wont => TELOPT_MXP,
                      Wont => TELOPT_MSP,
                      Will => TELOPT_SGA,
                      Will => TELOPT_TTYPE,
                      Will => TELOPT_NAWS,
                      Will => TELOPT_ECHO);
#   $listener->add($s);
   @sock{$world}->{sock} = $s;
   @sock_world{$s} = $world;
}

sub socket_handle_input
{
    for my $world (keys %sock) {

        if(defined @sock{$world}->{sock}) {
           my $conn = @sock{$world}->{sock};

           if($conn->eof()) {
              delete @sock{$world}->{sock};
              out_nolog("%% Connection closed to %s",$world);
              update_bar(1);
           } else {
              my @lines= $conn->getlines(Timeout=>0); # get from pmc::telnet
        
              for my $line (@lines) {
                 next unless $line;
                 $line =~ s/\r|\n//g;
                 out($world,"%s",$line);
              }
           }
        }
    }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  console code                                                              #
#                                                                            #
#----------------------------------------------------------------------------#

sub revert_console
{
   ReadMode 'normal';
   set_scroll_region("remove");
   goto_xy(24,1);
}

sub set_scroll_region
{
   my ($type) = @_;

   if(@state{region} eq $type || 
      ($type eq "remove" && !defined @state{region})) {
      return;
   }

   @state{region} = $type;
   if($type eq "key") {
      printf("\033[%s;%sr",@state{size_x} - 1,@state{size_x});
   } elsif($type eq "out") {
      printf("\033[1;%sr",@state{size_x} - 3);
   } elsif($type eq "remove") {
      printf("\033[r");
   } else {
      die("unknown scroll region '$type'");
   }
}


sub kb
{
   my $kb = @state{kbbuffer};

   if(@state{kbpos}) {
      return $$kb[@state{kbpos}];
   } else {
      return $$kb[$#$kb];
   }
}

sub kb_set
{
   my $data = shift;
   my $kb = @state{kbbuffer};

   $$kb[$#$kb] = $data;
}

sub kb_append
{
   my $data = shift;
   my $kb = @state{kbbuffer};

   if($#$kb == -1) {                                 # keyboard buffer empty
      push(@$kb,$data);                                      # add new entry
   } else {
      $$kb[$#$kb] .= $data;                             # append to existing
   }
}

sub kb_new_line
{
   my $kb = @state{kbbuffer};                                # add new line
   push(@$kb,"");
   delete @state{kbpos};
}

sub kb_handle_input
{
   if(kb() =~ /^\/([^ ]+)/) {
      if(defined @command{$1}) {
         &{@command{$1}}($');
      } else {
         out_nolog("%% Unknown command '/%s' called.",$1);
      }
   } elsif(defined @state{focus}) {
      snd(@state{focus},kb());
   }

   kb_new_line();
}

sub goto_xy
{
   my ($x,$y,$override) = @_;

   if($y <= 0) {                              # handle some sanity checks
      $y = 1;
   } elsif($y > @state{size_y}) {
      $y = @state{size_y};
   }

   if($x <= 0) {
      $x = 1;
   } elsif($x > @state{size_x}) {
      $x = @state{size_x};
   }

   if(@state{pos_x} != $x || @state{pos_y} != $y || $override) {# move as need
      if($x >= @state{size_x} - @state{size_i} +1) {     # track keyboard pos
         @state{key_x} = $x;
         @state{key_y} = $y;
      }
      @state{pos_x} = $x;                                  # track actual pos
      @state{pos_y} = $y;
      printf("\033[%s;%sH",$x,$y);
   } else {
#      out("skip: @state{pos_x} == $x && @state{pos_y} == $y");
   }
}

sub  highlight
{
   my $txt = shift;
 
   return sprintf("\033[7m%s\033[m",$txt);
}

sub more
{
   my $world = shift;

   if(!defined @sock{$world} || 
      !defined @sock{$world}->{pause}) {
      return @state{ch} x 6;
   } else {
      return highlight(" MORE ");
   }
}

#
# screen_size_changed
#    There might be a better way to do this, maybe the system can trigger
#    an update. Instead, for now, the code will excessively check the
#    terminal size for a change
#
sub screen_size_changed
{
   my ($size_y,$size_x) = GetTerminalSize();

   if(@state{size_y} != $size_y ||
      @state{size_x} != $size_x) {
      (@state{size_y},@state{size_x}) = ($size_y,$size_x);
      my $tmp = @state{focus};
      delete @state{focus};
      set_focus($tmp);
      $Text::Wrap::columns = $size_y;
      return 1;
   } else {
      return 0;
   }
}

sub set_new_bar_style
{
   if(@state{ch} eq undef) {
      @state{ch} = "_";
   } elsif(@state{ch} eq "_") {
      @state{ch} = "-";
   } elsif(@state{ch} eq "-") {
      @state{ch} = "=";
   } elsif(@state{ch} eq "=") {
      @state{ch} = "~";
   } elsif(@state{ch} eq "*") {
      @state{ch} = "_";
   }
}

sub update_bar
{
   my $do_update = shift;

   # check time
   my ($hr,$min) = ((localtime())[2,1]);
   $hr -= 12 if($hr > 12);
   my $cur = sprintf("%s:%02d",$hr,$min);

   my ($world, $size_y, $size_x);

   if(screen_size_changed() ||
      @state{prev_time} ne $cur ||                             # time changed
      @state{focus} ne @state{prev_focus} ||                  # world changed
      $do_update) {                                 # caller reuqested update

      set_new_bar_style();

      if(!defined @state{focus}) {
         $world = "None";
      } elsif(!defined @sock{@state{focus}} ||
         !defined @sock{@state{focus}}->{sock}) {
         $world = @state{focus} . "-Offline";
      } else {
          $world = @state{focus};
      }

      set_scroll_region("remove");
      goto_xy(@state{size_x} - 2,1);

      printf("%s[%s]%s[%s]%s",
         more($world),
         substr($world,0,15),
         @state{ch} x (@state{size_y} - length($cur.substr($world,0,15))-12),
         $cur,
         @state{ch} x 2
      );
      @state{prev_time} = $cur;
      @state{prev_focus} = @state{focus};
      display_cursor();
   }
}

sub out_nolog
{
   my ($fmt,@arg) = @_;
   my $txt = shift;

   set_scroll_region("out");
   goto_xy(@state{size_x} - 3,1);
   printf("%s",wrap('','',sprintf("\n$fmt",@arg)));
   display_cursor();
}

#----------------------------------------------------------------------------#
#                                                                            #
#  misc                                                                      #
#                                                                            #
#----------------------------------------------------------------------------#

#
# reset the terminal, display the error
#
sub err
{
   my ($fmt,@args) = @_;

   revert_console();
   printf("Err: $fmt\n",@args);
   exit(0);
}

#
# remove any space at the begining or end of a string
#
sub trim
{
   my $txt = shift;

   $txt =~ s/^\s+|\s+$//g;
   return $txt;
}
sub tick
{
    for my $world (keys %sock) {
        next if (!defined @sock{$world}->{sock});

        if(!defined @sock{$world}->{idle}) {
           @sock{$world}->{idle} = time();
        } elsif(time() - @sock{$world}->{idle} > 300) {
           @sock{$world}->{idle} = time();
           snd($world,"think # idle tick #");
        } 
    }
}


sub filter_modify
{
   my ($world,$fmt,@args) = @_;
   my $txt = sprintf($fmt,@args);

   if($txt=~ /^\[([^\]]+)\(([^\]]+)\)([^\]]*)\] /) {
      return $';
   } elsif($txt=~ /^\[([^:]+):\] /) {
      return $';
   } else {
      return $txt;
   }
}

sub filter_gag
{
   return 0;
}

sub to_fast
{
   my $world = shift;

   if(!defined @world_history{$world} ||
      $#{@world_history{$world}} < 10) {
      return 0;
   }

   my $array = @world_history{$world};
   my $hash = $$array[$#$array - 10];

   if(time() - $$hash{ts}  <=  1) {
      return 1;
   } else {
      return 0;
   }
}

sub out
{
   my ($world,$fmt,@arg) = @_;
   my $filtered_txt;

   my $filtered_txt = filter_modify($world,$fmt,@arg);

   if(!filter_gag($world,$fmt,@arg)) {
      if(defined @sock{$world} &&
         !defined @sock{$world}->{pause} &&
         to_fast($world)) {
         @sock{$world}->{pause} = $#{@world_history{$world}} + 1;
         update_bar(1) if($world eq @state{focus});
      } elsif(defined @sock{$world} && defined @sock{$world}->{pause}) {
         # do nothing
      } elsif($world eq @state{focus}) {
         set_scroll_region("out");
         goto_xy(@state{size_x} - 3,1);
         printf("\n%s",wrap('','',$filtered_txt));
         display_cursor();
      }
   }

   # initialize buffer if needed.
   @world_history{@state{focus}} = [] if(!defined @world_history{$world});

   my $history = @world_history{$world};
   push(@$history,{ txt => $filtered_txt,
                    ts => time(),
                    original => sprintf($fmt,@arg)
                  }
       );
}

sub key
{
   my $key = shift;

#   if(ord($key) != 127 && $key ne "\n") {
#     out("pressed: %s $key",ord($key));
#   }

   set_scroll_region("key");

   if(defined @state{key_buffer}) {
      my $buf = @state{key_buffer};
      if($#$buf == 0 && $key eq "[") {
         push(@$buf,$key);
         return;
      } elsif($#$buf == 1 && $key eq "A") {                       # up arrow
         delete @state{key_buffer};
         set_focus(next_world());
         return;
      } elsif($#$buf == 1 && $key eq "B") {                      # down arrow
         delete @state{key_buffer};
         set_focus(prev_world());
         return;
      } elsif($#$buf == 1 && $key eq "C") {                     # right arrow
         delete @state{key_buffer};
         out_nolog("Arrow right ");
         return;
      } elsif($#$buf == 1 && $key eq "D") {                     # left arrow
         delete @state{key_buffer};
         out_nolog("Arrow left");
         return;
      } else {                                                      # no idea
         delete @$buf[0];
         $key = join('',@$buf) . $key;
         delete @state{key_buffer};
      }
   }

#   out_nolog("KEY: '%s' -> '%s'\n",$key,ord($key));
   if($key eq "\n") {                                            # end of line
      kb_handle_input();
      if(@state{key_x} + 1 < @state{size_x}) {
         @state{key_x}++;
      } else {
         goto_xy(@state{key_x},@state{key_y});
         printf("\n");
      }
      @state{key_x}++;
      @state{key_y} = 1;
      goto_xy(@state{key_x},@state{key_y});
   } elsif(ord($key) == 9) {                                             # tab
      if(defined @sock{@state{focus}} &&
         defined @sock{@state{focus}}->{pause}) {
         my $start = @sock{@state{focus}}->{pause};
         my $end = $start + @state{size_x} - @state{size_i} - 1;
         my $buf = @world_history{@state{focus}};
         $end = $#$buf if($end > $#$buf);

         for my $i ($start .. $end) {
            out_nolog("%s",@{$$buf[$i]}{txt});
         }
         if($end == $#$buf) {
            delete @sock{@state{focus}}->{pause};
            update_bar(1);
         } else {
            @sock{@state{focus}}->{pause} = $end;
         }
      }
   } elsif(ord($key) == 16) {                                      # control-p
      out_nolog("Focus: @state{focus} == @state{prev_focus}");
   } elsif(ord($key) == 21) {                                      # control-U
      @state{key_y} = 1;                            # delete all previous input
      kb_new_line();
      printf("\033[1K");
      goto_xy(@state{key_x},@state{key_y});
   } elsif(ord($key) == 127) {                                    # delete key
      @state{key_y}--;
      kb_set(substr(kb(),0,length(kb())-1));
      goto_xy(@state{key_x},@state{key_y},1);
      printf("\033[P");
   } elsif(ord($key) == 27) {                                         # escape
      @state{key_buffer} = [ $key ];
   } else {                                                  # everything else
      kb_append($key);
      goto_xy(@state{key_x},@state{key_y});
      @state{key_y}++;
      printf("%s",$key);
   }
}

sub display_cursor
{
   set_scroll_region("key");
   goto_xy(@state{key_x},@state{key_y});
}

sub clear_screen
{
    set_scroll_region("out");
    for my $line (0 .. @state{size_x}) {
       out_nolog("\n");
       out_nolog("\033[K");
    }
}

sub set_focus
{
   my $world = shift;
   my $start;

   if($world eq undef) {
      # ignore
   } elsif(!defined @world{$world}) {
      out_nolog("%% No such world '%s'.",$world);
   } elsif($world ne @state{focus}) {
      @state{focus} = $world;

      @world_history{$world} = [] if(!defined @world_history{$world});
      my $history = @world_history{$world};
      for my $i (reverse 0 .. @state{size_x}) {
         my $pos = $#$history - $i;
         if($pos < 0) {
            out_nolog("\n");
            out_nolog("\033[K");
         } else {
            out_nolog("%s",@{$$history[$pos]}{txt});
         }
      }
      display_cursor();
   }
}

sub center
{
    my $txt = shift;

    out_nolog("%s%s",(" " x ((@state{size_y} - length($txt)) / 2)),$txt);
}

sub main
{
   eval {
      local $SIG{__DIE__} = sub {
         out_nolog("----- [ Crash REPORT\@ %s ]-----\n",scalar localtime());
         out_nolog("%s",code("long"));
      };

      update_bar();
      socket_handle_input();
      tick();

      my $key = ReadKey(1);                            # handle keyboard input
      next unless defined $key;

      key($key);
   };
   if($@) {
      out_nolog("%s",$@);
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  main.c                                                                    #
#                                                                            #
#----------------------------------------------------------------------------#

init();                                                                    #!#

while(1) {                                               #!# call main loop
   main();                                               #!# but don't reload
};                                                       #!#
