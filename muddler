#!/usr/bin/perl -I .
#-#             ( A 1990dies mud client written today )    
#-#          O                       ___   ___ _               
#-#      o _____    _____  __ __  __| _/__| _/| |  ___________ 
#-#    _||_| u |   /     \|  |  \/ __ |/ __ | | | / __ \_  __ \
#-#   (        |==|  Y Y  \  |  / /_/ / /_/ | | |_\  __/|  | \/
#-#   /-()---()   |__|_|__/____/\____/\_____/ |___/\___/|__|   

use strict;
# use Monitor qw(monitor);
use Term::ReadKey;
use Text::ParseWords;
use Digest::MD5;
use Pmc::Telnet qw( TELOPT_SGA TELOPT_TTYPE TELOPT_NAWS TELOPT_NEW_ENVIRON
                     TELNET_IAC TELNET_SB TELNET_SE TELOPT_ECHO);
use Carp;
my %key;                            # key presses hash table for fast lookups
my %history;                                                  # world history
my %socket;                                              # socket information
my %command;                            # command hash table for fast lookups
my %pending;                                            # unseen world output
my %address;                                                # world addresses 
my @input;                                                    # input history

my %state = (
   line_pos => 0,                     # character position on the current line
   size_x => 24,                                 # size of screen horizontally
   size_y => 80,                              # size of the screen veritically
   input_size => 2,
   input_offset => 0,                        # lines scrolled off input buffer
   input_pos => -1,                                 # location in input history
   line => [],                                             # curent input line
   pending => {}
);


#----------------------------------------------------------------------------#
#                                                                            #
#  ansi support                                                              #
#    Routines taken from teenymush. This should probably be turned into a    #
#    module if i liked using multiple files.                                 #
#                                                                            #
#----------------------------------------------------------------------------#
#
# ansi_debug
#    Convert an ansi string into something more readable.
#
sub ansi_debug
{
    my $txt = shift;

    $txt =~ s/\e/<ESC>/g;
    return $txt;
}


#
# ansi_char
#    Returns one character of the current string. Due to the nature of the
#    ansi functions, this will only return characters not in ansi character
#    strings. While this is silly to use a function to do this, this helps
#    abstract the data set for situations in which the ansi functions are
#    replaced by standard string functions.
#
sub ansi_char
{
   my ($data,$pos) = @_;

   return @{$$data{ch}}[$pos];
}


sub is_ansi_string
{
   my $txt = shift;

   if(ref($txt) ne "HASH" ||
      !defined $$txt{ch} ||
      !defined $$txt{snap} ||
      !defined $$txt{code}) {
      return 0;
   } else {
      return 1;
   }
}


sub ansi_reset
{
   my ($data,$pos) = @_;

   my $string = (is_ansi_string($data)) ? $data : ansi_init($data);

   printf("Ansi_reset: returning\n") if $pos < 0;
   return $string if $pos < 0;                               # sanity check

   my $code = $$string{code};
   my $array = $$code[$pos];

   # check to see if the last code is a reset, or no codes at all
   if($#$array == -1 || $$array[$#$array] ne "\e[0m") {
      push(@$array,"\e[0m");
   }
   return $string;
}
#
# ansi_add
#   Add a character or escape code to the data array. Every add of a
#   character results in a new element, escape codes are added to existing
#   elements as long as a character has not been added yet. The ansi state
#   is also kept track of here.
#
sub ansi_add
{
   my ($data,$type,$txt) = @_;

   my $ch   = $$data{ch};                      # make things more readable
   my $code = $$data{code};
   my $snap = $$data{snap};

   if($#$ch == -1 || $$ch[$#$ch] ne undef) {
      $$ch[$#$ch+1] = undef;
      $$code[$#$ch] = [];
      $$snap[$#$ch] = [];
   }

   if($type) {
     for my $c (split(//,$txt)) {                 # add multiple characters
        $$ch[ $#$ch + ((@$ch[$#$ch] ne undef) ? 1 : 0) ] = $c;
        @$code[$#$ch] = [] if(!defined @$code[$#$ch]);
        @$snap[$#$ch] = [ @{@$data{state}} ];
     }
   } else {                                           # add escape sequence
      push(@{$$code[$#$ch]},$txt);
      if($txt eq "\e[0m") {
         $$data{state} = [];
      } else {
         push(@{$$data{state}},$txt);
      }
   }
}


#
# ansi_init
#    Read in a string and convert it into a data structure that can be
#    easily parsed / modified, i hope.
#
#     {
#       code => [ [ array of arrays containing escape codes ] ]
#       ch   => [ Array containing each character one by one ]
#       snap => [ [ array of arrays containing all active escape codes
#                   at the time the character was encountered ] ]
#       state=> [ internal, current state of active escape does ]
#     }
#
sub ansi_init
{
   my $str = shift;

   my $data = { ch => [], code => [], state  => [], snap   => [] };

   while($str =~ /\e\[([\d;]*)([a-zA-Z])/) {
      $str = $';
      ansi_add($data,1,$`) if $` ne undef;
      ansi_add($data,0,"\e[$1$2");
   }
   ansi_add($data,1,$str) if($str ne undef);

   return $data;
}

#
# ansi_clone
#   Clone the ansi escape codes at a particular position to the new
#   string.
#
sub ansi_clone
{
   my ($str,$pos,$txt) = @_;

   if(ref($str) ne "HASH") {
      $str = ansi_init($str);
   }

   my $snap = $$str{snap};

   if($#$snap >= 0 && $#$snap > $pos) {
      return join('',@{@$snap[$pos]}) . $txt . "\e[0m";
   } else {
      return $txt;
   }
}

#
# ansi_string
#    Take ansi data structure and return
#        type => 0 : everything but the escape codes
#        type => 1 : original string [including escape codes]
#
sub ansi_string
{
   my ($data,$type) = @_;
   my $buf;

   for my $i (0 .. $#{$$data{ch}}) {
      $buf .= join('', @{@{$$data{code}}[$i]}) if($type);
      $buf .= @{$$data{ch}}[$i];
   }
   return $buf;
}

#
# ansi_substr
#    Do a substr on a string while preserving the escape codes.
#
#    no-ansi flag : do not copy over escape sequences
#
sub ansi_substr
{
   my ($txt,$start,$count,$noansi) = @_;
   my ($result,$data);
   my $last = -1;

   if(ref($txt) eq "HASH") {
      $data = $txt;
   } else {
      $data = ansi_init($txt);
   }

   $start = 0 if($start !~ /^\s*\d+\s*$/);                  # sanity checks
   if($count !~ /^\s*\d+\s*$/) {
      $count = ansi_length($txt);
   } else {
      $count += $start;
   }
   return undef if($start < 0);                         # no starting point

   # loop through each "character" w/attached ansi codes
   for(my $i = $start;$i < $count && $i <= $#{$$data{ch}};$i++) {
      if(!$noansi) {
         my $code=join('',@{@{$$data{($i == $start) ? "snap" : "code"}}[$i]});
         $result .= $code . @{$$data{ch}}[$i];
      } else {
         $result .= @{$$data{ch}}[$i];
      }
      $last = $#{@{$$data{snap}}[$i]};
   }

   # are attributes turned on on last character? if so, reset them.
   return $result . (($last == -1) ? "" : (chr(27) . "[0m"));
}

#
# ansi_length
#    Return the length of a string without counting all those pesky escape
#    codes.
#
sub ansi_length
{
   my $txt = shift;
   my $data = shift;

   if(ref($txt) eq "HASH") {                           # already inited txt?
      $data = $txt;
   } else {
      $data = ansi_init($txt);
   }

   if($#{$$data{ch}} == -1) {                                       # empty
      return 0;
   } elsif(@{$$data{ch}}[-1] eq undef) {               # last char pos empty?
      return $#{$$data{ch}};
   } else {
      return $#{$$data{ch}} + 1;                        # last char populated
   }
}
#
# ansi_remove
#    remove any escape codes from the string
#
sub ansi_remove
{
#   my $txt = ansi_init(shift);
#   return ansi_print($txt,0);

   my $txt = shift;
   $txt =~ s/\e\[[\d;]*[a-zA-Z]//g;
   return $txt;
}


#----------------------------------------------------------------------------#
#                                                                            #
#  pmc support                                                               #
#                                                                            #
#----------------------------------------------------------------------------#

sub TELQUAL_IS   { 0; }
sub TELQUAL_SEND { 1; }
sub TELOPT_MXP   { 91; }
sub TELOPT_MSP   { 90; }

sub negotiation {
    my ($conn, $option, $is_remote, $is_enabled, $was_enabled,
        $buf_position)= @_;
    $is_remote||=0;
    $is_enabled||=0;
    $was_enabled||=0;
    my ($noecho, $linemode);

#    debug("negotiation: $option rem:$is_remote is_en:$is_enabled ".
#          "was_en:$was_enabled");

    if ($option==TELOPT_TTYPE) {
        send_iac($conn,chr(TELNET_SB).
                 chr(TELOPT_TTYPE).
                 chr(TELQUAL_IS).
                 $ENV{TERM}.
                 chr(TELNET_IAC).
                 chr(TELNET_SE)
                );
    } elsif($option == TELOPT_NAWS) {
        send_naws($conn,1);
    } elsif ($option==TELOPT_ECHO) {
        if ($is_enabled) {
            $noecho=1;
        } else {
            $noecho=0;
        }
        switch_echo();
    } elsif ($option==TELOPT_SGA) {
        if ($linemode && $is_enabled) {
            debug('char-mode');
            ReadMode(4);
        } elsif (!$is_enabled && !$linemode) {
            debug('line-mode');
            ReadMode(0);
        }
        $linemode= !$is_enabled;
    } elsif ($option==TELOPT_MXP || $option==TELOPT_MSP) {
    } else {
    }
}

sub send_iac {
    my ($conn,$neg) = @_;

    syswrite $conn, chr(TELNET_IAC).$neg, length($neg)+1, 0;
}

sub check_mcp_naws {
   return 0;
}

sub send_naws {
    my ($conn,$from_telopt)= @_;

#    my ($height,$width)= $term->get_screen_size();
    my ($height,$width) = (24,80);
    if (check_mcp_naws() && !$from_telopt) {
        mcp_send('dns-com-vmoo-client-screensize',
                jols => $width, rows => $height);
    } else {
        send_iac($conn,chr(TELNET_SB).chr(TELOPT_NAWS).chr($width/256).
                 chr($width%256).chr($height/256).chr($height%256).
                 chr(TELNET_IAC).chr(TELNET_SE));
    }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  tcp code                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

#
# BEGIN statement with including code, and most of socket_connect were
# copied from from: http://aspn.activestate.com/ASPN/Mail/Message/
# perl-win32-porters/1449297.
#
# BEGIN {
#    # This nonsense is needed in 5.6.1 and earlier -- I'm too lazy to
#    # test if it's been fixed in 5.8.0.
#    if( $^O eq 'MSWin32' ) {
#       *EWOULDBLOCK = sub () { 10035 };
#       *EINPROGRESS = sub () { 10036 };
#       *IO::Socket::blocking = sub {
#           my ($self, $blocking) = @_;
#           my $nonblocking = $blocking ? "0" : "1";
#           ioctl($self, 0x8004667e, $nonblocking);
#       };
#    } else {
#       require Errno;
#       import  Errno qw(EWOULDBLOCK EINPROGRESS);
#    }
# }

sub socket_connect
{
   my ($world,$host,$port,$ssl) = ( lc(shift), @_ );

   if(defined @socket{$world} && @socket{$world}->{sock}) {
      return echo("%% Already connected to %s",$world);
   }

   @history{$world} = [];
   @pending{$world} = [] if !defined @pending{$world};
   @socket{$world} = { name      => $world,
                       host      => $host,
                       port      => $port,
                       more      => 0,
                       more_last => 0,
                       last_read => -1,
                       lnum      => 0,
                     };
   @state{world} = $world;
   @socket{$world}->{pos} = scalar keys %socket;

   my $s = new Pmc::Telnet( $host, $port, $ssl, Timeout => 10);
   key_log("name=$world,host=$host,port=$port");

   if(!$s) {
      update_bar();
      return echo("%% Connection Failed.");
   }

   $s->option_callback(\&negotiation);
   $s->option_accept( Do   => TELOPT_SGA,
                      Do   => TELOPT_TTYPE,
                      Do   => TELOPT_NAWS,
                      Do   => TELOPT_ECHO,
                      Dont => TELOPT_MXP,
                      Dont => TELOPT_MSP,
                      Wont => TELOPT_MXP,
                      Wont => TELOPT_MSP,
                      Will => TELOPT_SGA,
                      Will => TELOPT_TTYPE,
                      Will => TELOPT_NAWS,
                      Will => TELOPT_ECHO);
   @socket{$world}->{sock} = $s;
   echo("%% Connection to %s succeeded.",$world);
   if(defined @address{$world}->{user} && defined @address{$world}->{pass}) {
      out($world,
           "connect %s %s\n",
           @address{$world}->{user},
           @address{$world}->{pass}
          );
   }
   update_bar();
}

sub socket_handle_input
{
   for my $world (keys %socket) {
      if(@socket{$world}->{sock}) {
         if(@socket{$world}->{sock}->eof()) {
            delete @socket{$world}->{sock};
            pending($world,"% Connection closed to ". name($world));
            update_bar();
         } else {                 # favor keyboard input not socket in timeout
            my @lines = @socket{$world}->{sock}->getlines(Timeout=>0);
            if($#lines >= 0) {
               for my $i (0 .. $#lines) { 
                  pending($world,@lines[$i]);
               }
            }
         }
      }
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  console code                                                              #
#                                                                            #
#----------------------------------------------------------------------------#

#
# echo
#    Echo something to the screen and also log that output into the history
#    see echo_nolog if it shouldn't be logged to the current history.
#
sub echo
{
   my $txt;

   if(ref(@_[0]) eq "HASH") {             # probably directly from pending()
      $txt = shift;
   } else {
      my ($fmt,@args) = @_;
      $txt = { txt       => sprintf($fmt,@args),
               ts        => time(),                              # add entry
               gagged    => 0,                            # was line gagged?
               pend_code => code(),
               internal  => 1,
             };
      if(defined @state{world} && defined @socket{@state{world}}) {
         $$txt{td} = @socket{@state{world}}->{lnum}++,
      }
   }

   history(@state{world},$txt) if defined @state{world};
 
   update_scroll_region("output");
   xy(output_end(),1);
   printf("\n%s",$$txt{txt});
   update_scroll_region("input");
   xy(input_x(),input_y());
}

sub echo_nolog
{
   my $txt;

   if(ref(@_[0]) eq "HASH") {
      $txt = shift;
   } else {
      my ($fmt,@args) = @_;
      $txt = { txt    =>  sprintf($fmt,@args),
               ts     => time(),                             # add entry
               gagged => 0,                              # was line gagged?
             };
      if(defined @state{world} && defined @socket{@state{world}}) {
         $$txt{td} = @socket{@state{world}}->{lnum}++,
      }
   }

#   pending($txt);
 
   update_scroll_region("output");
   xy(output_end(),1);
   printf("\n%s",$$txt{txt});
   update_scroll_region("input");
   xy(input_x(),input_y());
}
#
# pausable_check
#    Check to see if the socket should have "more" turned on based upon
#    activity, weather conditions, and whatever else I think of.
#
sub more_check
{
   my $w = lc(shift);
   my ($last, $count);

   return if($w eq undef || !defined @history{$w} || !defined @pending{$w});

   if($#{@pending{$w}} > @state{size_y} * .90) {
      @socket{$w}->{more} = 1;
      return;
   }

   my $pend = @pending{$w};
   for my $i (0 .. $#$pend) {
      if($last ne undef && $$pend[$i]->{ts} - $last < 3) {
         $count++;
      }
      $last = $$pend[$i]->{ts};
   }

   if($count >= 5) {
      @socket{$w}->{more} = 1;
      return;
   }

   my $hist = @history{$w};
   for(my $i=$#$hist;$i >= 0 && time() - $$hist[$i]->{ts} > 300;$i--) {
      if($last ne undef && $$hist[$i]->{ts} - $last < 3) {
         $count++;
      }
      $last = $$hist[$i]->{ts};
   }

   if($count >= 5) {
      @socket{$w}->{more} = 1;
      return;
   }
}

sub more_update
{
   my $w = shift;

   return if(!defined @pending{$w} || !more($w));

   update_bar();
   if($#{@pending{$w}} >= 0) {
      @socket{$w}->{more_needed} = 1;
   } else {
      @socket{$w}->{more_needed} = 0;
      @socket{$w}->{more} = 0;
   }
}

sub paused
{
   my $w = shift;

   if(@socket{$w}->{more} == 1 && @socket{$w}->{more_needed} == 1) {
      return 1;
   } else {
      return 0;
   }
}

sub on_world
{
   return (@state{world} eq @_[0]) ? 1 : 0;
}

#
# more
#    Show the status for the current world and optionally fix it.
#
sub more
{
  my $world = shift;
  $world = @state{world} if($world eq undef);
  if(@socket{$world}->{more} == 1) {
     if($#{@pending{$world}} == -1) {
        delete @socket{$world}->{more};
        return 0;
     }
     return 1;
   } else {
     return 0;
   }
}

sub recent
{
   my ($world,$howlong) = @_;
   my $count = 0;

   key_log("recent: start");

   my $array = @pending{$world};
   for(my $i = $#$array;$i >= 0 && time() - $$array[$i]->{ts} < $howlong; $i--){
      $count++;
   }

   my $array = @history{$world};
   key_log("LAST: '%s' '%s'\n",@socket{$world}->{more_last},$#$array);
   for(my $i = $#$array;
       $i >= 0 && $i >= @socket{$world}->{more_last} && 
       time() - $$array[$i]->{ts} < $howlong;
       $i--){
      # always count original to make counting easier but not gagged.
      # In the situation of a text being replaced, we technically we should
      # count just the modifed version but then you have figure out how to
      # count the original version when not modified. Gagged output should
      # never be "original".
      if($$array[$i]->{original} || !$$array[$i]->{gagged}) { # don't count 
         $count++;
      }
   }
   key_log("recent: end [$count]");
   return $count;
}

sub replace
{
   my ($world,$txt) = @_;

   if($txt =~ /^\[([^\]]+)\(([^\]]+)\)([^\]]*)\] / ||
      $txt =~ /^\[([^:]+):\] /)  {
      return $';
   }
   return undef;
}

sub pending_add
{
   my ($world,$line) = @_;

   my $array = @pending{$world};
   my $gagged = 0;

   my $modified= replace($world,$line);
   if($modified ne undef) {
      $$array[$#$array+1] = { txt       => $modified,
                              id        => @socket{@state{world}}->{lnum}++,
                              ts        => time(),             # add entry
                              gagged    => 0,             # was line gagged?
                              pend_code => code(),
                              original  => $#$array + 2,
                              internal  => 0,
                             };
      $gagged = 1;
   }

   $$array[$#$array+1] = { txt       =>  $line,
                           id        => @socket{@state{world}}->{lnum}++,
                           ts        => time(),             # add entry
                           gagged    => $gagged,     # was line gagged?
                           pend_code => code(),
                           original  => 1
                          };

   if(!more($world) && on_world($world) && 
      recent($world,30)  > @state{size_x} * .55) {
      @socket{$world}->{more} = 1;
      @socket{$world}->{more_needed} = 1;
#   } else {
#      key_log("SPEED_COUNT: %s < %s[%s]",
#              recent($world,30),
#              @state{size_x} * .55,
#              @socket{$world}->{more});
  }
}

#
# pending
#    add a line of input into the pending queue
#
sub pending
{
   my ($world,$txt,$gagged) = @_;
   $txt =~ s/\r|\n//g;

   return if @state{world} eq undef;
   @pending{$world} = [] if !defined @pending{$world};

   if($txt eq undef) {
      pending_add($world,"");
   } else {
      for my $line (ansi_wrap($txt)) {
         pending_add($world,$line);
      }
   }

   if(on_world($world) && !paused($world)) {
      show_output($world);
   } else {
      @state{activity}->{$world} = 1;
   }
}

sub history
{
   my ($world,$data) = @_;

   if(ref($data) ne "HASH") {
      key_log("Invalid data type found[%s]: %s\n",code(),$data);
   } elsif(!defined $$data{pend_code}) {
      key_log("No pending code[%s]: %s\n",code(),print_var($data));
   } else {
      $$data{history_code} = code();
      push(@{@history{$world}},$data);
   }
}

sub show_output
{
   my $flag = shift;
   my $w = @state{world};
   my $count = 0;

   return if $w eq undef;
   more_check($w);
   return if(paused($w));

   while($#{@pending{$w}} >= 0 && $count < @state{size_x} - 3) {
      my $txt = shift(@{@pending{$w}});

      if(!$$txt{gagged}) {
         echo($txt);
      } else {
         history($w,$txt);
      }
      $count++;
   }
   delete @state{activity}->{$w} if defined @state{activity}->{$w};

   more_update($w);
}

sub line_start_pos
{
   return @state{size_x} - 2;
}

#
# return the X position of the input cursor
#
sub input_x
{
   my $x = input_start() + 
           sprintf("%d",(@state{line_pos} - 
                        ((@state{size_y} - 1) * @state{input_offset})) /
                        (@state{size_y} - 1));
   

   if($x > @state{size_x}) {
      return @state{size_x};
   } else {
      return $x;
   }
}

#
# return the Y position of the input cursor
#
sub input_y
{
   return 1 + (@state{line_pos} % (@state{size_y} - 1));
}

#
# define all functions here so they can be reloaded.
#
sub key_init
{
   delete @key{keys %key};
   @key{def}         = sub { return key_default(@_);             };
   @key{4}           = sub { return key_dump(@_);                };
   @key{9}           = sub { return key_tab(@_);                 };
   @key{10}          = sub { return key_return(@_);              };
   @key{12}          = sub { return key_ctl_l(@_);               };
   @key{14}          = sub { return key_ctl_n(@_);               };
   @key{16}          = sub { return key_ctl_p(@_);               };
   @key{18}          = sub { return key_ctl_r(@_);               };
   @key{21}          = sub { return key_ctl_u(@_);               };
   @key{23}          = sub { return key_ctl_w(@_);               };
   @key{27}          = sub { return key_escape(@_);              };
   @key{127}         = sub { return key_delete(@_);              };
   @key{multi}       = sub { return key_multi(@_);               };
   @key{multi_119}   = sub { return key_esc_w(@_);               };
   @key{multi_91_65} = sub { return key_up(@_);                  };
   @key{multi_91_66} = sub { return key_down(@_);                };
   @key{multi_91_67} = sub { return key_right(@_);               };
   @key{multi_91_68} = sub { return key_left(@_);                };
}



sub output_end
{
   return @state{size_x} - @state{input_size} - 1;
}

sub ansi_wrap
{
   my $txt = shift;
   $txt =~ s/[\n\r]+$//g;
   my $str = ansi_init($txt);
   my ($start,$last,$len,@out) = (0);

   for my $i (0 .. $#{$$str{ch}}) {
      if(ansi_char($str,$i) =~ /[ ,]/ && $i - $start <= @state{size_y} - 1) {
         $len = $i + 1;                           # scan for breaking points
      }

      if($i - $start >= @state{size_y} - 1) {       # past max, use last point
         # use $len unless at end of string or no breakpoints found
         my $cut = ($#{$$str{ch}} == $i || $len eq undef) ? $i : $len;
         push(@out,ansi_substr($str,$start,$cut - $start));
         $start = $cut;
         $len = undef;
      }
   }

   # add left overs.
   push(@out,ansi_substr($str,$start)) if($start < $#{$$str{ch}});
   return @out;
}

sub rewrap
{
   my ($world,$hist,$txt) = @_;

   if(!defined @history{$world} && !defined @history{$world}->[$hist]) {
      return;
   }

   # input already defined, use it
   if(defined @history{$world}->[$hist]->{txt}) { 
      $txt = join("",@{@history{$world}->[$hist]->{txt}});
   }
   $txt =~ s/([\r\n]+)$//g;                         # remove ending return(s)

   @history{$world}->[$hist]->{txt} = ansi_wrap($txt); # update entry
   @history{$world}->[$hist]->{size} = @state{size_y};
  
   if($#{@history{$world}->[$hist]->{txt}} == -1) {
      @history{$world}->[$hist]->{txt} = [ "" ];
   }
}

sub redraw_output
{
   my $flag = shift;                       # don't show internal messages?
   my ($y,@out,$paused);
   my ($start,$last) = @_;
   my $count;

   my $w = @state{world};

   more_check($w);
   if($w ne undef) {
      if(!paused($w)) {
         # populate history with some new entries
         
         my $pend = @pending{$w};
         for(my $i=0;$#$pend >= 0 && $count <= output_end() * 0.55;$i++) {
            $count++ if(!$$pend[$#$pend]->{gagged});
            history($w,shift(@$pend));
         }
         more_update($w);
      }

      # show old history + recently added entries
      my $hist = @history{$w};
      for(my $i=$#$hist;$#out <= output_end()-1 && $i >= 0;$i--) {
         if(!$$hist[$i]->{gagged} && (!$flag ||
            $flag && $$hist[$i]->{internal} == 0)) {
            if($$hist[$i]->{internal} <= 1) {
               unshift(@out,@{$$hist[$i]}{txt});
            }
            $$hist[$i]->{internal}++ if($$hist[$i]->{internal} == 1);
         }
      }
   }

   for my $i (1 .. (output_end() - $#out + 1)) { # fill in any blank lines
      unshift(@out,"\033[K");
   }

   # send the screen
   for my $i (0 .. $#out) { 
      echo_nolog("%s",@out[$i]);
   }

   # move cursor back to input area
   xy(input_x(),input_y());
}

sub redraw_input
{
   update_scroll_region("input",1);
   key_log("input_start: '%s' '%s'\n",input_start(),input_x());
   xy(input_start(),1,1);
   my $start = @state{input_offset}+1;
   my $end = $start + @state{input_size} - 1;
   for my $i ($start .. $end) {
      printf("%s\033[K%s",input_line($i),($i != $end) ? "\n" : "");
   }
   xy(input_x(),input_y(),1);
}

sub redraw_screen
{
   my $flag = shift;

   key_log("redraw_screen: start");
   my $clear = shift;
   printf("\033[r\033[2J") if $clear;
   clear_screen();
   redraw_output($flag);
   update_bar(1);
   redraw_input();
   key_log("redraw_screen: end`");
}

sub key_dump
{
   my $file;

   key_log("Dumping files");

   for my $key (keys %history) {
      open($file,"> history.$key.log") || return;
      printf($file "%s\n",print_var(@history{$key}));
      close($file);
   }

   for my $key (keys %pending) {
      open($file,"> pending.$key.log") || return;
      printf($file "%s\n",print_var(@pending{$key}));
      close($file);
   }
}

#
# key_ctl_p
#    Move down into the keyboard input history
#
sub key_ctl_p
{
   # current input has data, lets store it
   if($#{@state{line}} >= 0 && @state{input_pos} == -1) { # store current input
      unshift(@input,@state{line});
      @state{input_pos}++;
   } 
   if(@state{input_pos} < $#input) {           # move down in keyboard history
      @state{line} = @input[++@state{input_pos}];
      @state{line_pos} = $#{@input[@state{input_pos}]} + 1;
      redraw_input();
   }
}

#
# key_ctl_p
#    Move up in the keyboard input history
#
sub key_ctl_n
{
   if(@state{input_pos} == 0) {            # input empty, start with new line
      @state{line} = [];
      @state{line_pos} = 0;
      @state{input_pos} = -1;
      redraw_input();
   } elsif(@state{input_pos} > 0) {         # input availible, move up in hist
      @state{line} = @input[--@state{input_pos}];
      @state{line_pos} = $#{@input[@state{input_pos}]} + 1;
      redraw_input();
   }
}

sub key_ctl_r
{
   key_log("Reloading code");
   reload_code();
}

sub key_ctl_l
{
   redraw_screen(@state{world},1);
}

sub key_tab
{
#   key_log("key_tab: called");
   return if @state{world} eq undef;
   delete @socket{@state{world}}->{more_needed};
   @socket{@state{world}}->{more_last} = $#{@history{@state{world}}};
   show_output(@state{world});
   delete @socket{@state{world}}->{more} if($#{@pending{@state{world}}} == 1);
}

# key_ctl_u
#    Clear keyboard input
#
sub key_ctl_u
{
   @state{line} = [];
   @state{line_pos} = 0;
   delete @state{input_offset};
   xy(input_start(),1);
   printf("\033[J");
}

sub key_ctl_w
{
   my $count = 0;
   my $found = 0;

   key_log("control_w: pressed: '%s'",@state{line_pos});
   for(my $i = @state{line_pos};$i >= 0;$i--) {
      if(@state{line}->[$i] ne " ") {
         key_log("Found non space: '%s'",@state{line}->[$i]);
         $count++;
         if(@state{line}->[$i] ne undef) {
            $found = 1;
         }
      } elsif(@state{line}->[$i] eq " " && !$found) {
         $count++;
      } else {
         key_log("Found space: '%s'",@state{line}->[$i]);
         last;
      }
   }
   for my $i (2 .. $count) {
      key_delete();
   }
}

sub key_escape
{
   @state{multikey} = [];
}

sub out
{
   my $world = shift;
   my ($fmt,@args) = @_;

   $world = @state{world} if($world eq undef);
   if(defined @socket{$world} && defined @socket{$world}->{sock}) {
      my $sock = @socket{@state{world}}->{sock};
      key_log("$world> $fmt",@args);
      printf($sock "$fmt",@args);
      @socket{$world}->{last_send} = time();
   }
}

sub key_return
{
   my $array = @state{line};
   my $input = join('',@$array);

   if($input =~ /^\/([^ ]+)\s*/) {
      if(defined @command{lc($1)}) {
         key_log("CMD: '%s'\n",$input);
         &{@command{lc($1)}}($');
      } else {
         key_log("!CMD: '%s'\n",$input);
         echo("%% %s: no such command or macro",lc($1));
      }
   } elsif(!defined @state{world}) {
      key_log("RETURN: '%s'\n",$input);
   } elsif(defined @socket{@state{world}}->{sock}) {
      key_log("RETURN: '%s'\n",$input);
      out(@state{world},"%s\n",$input);
   }
   unshift(@input,@state{line});                        # store keyboard history
   @state{input_pos} = -1;                        # reset keyboard history pos
   @state{line} = [];
   @state{line_pos} = 0;

   # just entered input, don't be so quick to show the more
   @socket{@state{world}}->{more_last} = $#{@history{@state{world}}};
   input_clear();
   xy(input_x(),input_y());
   key_log("key_return: done");
}

sub input_lines
{
    my $result = sprintf("%d",($#{@state{line}} + 1) / (@state{size_y} - 1));
    return $result + 1 if(($#{@state{line}} + 1) % (@state{size_y} - 1) >= 1);
    return $result;
}

sub input_online
{
    my $result = sprintf("%d",@state{line_pos} / (@state{size_y} - 1));
    return $result + 1 if(@state{line_pos} % (@state{size_y} - 1) >= 1);
    return $result;
}


sub key_delete
{
   my $ch = shift;
   update_scroll_region("input");
   
   if(@state{line_pos} < 1) {                        # nothing left to delete
      return;
   } elsif(@state{line_pos} < $#{@state{line}}) {          # delete in middle
      splice(@{@state{line}},@state{line_pos}-1,1);
      xy(input_x(),input_y()-1);
      printf("\033[P");
      @state{line_pos}--;
      xy(input_x(),input_y());
     
      for my $i ((input_online()+1) .. input_lines()) {
         xy(input_start() + $i - 2,79);
         printf("%s",@state{line}->[(@state{size_y}-1) * ($i-1) - 1]);
         xy(input_x() + $i - 1,0);
         printf("\033[P");
      }
      xy(input_x(),input_y());
   } elsif(@state{line_pos} >= 1) {                           # delete at EOL
      @state{line_pos}--;
      pop(@{@state{line}});
      xy(input_x(),input_y());
      printf("\033[P");
      xy(input_x(),input_y());
   }
}

#
# key_default
#    Default key handler for all normal characters.
#
sub key_default
{
   my $ch = shift;
   my $out;

   update_scroll_region("input");

   splice(@{@state{line}},@state{line_pos},0,$ch);         # add ch to buffer
   @state{line_pos}++;                          # move cursor position over 1
   printf("%s",$ch);                                     # print out new char

   # redraw all characters in front of current character as the terminal
   for my $i (@state{line_pos} .. $#{@state{line}}) {

      # determine if character would be off the screen, if so done.
      if($i >= ((@state{size_y}-1) * @state{input_size}) + 
               (@state{input_offset} * (@state{size_y}-1))) {
         last;
      }

      # determine if we should drop down a line before next character
      if($i % (@state{size_y}-1) == 0 && $i != 0) {
         $out .= "\n";
      }
      $out .= @state{line}->[$i];                   # add next char in buffer
   }
   printf("%s",$out);                                   # output generated txt
   $out =~ s/\n/<N>/g;

   # if the input has gotten bigger then the input window, send a return now
   # plus the next line.
   if(($#{@state{line}} + 1 >= @state{input_size} * (@state{size_y}-1)) &&
      @state{line_pos} % (@state{size_y} - 1) == 0) {
      printf("\n%s",input_line(input_online()+1));
      @state{input_offset}++;
   }
   xy(input_x(),input_y());
}

sub key_left
{
   my $ret = "\n";
   if(@state{input_offset} > 0 && @state{line_pos} % (@state{size_y}-1)==0 &&
      input_x() == input_start()) {
      @state{input_offset}--;
      for my $i (input_online() .. input_lines()) {
         last if(@state{input_size} < $i - @state{input_offset});
         my $start = ($i-1) * (@state{size_y} -1);
         my $stop = $start + @state{size_y}-2;

         # only draw lines that are currently visible.
         if(@state{input_size} < $i + 1 - @state{input_offset}) {
            $ret = undef;                          # last line? no return
         }
         printf("\033[J%s$ret",join('',@{@state{line}}[$start .. $stop]));
      }
   }
   if(@state{line_pos} >= 1) {
      @state{line_pos}--;
      xy(input_x(),input_y());
   }
}

#
# input_line
#   Returns the keyed in input for a line on the screen.
#
sub input_line
{
   my $start = (@_[0] - 1) * (@state{size_y} -1);
   my $stop = $start + @state{size_y}-2;
   return join('',@{@state{line}}[$start .. $stop]);
}

sub name
{
   my $name = lc(shift);

   return undef if($name eq undef && @state{world} eq undef);
   $name = @state{world} if $name eq undef;

   if(defined @address{$name}) {
      return ((defined @socket{$name}->{sock}) ? "" : "!") .
             @address{$name}->{name};                      # correct case?
   } else {
      return "(Unnamed)";
   }
}

sub key_up
{
   return if not defined @state{world};
   my $pos = @socket{@state{world}}->{pos};
   $pos++;
   $pos = 1 if $pos > scalar keys %socket;

   @state{world} = (sort {@socket{$a}->{pos} cmp @socket{$b}->{pos}} 
                    keys %socket)[$pos-1];
   delete @state{activity}->{@state{world}};
   redraw_output();
   update_bar();
   sort keys %socket
}

sub key_down
{
   return if not defined @state{world};
   my $pos = @socket{@state{world}}->{pos};
   if($pos == 1) {
      $pos = scalar keys %socket;
   } else {
      $pos--;
   }

   @state{world} = (sort {@socket{$a}->{pos} cmp @socket{$b}->{pos}} 
                     keys %socket)[$pos-1];
   redraw_output();
   update_bar();
   sort keys %socket
}

sub key_right
{
   if(@state{line_pos} <= $#{@state{line}}) {
      if(@state{line_pos} % (@state{size_y}-1)==78 &&
         input_x() == @state{size_x}) {
         @state{input_offset}++;
         printf("\n%s",input_line(input_online()+1));
      }
      @state{line_pos}++;
      xy(input_x(),input_y());
   }
}

#
# key_esc_w
#   Go to the next active world
#
sub key_esc_w
{
   return if not defined @state{world};

   my $new = (keys %{@state{activity}})[0];
   return if $new eq undef;

   @state{world} = $new;
   delete @state{activity}->{@state{world}};

   redraw_output();
   update_bar();
   sort keys %socket
}

#
# update_scroll_region
#   Send the escape sequence to set a scroll region in the terminal.
#   The region will not be set if the region is already in affect unless
#   $force is true.
#
sub update_scroll_region
{
   my ($region,$force) = @_;
   my ($start,$stop);

   if($region eq "input") {                           # supported region input
      $start = @state{size_x} - @state{input_size} + 1;
      $stop  = @state{size_x};
   } elsif($region eq "output") {                    # supported region output
      $start = 1;
      $stop = output_end();
   } else {                                              # unsupported region
      die("Invalid region '$region' specified.");
   }

   if(@state{region} ne "$start,$stop" || $force) {           # do the work
      printf("\033[%s;%sr",$start,$stop);
#      key_log("USR[$region]: $start,$stop");
      @state{region} = "$start,$stop";
   }
}

#
# key_multi
#   Process multiple character keys. key_escape will start the sequence
#   off and this will grab characters till it makes a match or no match
#   can be made.
#
sub key_multi
{
   my $ch = shift;

   my $array = @state{multikey};

   if($#$array == -1) {                         # second character recieved
      if($ch eq "[") {
         return push(@$array,$ch);
      } elsif(defined @key{"multi_" . ord($ch)}) {
         return &{@key{"multi_" . ord($ch)}}($ch);
      }
   } elsif($#$array == 0) {                       # third character recieved
      if(defined @key{"multi_" . ord($$array[0]) . "_" . ord($ch)}) {
         return &{@key{"multi_" . ord($$array[0]) . "_" . ord($ch)}}($ch);
      }
   }
   delete @state{multikey};                              # no match or error, 
   key_process($ch);                          # process character generically
}

#
# key_process
#    Process input one key at a time while allowing for multi character
#    keys that begin with a escape and are followed by an arbitrary number
#    of letters afterwards (1 to 2?).
#
sub key_process
{
   my $input = shift;
   return unless defined $input;

   for my $ch (split(//,$input)) {
#      key_log("ch: '%s'",ord($ch));
      if(defined @key{ord($ch)}) {
         &{@key{ord($ch)}}($ch);
      } elsif(defined @state{multikey} && $#{@state{multikey}} <=2) {
         &{@key{multi}}($ch);
      } else {
         &{@key{def}}($ch);
      }
   }
}

sub clear_screen
{
    xy(1,1);
    for my $line (1 .. @state{size_x}) {
       if($line == @state{size_x}) {
          printf("\033[K");
       } else {
          printf("\033[K\n");
       }
    }
}

sub xy
{
   my ($x,$y,$use_the_force_luke) = @_;

   if(@state{prev_xy} ne "$x,$y" || $use_the_force_luke) {
      printf("\033[%s;%sH",$x,$y);
#      key_log("POS: '%s','%s' [%s]",$x,$y,code());
      @state{prev_xy} = "$x,$y";
   }
}

sub update_bar
{
   my $force = shift;
   my $new = time();
   my ($hr,$min,$active,$more) = ((localtime($new))[2,1]);
   $hr -= 12 if($hr > 12);

   if($force || "$hr$min" ne @state{bar_time} ||
      (@state{world} ne undef && @state{bar_world} ne @state{world}) ||
      scalar keys %{@state{activity}} > 0 ||
      @state{bar_name} ne name(@state{world}) ||
      (@state{world} ne undef && 
      @state{bar_more} != $#{@pending{@state{world}}} + 1)) {

      xy(@state{size_x} - @state{input_size},0);
      @state{bar_time} = "$hr$min";
      @state{bar_name} = name(@state{world});

      if(@state{world} ne undef) {
         @state{bar_world} = @state{world};
         @state{bar_more} = $#{@pending{@state{world}}} + 1;
         if(more(@state{world})) {
            $more = sprintf("\033[7mMore %s%s\033[0m",
                " " x (4-length(@state{bar_more})),@state{bar_more});
         }
      }
      $more = "_" x 9 if($more eq undef);

      if(defined @state{activity}->{@state{world}}) {
         delete @state{activity}->{@state{world}};
      }
      if(scalar keys %{@state{activity}} > 0) {
         $active = sprintf("(Active: %d)",scalar keys %{@state{activity}});
      }

      printf("%s_%s%s_%s______%s:%02d",
             $more,
             name(),
             "_" x (@state{size_y} - length(name() . "$more$active$hr") - 11),
             $active,
             $hr,
             $min
            );
   }
         
   update_scroll_region("input");
   xy(input_x(),input_y());
}

sub input_start
{
   return @state{size_x} - @state{input_size} + 1;
}

sub input_end
{
   return @state{size_x};
}

sub revert_console
{
   ReadMode 'normal';
   printf("\033[r");
   xy(24,1);
}


sub key_log
{
   my ($fmt,@args) = @_;
   my $file;

   my $msg = sprintf("$fmt",@args);
   $msg .= "\n" if($msg !~ /\n/);
   open($file,">> key.log");
   printf($file "%s",$msg);
   close($file);
}

sub code
{
   my $type = shift;
   my @stack;

   if(!$type || $type eq "short") {
      for my $line (split(/\n/,Carp::shortmess)) {
         if($line =~ /at ([^ ]+) line (\d+)\s*$/) {
            push(@stack,$2);
         }
      }
      return join(',',@stack);
   } else {
      return Carp::shortmess;
   }
}

sub input_clear
{
   update_scroll_region("input");
   my $start = @state{size_x} - @state{input_size} + 1;
   xy($start,0);
   for my $i ($start .. @state{size_y}) {
      printf("\033[K\n");
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  commands                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

sub command_init
{
   delete @command{keys %command};
   @command{world}       = sub { return cmd_world(@_);                     };
   @command{quit}        = sub { return cmd_quit(@_);                      };
   @command{reload}      = sub { return cmd_reload(@_);                    };
   @command{dc}          = sub { return cmd_dc(@_);                        };
   @command{listsockets} = sub { return cmd_dc(@_);                        };
   @command{l}           = sub { return cmd_listsockets(@_);               };

}

sub cmd_listsockets
{
   echo("%-16s %-26s %-5s","NAME","HOST","PORT");
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock}) {
         echo("%-16s %-26s %-5s", @address{$w}->{name}, @address{$w}->{host},
             @address{$w}->{port});
      }
   }
}
sub cmd_quit
{
   revert_console();
   exit(1);
}

sub cmd_reload
{
   reload_code();
}

sub cmd_world
{
   my $txt = trim(shift);

   key_log("cmd_world: called\n");
   if(!defined @address{lc($txt)}) {
      return echo("% CONNECT: no such world '%s'",$txt);
   } else {
      echo("% Trying to connect to: '%s' => '%s'",$txt,@address{$txt}->{host});
      socket_connect(@address{$txt}->{name},
                     @address{$txt}->{host},
                     @address{$txt}->{port},
                    );
   }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  misc code                                                                 #
#                                                                            #
#----------------------------------------------------------------------------#

END {
  revert_console();
}

sub center
{
    my $txt = shift;

    return sprintf("%s%s",(" " x ((@state{size_y} - length($txt)-1) / 2)),$txt);
}

sub show_banner
{
   open(PROG,$0) || return;

   while(<PROG>) {
      s/\n|\r//g;
      if($. > 24) {                                  # read only 24 lines
         last;
      } elsif(/^#-#   /) {
         echo("%s",center($'));
      } elsif($. > 100) {                              # read only 50 lines
         last;
      }
   }
   close(PROG);
   for my $i (0 .. 2) {
      echo("%s","");
   }
}

sub read_tfworlds
{
   my $fn = shift;
   my ($file, $bad);

   open($file,$fn) ||
      return echo("%% Unable to open '%s' for reading",$fn);

   while(<$file>) {
      s/\r|\n//g;
      if(/^\/test addworld\((.*)\)$/) {
         my @data = quotewords(',',0,$1);
         @address{lc(trim(@data[0]))} = {};
         @address{lc(trim(@data[0]))}->{host} = trim(@data[2]);
         @address{lc(trim(@data[0]))}->{port} = trim(@data[3]);;
         @address{lc(trim(@data[0]))}->{user} = trim(@data[4]);;
         @address{lc(trim(@data[0]))}->{pass} = trim(@data[5]);;
         @address{lc(trim(@data[0]))}->{name} = trim(@data[0]);
      } else {
         $bad++;
         echo("%% Unknown data: '%s'",$_);
      }
   }
   close($file);
   echo("%% %d worlds read from tfworlds file.",scalar keys %address);
}

sub get_checksums
{
   my ($file,$pos,%data);

   open($file,$0) ||
     return echo("%% Unable to read source file, /reload will be disabled");

   for my $line (<$file>) {
      if($pos eq undef && $line =~ /^sub\s+([^ \n\r]+)\s*$/) {
         $pos = $1;
         @data{$pos} = { chk => Digest::MD5->new };
         @data{$pos}->{chk}->add($line);
         @data{$pos}->{src} .= qq[#line 0 "$pos"\n] . $line;
         @data{$pos}->{line} = $.;
      } elsif($pos ne undef && $line =~ /^}\s*$/) {
         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk}->add($line);
         @data{$pos}->{chk} = @data{$pos}->{chk}->hexdigest;
         @data{$pos}->{done} = 1;
         $pos = undef;
      } elsif($pos ne undef) {
         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk}->add($line);
      }
   }
   close($file);

   for my $pos (keys %data) {
      if(!defined @data{$pos}->{done}) {
         echo("% Warning: Did not find end to %s",$pos);
      }
   }
   return \%data;
}

#
# reload_code
#    As long as the global variables do not change, the code can be
#    reloaded without dropping any connections.
#
sub reload_code
{
   my $new = get_checksums();
   my $old = @state{chksum};
   $old = {} if $old eq undef;

   for my $key (keys %$new) {
      if(!defined $$old{$key} || $$old{$key}->{chk} ne $$new{$key}->{chk}
         && $key ne "muddler") {
         
         echo("%% Reloading: %s",$key);
         eval($$new{$key}->{src});
         if($@) {
            echo("%% Error reloading $key: %s",$@)
         } else {
            echo("%% Reloading: %s [done]",$key);
         }
      }
   }
   @state{chksum} = $new;
   command_init();
}

#
# ignoreit
#    Ignore certain hash key entries at all depths or just the specified
#    depth.
#
sub ignoreit
{
   my ($skip,$key,$depth) = @_;


   if(!defined $$skip{$key}) {
      return 0;
   } elsif($$skip{$key} < 0 || ($$skip{$key} >= 0 && $$skip{$key} == $depth)) {
     return 1;
   } else {
     return 0;
   }
}

#
# print_var
#    Return a "text" printable version of a HASH / Array
#
sub print_var
{
   my ($var,$depth,$name,$skip,$recursive) = @_;
   my ($PL,$PR) = ('{','}');
   my $out;

   if($depth > 4) {
       return (" " x ($depth * 2)) .  " -> TO_BIG\n";
   }
   $depth = 0 if $depth eq "";
   $out .= (" " x ($depth * 2)) . (($name eq undef) ? "UNDEFINED" : $name) .
           " $PL\n" if(!$recursive);
   $depth++;

   for my $key (sort ((ref($var) eq "HASH") ? keys %$var : 0 .. $#$var)) {

      my $data = (ref($var) eq "HASH") ? $$var{$key} : $$var[$key];

      if((ref($data) eq "HASH" || ref($data) eq "ARRAY") &&
         !ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s $PL\n"," " x ($depth*2),$key);
         $out .= print_var($data,$depth+1,$key,$skip,1);
         $out .= sprintf("%s$PR\n"," " x ($depth*2));
      } elsif(!ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s = %s\n"," " x ($depth*2),$key,$data);
      }
   }

   $out .= (" " x (($depth-1)*2)) . "$PR\n" if(!$recursive);
   return $out;
}


#
# remove any space at the begining or end of a string
#
sub trim
{
   my $txt = shift;

   $txt =~ s/^\s+|\s+$//g;
   return $txt;
}

sub tick
{
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock} && time()-@socket{$w}->{last_send} > 300){
         key_log("tick: $w");
         if($w eq "del") {
            out($w,"score\n");
         } else {
            out($w,"think\n");
         }
         @socket{$w}->{last_send} = time();
      }
   }
   my $prev = "@state{size_y},@state{size_x}";
   (@state{size_y},@state{size_x}) = GetTerminalSize();
   if($prev ne "@state{size_y},@state{size_x}") {
      redraw_screen();
   }
}


sub muddler
{
   `del key.log`;
   @state{activity} = {};
   @state{chksum} = get_checksums();
   key_log("### START ###");
   $| = 1;                                                  # unbuffer stdout
   ReadMode 'cbreak';
   key_init();
   command_init();
   redraw_screen();
   show_banner();
   read_tfworlds("@ENV{HOME}/.tfworlds");
#   Monitor::monitor(@pending{alpha}, "array");

    while(1) {

      eval { # this is probably not needed, ReadKey seems to be protecting
             # everything which doesn't make me happy.

         socket_handle_input();
         key_process(ReadKey(0.25));
         if($@) {
           key_log("Crash? $@");
         }
         update_bar();

         if(time() - @state{tick_last} >= 10) {
            tick();
            @state{tick_last} = time();
         }

      };
      if($@) {
         key_log("Fatal: $@");
      }
   }
}

muddler();
