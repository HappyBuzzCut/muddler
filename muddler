#!/usr/bin/perl
#-#         ( A 90dies mud client written today ) 
#-#       o               v1.0a                   
#-#      o _____                __  __ _          
#-#    _||_| u |    _ _  _ _ __| /_| /| |  __ ____
#-#   (        |== / v \| | |  _ | _ || |/ -_) __/
#-#   /-()---()   |_|_|_|___/\___\___/|_|\__/_/   
#
# Note: A large section of the javascript, html, css came from Grapenut's
#       websocket client and has been embeded into this perl script.
#       I'm betting this is okay considering the license is described as:
#       There is no license. Just make a neato game with it.
#
#       Project's location: https://github.com/grapenut/websockclient

use strict;

use 5.014;                                                   # enable utf8
use utf8;
use strict;
use open        qw< :std  :utf8     >;
use charnames   qw< :full >;
use feature     qw< unicode_strings >;
use File::Basename      qw< basename >;
use Carp                qw< carp croak confess cluck >;
use Encode              qw< encode decode >;
use Unicode::Normalize  qw< NFD NFC >;



use strict;
# use Monitor qw(monitor);
use POSIX;
use IO::Select;
use IO::Socket;
use Text::ParseWords;
use URI::Escape;
#use Pmc::Telnet qw( TELOPT_SGA TELOPT_TTYPE TELOPT_NAWS TELOPT_NEW_ENVIRON
#                     TELNET_IAC TELNET_SB TELNET_SE TELOPT_ECHO);

use Carp;
my %key;                            # key presses hash table for fast lookups
my %history;                                                  # world history
my %socket;                                              # socket information
my %command;                            # command hash table for fast lookups
my %address;                                                # world addresses 
my %help;                                                         # help data
my @input;                                                    # input history
my %ws;                                             # websocket specific data
my $ws_listen;                                           # websocket listener
my $ws_server;                                             # websocket server
my $http_listen;                                              # http listener
my %http;                               # data structure for http connections
my %http_data;                                 # store websocket client pages
my %def;                                        # tf style define information
my %pid;                                              # internal process list

my %state = (
   line_pos        => 0,           # character position on the current line
   size_x          => 24,                     # size of screen horizontally
   size_y          => 80,                  # size of the screen veritically
   input_size      => 2,
   input_offset    => 0,                   # lines scrolled off input buffer
   input_pos       => -1,                        # location in input history
   line            => [],                                # curent input line
   pending         => {},
   web             => 0,                        # websocket enabled/disabled
   console         => 1,                            # disable console output
   p_password      => "xyzzy",
   p_color         => "light",                     # default websocket theme
   p_port          => 9000,                 # web/websock port starting port
   p_debug         => 0,               # store debuging info to key_log file
   overlap         => 3,                        # keep X lines from previous
                                                     # output when scrolling
   world           => "muddler",    # starting "world" to make coding easier
);

#
# define all keys/commands in a manor so that they can be reloaded
# while the program is still running.
#
sub key_init
{
   delete @key{keys %key};
   @key{def}             = sub { return key_default(@_);             };
   @key{2}               = sub { return key_left(@_);                };
   @key{4}               = sub { return key_dump(@_);                };
   @key{6}               = sub { return key_right(@_);               };
   @key{8}               = sub { return key_delete(@_);              };
   @key{9}               = sub { return key_tab(@_);                 };
   @key{10}              = sub { return key_return(@_);              };
   @key{12}              = sub { return key_ctl_l(@_);               };
   @key{14}              = sub { return key_ctl_n(@_);               };
   @key{16}              = sub { return key_ctl_p(@_);               };
   @key{18}              = sub { return key_ctl_r(@_);               };
   @key{21}              = sub { return key_ctl_u(@_);               };
   @key{23}              = sub { return key_ctl_w(@_);               };
   @key{27}              = sub { return key_escape(@_);              };
   @key{127}             = sub { return key_delete(@_);              };
   @key{multi}           = sub { return key_multi(@_);               };
   @key{multi_119}       = sub { return key_esc_w(@_);               };
   @key{multi_113}       = sub { return key_esc_q(@_);               };
   @key{multi_91_53_126} = sub { return key_pgup(@_);                };
   @key{multi_91_54_126} = sub { return key_pgdn(@_);                };
   @key{multi_91_65}     = sub { return key_up(@_);                  };
   @key{multi_91_66}     = sub { return key_down(@_);                };
   @key{multi_91_67}     = sub { return key_right(@_);               };
   @key{multi_91_68}     = sub { return key_left(@_);                };
}

sub command_init
{
   delete @command{keys %command};
   @command{world}         = sub { return cmd_world(@_);                   };
   @command{quit}          = sub { return cmd_quit(@_);                    };
   @command{reload}        = sub { return cmd_reload(@_);                  };
   @command{dc}            = sub { return cmd_dc(@_);                      };
   @command{listsockets}   = sub { return cmd_dc(@_);                      };
   @command{l}             = sub { return cmd_listsockets(@_);             };
   @command{recall}        = sub { return cmd_recall(@_);                  };
   @command{version}       = sub { return cmd_version(@_);                 };
   @command{help}          = sub { return cmd_help(@_);                    };
   @command{web}           = sub { return cmd_web(@_);                     };
   @command{port}          = sub { return cmd_port(@_);                    };
   @command{key_tab}       = sub { return key_tab(@_);                     };
   @command{key_esc_w}     = sub { return key_esc_w(@_);                   };
   @command{key_ctl_l}     = sub { return key_ctl_l(@_);                   };
   @command{key_up}        = sub { return key_up("A",@_);                  };
   @command{key_down}      = sub { return key_down("B",@_);                };
   @command{key_pgdn}      = sub { return key_pgdn(@_);                    };
   @command{key_pgup}      = sub { return key_pgup(@_);                    };
   @command{web_size}      = sub { return cmd_web_size(@_);                };
   @command{repeat}        = sub { return cmd_repeat(@_);                  };
   @command{echo}          = sub { return cmd_echo(@_);                    };
   @command{ps}            = sub { return cmd_ps(@_);                      };
   @command{kill}          = sub { return cmd_kill(@_);                    };
   @command{def}           = sub { return cmd_def(@_);                     };
   @command{listdef}       = sub { return cmd_listdef(@_);                 };
   @command{listworlds}    = sub { return cmd_listworlds(@_);              };
   @command{add}           = sub { return cmd_addworld(@_);                };
   @command{addworld}      = sub { return cmd_addworld(@_);                };
   @command{rc}            = sub { return read_tfrc("@ENV{HOME}/.tfrc");   };
   @command{keepalive}     = sub { return cmd_keepalive(@_);               };
   @command{color}         = sub { return cmd_color(@_);                   };
   @command{password}      = sub { return cmd_password(@_);                };
   @command{update}        = sub { return cmd_update(@_);                  };
   #-----------------------------------------------------------------------#
   @command{clock}         = sub { return cmd_null(@_);                    };
   @command{lcd}           = sub { return cmd_null(@_);                    };
   @command{hilite_page}   = sub { return cmd_null(@_);                    };
   @command{hilite_whisper}= sub { return cmd_null(@_);                    };
   @command{status_rm}     = sub { return cmd_null(@_);                    };
   @command{set}           = sub { return cmd_null(@_);                    };
   @command{load}          = sub { return cmd_null(@_);                    };
   @command{loadworld}     = sub { return cmd_null(@_);                    };
   @command{visual}        = sub { return cmd_null(@_);                    };
   @command{isize}         = sub { return cmd_null(@_);                    };
   @command{idleit}        = sub { return cmd_null(@_);                    };
   @command{saveworld}     = sub { return cmd_null(@_);                    };
}

#----------------------------------------------------------------------------#
#                                                                            #
#  modules                                                                   #
#                                                                            #
#----------------------------------------------------------------------------#

sub module_enabled
{
   my $txt = shift;

   if(!defined @state{"mod_$txt"} || @state{"mod_$txt"} == -1) {
      key_log("Mod: '%s' -> '%s'\n",$txt,@state{"mod_$txt"});
      return 0;
   } else {
      return 1;
   }
 
}

sub load_modules
{
   my %mod = (
      'Term::ReadKey'          => { fatal => 1, fix => "apt install " .
                                     "libterm-readkey-perl" },
      'Net::WebSocket::Server' => {  fatal => 0, fix => "perl -MCPAN -e " .
                                     "\"install Net::WebSocket::Server\"",
                                     disable => 'web/websocket server'
                                  },
      'Net::Telnet'            => { fatal => 1, fix => "apt install " .
                                    "libnet-telnet-perl" },
      'Encode'                 => { fatal => 1, fix => "install Encode module"},
      'Digest::MD5'            => { fatal => 0, fix => "install Digest::MD5"},
   );

   for my $key (keys %mod) {
      if(!defined @state{"mod_@mod{$key}"} || @state{"mod_@mod{$key}"} == -1) {
         @state{"mod_$key"} = 1;
         eval "use $key; 1;" or @state{"mod_$key"} = -1;

         if(@state{"mod_$key"} == -1) {
            if(@mod{$key}->{fatal}) {
               @state{modules} = [] if(!defined @state{modules});
               @state{fatal} = 1;
               push(@{@state{modules}},sprintf("FATAL: perl $key module is required for muddler.\n   " . 
                       "Fix?   @mod{$key}->{fix}\n"));
            } else {
               @state{modules} = [] if(!defined @state{modules});
               push(@{@state{modules}},sprintf("WARNING: perl %s module is required for muddler.\n" .
                      "         %s will be disabled.\n" .
                      "         Fix?   %s\n",
                      $key,
                      @mod{$key}->{disable},
                      @mod{$key}->{fix}
                     ));
            }
         }
      }
   }
   
   if(@state{fatal}) {
      for my $i (0 .. $#{@state{modules}}) {
         printf("%s",@state{modules}->[$i]);
      }
   }
   exit() if @state{fatal};
}


#----------------------------------------------------------------------------#
#                                                                            #
#  ansi support                                                              #
#    Routines taken from teenymush. This should probably be turned into a    #
#    module if i liked using multiple files.                                 #
#                                                                            #
#----------------------------------------------------------------------------#
#
# ansi_debug
#    Convert an ansi string into something more readable.
#
sub ansi_debug
{
    my $txt = shift;

    $txt =~ s/\e/<ESC>/g;
    return $txt;
}


#
# ansi_char
#    Returns one character of the current string. Due to the nature of the
#    ansi functions, this will only return characters not in ansi character
#    strings. While this is silly to use a function to do this, this helps
#    abstract the data set for situations in which the ansi functions are
#    replaced by standard string functions.
#
sub ansi_char
{
   my ($data,$pos) = @_;

   return @{$$data{ch}}[$pos];
}


sub is_ansi_string
{
   my $txt = shift;

   if(ref($txt) ne "HASH" ||
      !defined $$txt{ch} ||
      !defined $$txt{snap} ||
      !defined $$txt{code}) {
      return 0;
   } else {
      return 1;
   }
}


sub ansi_reset
{
   my ($data,$pos) = @_;

   my $string = (is_ansi_string($data)) ? $data : ansi_init($data);

   return $string if $pos < 0;                               # sanity check

   my $code = $$string{code};
   my $array = $$code[$pos];

   # check to see if the last code is a reset, or no codes at all
   if($#$array == -1 || $$array[$#$array] ne "\e[0m") {
      push(@$array,"\e[0m");
   }
   return $string;
}
#
# ansi_add
#   Add a character or escape code to the data array. Every add of a
#   character results in a new element, escape codes are added to existing
#   elements as long as a character has not been added yet. The ansi state
#   is also kept track of here.
#
sub ansi_add
{
   my ($data,$type,$txt) = @_;

   my $ch   = $$data{ch};                      # make things more readable
   my $code = $$data{code};
   my $snap = $$data{snap};

   if($#$ch == -1 || $$ch[$#$ch] ne undef) {
      $$ch[$#$ch+1] = undef;
      $$code[$#$ch] = [];
      $$snap[$#$ch] = [];
   }

   if($type) {
     for my $c (split(//,$txt)) {                 # add multiple characters
        $$ch[ $#$ch + ((@$ch[$#$ch] ne undef) ? 1 : 0) ] = $c;
        @$code[$#$ch] = [] if(!defined @$code[$#$ch]);
        @$snap[$#$ch] = [ @{@$data{state}} ];
     }
   } else {                                           # add escape sequence
      push(@{$$code[$#$ch]},$txt);
      if($txt eq "\e[0m") {
         $$data{state} = [];
      } else {
         push(@{$$data{state}},$txt);
      }
   }
}


#
# ansi_init
#    Read in a string and convert it into a data structure that can be
#    easily parsed / modified, i hope.
#
#     {
#       code => [ [ array of arrays containing escape codes ] ]
#       ch   => [ Array containing each character one by one ]
#       snap => [ [ array of arrays containing all active escape codes
#                   at the time the character was encountered ] ]
#       state=> [ internal, current state of active escape does ]
#     }
#
sub ansi_init
{
   my $str = shift;

   my $data = { ch => [], code => [], state  => [], snap   => [] };

   while($str =~ /\e\[([\d;]*)([a-zA-Z])/) {
      $str = $';
      ansi_add($data,1,$`) if $` ne undef;
      ansi_add($data,0,"\e[$1$2");
   }
   ansi_add($data,1,$str) if($str ne undef);

   return $data;
}

#
# ansi_clone
#   Clone the ansi escape codes at a particular position to the new
#   string.
#
sub ansi_clone
{
   my ($str,$pos,$txt) = @_;

   if(ref($str) ne "HASH") {
      $str = ansi_init($str);
   }

   my $snap = $$str{snap};

   if($#$snap >= 0 && $#$snap > $pos) {
      return join('',@{@$snap[$pos]}) . $txt . "\e[0m";
   } else {
      return $txt;
   }
}

#
# ansi_string
#    Take ansi data structure and return
#        type => 0 : everything but the escape codes
#        type => 1 : original string [including escape codes]
#
sub ansi_string
{
   my ($data,$type) = @_;
   my $buf;

   for my $i (0 .. $#{$$data{ch}}) {
      $buf .= join('', @{@{$$data{code}}[$i]}) if($type);
      $buf .= @{$$data{ch}}[$i];
   }
   return $buf;
}

#
# ansi_substr
#    Do a substr on a string while preserving the escape codes.
#
#    no-ansi flag : do not copy over escape sequences
#
sub ansi_substr
{
   my ($txt,$start,$count,$noansi) = @_;
   my ($result,$data);
   my $last = -1;

   if(ref($txt) eq "HASH") {
      $data = $txt;
   } else {
      $data = ansi_init($txt);
   }

   $start = 0 if($start !~ /^\s*\d+\s*$/);                  # sanity checks
   if($count !~ /^\s*\d+\s*$/) {
      $count = ansi_length($txt);
   } else {
      $count += $start;
   }
   return undef if($start < 0);                         # no starting point

   # loop through each "character" w/attached ansi codes
   for(my $i = $start;$i < $count && $i <= $#{$$data{ch}};$i++) {
      if(!$noansi) {
         my $code=join('',@{@{$$data{($i == $start) ? "snap" : "code"}}[$i]});
         $result .= $code . @{$$data{ch}}[$i];
      } else {
         $result .= @{$$data{ch}}[$i];
      }
      $last = $#{@{$$data{snap}}[$i]};
   }

   # are attributes turned on on last character? if so, reset them.
   return $result . (($last == -1) ? "" : (chr(27) . "[0m"));
}

#
# ansi_length
#    Return the length of a string without counting all those pesky escape
#    codes.
#
sub ansi_length
{
   my $txt = shift;
   my $data = shift;

   if(ref($txt) eq "HASH") {                           # already inited txt?
      $data = $txt;
   } else {
      $data = ansi_init($txt);
   }

   if($#{$$data{ch}} == -1) {                                       # empty
      return 0;
   } elsif(@{$$data{ch}}[-1] eq undef) {               # last char pos empty?
      return $#{$$data{ch}};
   } else {
      return $#{$$data{ch}} + 1;                        # last char populated
   }
}
#
# ansi_remove
#    remove any escape codes from the string
#
sub ansi_remove
{
#   my $txt = ansi_init(shift);
#   return ansi_print($txt,0);

   my $txt = shift;
   $txt =~ s/\e\[[\d;]*[a-zA-Z]//g;
   return $txt;
}


#----------------------------------------------------------------------------#
#                                                                            #
#  pmc support                                                               #
#                                                                            #
#----------------------------------------------------------------------------#

# sub TELQUAL_IS   { 0; }
# sub TELQUAL_SEND { 1; }
# sub TELOPT_MXP   { 91; }
# sub TELOPT_MSP   { 90; }
# 
# sub negotiation {
#     my ($conn, $option, $is_remote, $is_enabled, $was_enabled,
#         $buf_position)= @_;
#     $is_remote||=0;
#     $is_enabled||=0;
#     $was_enabled||=0;
#     my ($noecho, $linemode);
# 
# #    debug("negotiation: $option rem:$is_remote is_en:$is_enabled ".
# #          "was_en:$was_enabled");
# 
#     if ($option==TELOPT_TTYPE) {
#         send_iac($conn,chr(TELNET_SB).
#                  chr(TELOPT_TTYPE).
#                  chr(TELQUAL_IS).
#                  $ENV{TERM}.
#                  chr(TELNET_IAC).
#                  chr(TELNET_SE)
#                 );
#     } elsif($option == TELOPT_NAWS) {
#         send_naws($conn,1);
#     } elsif ($option==TELOPT_ECHO) {
#         if ($is_enabled) {
#             $noecho=1;
#         } else {
#             $noecho=0;
#         }
#         switch_echo();
#     } elsif ($option==TELOPT_SGA) {
#         if ($linemode && $is_enabled) {
#             debug('char-mode');
#             ReadMode(4);
#         } elsif (!$is_enabled && !$linemode) {
#             debug('line-mode');
#             ReadMode(0);
#         }
#         $linemode= !$is_enabled;
#     } elsif ($option==TELOPT_MXP || $option==TELOPT_MSP) {
#     } else {
#     }
# }
# 
# sub send_iac {
#     my ($conn,$neg) = @_;
# 
#     syswrite $conn, chr(TELNET_IAC).$neg, length($neg)+1, 0;
# }
# 
# sub check_mcp_naws {
#    return 0;
# }
# 
# sub send_naws {
#     my ($conn,$from_telopt)= @_;
# 
# #    my ($height,$width)= $term->get_screen_size();
#     my ($height,$width) = (24,80);
#     if (check_mcp_naws() && !$from_telopt) {
#         mcp_send('dns-com-vmoo-client-screensize',
#                 jols => $width, rows => $height);
#     } else {
#         send_iac($conn,chr(TELNET_SB).chr(TELOPT_NAWS).chr($width/256).
#                  chr($width%256).chr($height/256).chr($height%256).
#                  chr(TELNET_IAC).chr(TELNET_SE));
#     }
# }

#----------------------------------------------------------------------------#
#                                                                            #
#  tcp code                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

#
# BEGIN statement with including code, and most of socket_connect were
# copied from from: http://aspn.activestate.com/ASPN/Mail/Message/
# perl-win32-porters/1449297.
#
# BEGIN {
#    # This nonsense is needed in 5.6.1 and earlier -- I'm too lazy to
#    # test if it's been fixed in 5.8.0.
#    if( $^O eq 'MSWin32' ) {
#       *EWOULDBLOCK = sub () { 10035 };
#       *EINPROGRESS = sub () { 10036 };
#       *IO::Socket::blocking = sub {
#           my ($self, $blocking) = @_;
#           my $nonblocking = $blocking ? "0" : "1";
#           ioctl($self, 0x8004667e, $nonblocking);
#       };
#    } else {
#       require Errno;
#       import  Errno qw(EWOULDBLOCK EINPROGRESS);
#    }
# }

# sub socket_connect
# {
#    my ($world,$host,$port,$ssl) = ( lc(shift), @_ );
# 
#    if(defined @socket{$world} && @socket{$world}->{sock}) {
#       return echo("%% Already connected to %s",$world);
#    }
# 
#    @history{$world} = [];
#    @pending{$world} = [] if !defined @pending{$world};
#    @socket{$world} = { name      => $world,
#                        host      => $host,
#                        port      => $port,
#                        more      => 0,
#                        more_last => 0,
#                        last_read => -1,
#                      };
#    @state{world} = $world;
#    @socket{$world}->{pos} = scalar keys %socket;
# 
#    my $s = new Pmc::Telnet( $host, $port, $ssl, Timeout => 10);
#    key_log("name=$world,host=$host,port=$port");
# 
#    if(!$s) {
#       draw_bar();
#       return echo("%% Connection Failed.");
#    }
# 
#    $s->option_callback(\&negotiation);
#    $s->option_accept( Do   => TELOPT_SGA,
#                       Do   => TELOPT_TTYPE,
#                       Do   => TELOPT_NAWS,
#                       Do   => TELOPT_ECHO,
#                       Dont => TELOPT_MXP,
#                       Dont => TELOPT_MSP,
#                       Wont => TELOPT_MXP,
#                       Wont => TELOPT_MSP,
#                       Will => TELOPT_SGA,
#                       Will => TELOPT_TTYPE,
#                       Will => TELOPT_NAWS,
#                       Will => TELOPT_ECHO);
#    @socket{$world}->{sock} = $s;
#    echo("%% Connection to %s succeeded.",$world);
#    if(defined @address{$world}->{user} && defined @address{$world}->{pass}) {
#       out($world,
#            "connect %s %s\n",
#            @address{$world}->{user},
#            @address{$world}->{pass}
#           );
#    }
#    draw_bar();
# }

sub socket_connect
{
   my ($world,$host,$port,$ssl) = ( lc(shift), @_ );

   if(defined @socket{$world} && @socket{$world}->{sock}) {
      return echo("%% Already connected to %s",$world);
   }

   @history{$world} = [];
   @socket{$world} = { name      => $world,
                       host      => $host,
                       port      => $port,
                       more      => -1,
                       more_count=> 0,
                       last_read => -1,
                       history_pos => -1,
                       history_pos_partial => -1,
                     };
   @state{world} = $world;
   @socket{$world}->{pos} = ++@state{pos_sequence};
#   Monitor::monitor(@socket{$world}, "hash");

   my $s = Net::Telnet->new(host => $host,
                            port => $port,
                            binmode => 1,
                            Timeout => 10,
                            Errmode => "return");

   if(!$s) {
      draw_bar();
      return echo("%% Connection Failed.");
   }


   @socket{$world}->{sock} = $s;
   echo("%% Connection to %s succeeded.",$world);
   if(defined @address{$world}->{user} && defined @address{$world}->{pass}) {
      out($world,
           "connect %s %s\n",
           @address{$world}->{user},
           @address{$world}->{pass}
          );
   }
   delete @socket{muddler};
   draw_bar();
 
}

sub socket_handle_input
{
   for my $world (keys %socket) {
      if(@socket{$world}->{sock}) {
         if(@socket{$world}->{sock}->eof()) {
            delete @socket{$world}->{sock};
            history($world,"% Connection closed to ". name($world));
            draw_bar();
         } else {                 # favor keyboard input not socket in timeout
            # read all input
            for(my $count=0;$count < 200;$count++) {
               if(my $input = decode("UTF-8",@socket{$world}->{sock}->getline(Timeout=>0))) {
                  history($world,$input);
               } else {
                  last;
               }
            }
         }
      }
   }
}
#----------------------------------------------------------------------------#
#                                                                            #
#  websocket support                                                         #
#    A mudding client with an http/websocket server? why not.                #
#                                                                            #
#----------------------------------------------------------------------------#

sub web
{
    return (@state{web} == 1) ? 1 : 0;
}

#
# server_hostname
#    lookup the hostname based upon the ip address
#
sub server_hostname
{
   my $sock = shift;
   my $ip = $sock->peerhost;                           # contains ip address

   my $name = gethostbyaddr(inet_aton($ip),AF_INET);

   if($name =~ /^\s*$/ || $name =~ /in-addr\.arpa$/) {
      return $ip;                            # last resort, return ip address
   } else {
      return $name;                                         # return hostname
   }
}

sub ws_init
{
  
   if(!console()) {
      printf("%% Web enabled, connect via: http://localhost:@state{port}\n");
      printf("%%    Password: @state{p_password}\n");
   }
   @state{web} = 1;
   $http_listen = IO::Socket::INET->new( LocalPort => @state{port},
                                         Listen    => 1,
                                         Reuse     => 1,
                                       )
   or die "failed to set up httpd listener: $!";

   $ws_listen = IO::Socket::INET->new( LocalPort => @state{port} + 1,
                                       Listen    => 1,
                                       Reuse     => 1,
                                       )
   or die "failed to set up websocket listener: $!";

   $ws_server = Net::WebSocket::Server->new(
      listen => $ws_listen,
      tick_period => 1,
      on_connect => sub { my( $serv, $conn ) = @_;
                          $conn->on( ready =>      sub{ ws_login_screen(@_); },
                                     utf8  =>      sub{ ws_process( @_, 0 ); },
                                     disconnect => sub{ ws_disconnect(@_);   },
                                   );
                        },
      );
   $ws_server->{select_readable}->add($ws_listen);
   $ws_server->{select_readable}->add($http_listen);
   $ws_server->{conns} = {};
}

sub ws_disconnect
{
   my $conn = shift;

   my $sock = $conn->{socket};
   $ws_server->{select_readable}->remove( $sock );
   delete $ws_server->{conns}{$sock};
   delete @ws{$conn};
   # $sock->close;
}

sub ws_login_screen
{
   my $ws = shift;
   ws_echo($ws,"t",@state{version},1);

   if(defined @state{p_color}) {
      ws_echo($ws,"c",@state{p_color},1);
   }
#   redraw_screen();
}

#
# ws_echo
#    The send might crash if the websocket has disconnected the evals should
#    probably be removed once this is more stable. With that in mind,
#    currently crash will be treated as a disconnect.
#
sub ws_echo
{
   my ($ws, $type, $msg,$force) = @_;

   # only show something if authorized or those exceptions when logging in
   return if(@ws{$ws}->{auth} eq 0 && !$force);

   # this might crash if the websocket dies, the evals should
   # probably be removed once this is more stable. With that in mind,
   # currently crash will be treated as a disconnect.

   eval {
      $ws->send('',$type . encode_utf8($msg) . "\r\n");
   };
   if($@) {
      ws_disconnect($ws) if($@);
      key_log("FATALs: $@");
   }
}

#
# server_address
#    lookup the hostname based upon the ip address
#
sub server_address
{
   my $sock = shift;
   my $ip = $sock->peerhost;                           # contains ip address

   my $name = gethostbyaddr(inet_aton($ip),AF_INET);

   if($name =~ /^\s*$/ || $name =~ /in-addr\.arpa$/) {
      return $ip;                            # last resort, return ip address
   } else {
      return $name;                                         # return hostname
   }
}


sub ws_io
{
   my ($sockets) = IO::Select->select($ws_server->{select_readable},
                                      $ws_server->{select_writeable},
                                      undef,
                                      0
                                     );

   for my $sock (@$sockets) {
      if( $sock == $ws_listen ) {
         my $s = $ws_listen->accept;
         my $conn = new Net::WebSocket::Server::Connection(
                    socket => $s, server => $ws_server );
   
         $ws_server->{conns}{$s} = { conn     => $conn,
                                     lastrecv => time,
                                     ip       => server_hostname($s)
                                   };
         $ws_server->{select_readable}->add( $s );
         $ws_server->{on_connect}($ws_server, $conn );
         @ws{$conn} = {};
         @ws{$conn}->{conn} = $conn;
         @ws{$conn}->{start} = time();
         @ws{$conn}->{auth} = 0;
      } elsif($sock == $http_listen) {
         my $s = $sock->accept;
         $ws_server->{select_readable}->add($s);
         @http{$s} = { sock    => $s,
                       data    => {},
                       address => server_address($s)
                     };
      } elsif(defined @http{$sock}) {
         http_io($sock);
      } elsif( $ws_server->{watch_readable}{$sock} ) {
         $ws_server->{watch_readable}{$sock}{cb}( $ws_server , $sock );
      } elsif( $ws_server->{conns}{$sock} ) {
         my $connmeta = $ws_server->{conns}{$sock};
         $connmeta->{lastrecv} = time;
         $connmeta->{conn}->recv();
      } else {
         key_log("filehandle $sock became readable, but no handler took " .
              "responsibility for it; removing it");
         $ws_server->{select_readable}->remove( $sock );
      }
   }
}

sub http_data_init
{
   delete @http{keys %http_data};
   @http_data{"orig_muddler_ansi.css"}=<<__ANSI__;
   /* underlined text */
   .ansi-4 { text-decoration: underline; }
   
   /* blinking text */
   .ansi-5 {
       -webkit-animation: blink .75s linear infinite;
       -moz-animation: blink .75s linear infinite;
       -ms-animation: blink .75s linear infinite;
       -o-animation: blink .75s linear infinite;
       animation: blink .75s linear infinite;
   }

   /* standard 16 foreground colors */
   .ansi-30 { color: black; }
   .ansi-1-30 { color: gray; }
   .ansi-31 { color: maroon; }
   .ansi-1-31 { color: red; }
   .ansi-32 { color: green; }
   .ansi-1-32 { color: lime; }
   .ansi-33 { color: olive; }
   .ansi-1-33 { color: yellow; }
   .ansi-34 { color: navy; }
   .ansi-1-34 { color: blue; }
   .ansi-35 { color: purple; }
   .ansi-1-35 { color: fuchsia; }
   .ansi-36 { color: teal; }
   .ansi-1-36 { color: aqua; }
   .ansi-37 { color: black; }
   .ansi-1-37 { color: black; } 


   /* standard 16 background colors */
   .ansi-40 { background-color: black; }
   .ansi-1-40 { background-color: gray; }
   .ansi-41 { background-color: maroon; }
   .ansi-1-41 { background-color: red; }
   .ansi-42 { background-color: green; }
   .ansi-1-42 { background-color: lime; }
   .ansi-43 { background-color: olive; }
   .ansi-1-43 { background-color: yellow; }
   .ansi-44 { background-color: navy; }
   .ansi-1-44 { background-color: blue; }
   .ansi-45 { background-color: purple; }
   .ansi-1-45 { background-color: fuchsia; }
   .ansi-46 { background-color: teal; }
   .ansi-1-46 { background-color: aqua; }
   .ansi-47 { background-color: silver; }
   .ansi-1-47 { background-color: white; }
   
   .ansi-38-5-0     { color:            #000000; }
   .ansi-38-5-1     { color:            #cd0000; }
   .ansi-38-5-2     { color:            #00cd00; }
   .ansi-38-5-3     { color:            #cdcd00; }
   .ansi-38-5-4     { color:            #0000ee; }
   .ansi-38-5-5     { color:            #cd00cd; }
   .ansi-38-5-6     { color:            #00cdcd; }
   .ansi-38-5-7     { color:            #e5e5e5; }
   .ansi-38-5-8     { color:            #7f7f7f; }
   .ansi-38-5-9     { color:            #ff0000; }
   .ansi-38-5-10    { color:            #00ff00; }
   .ansi-38-5-11    { color:            #e8e800; }
   .ansi-38-5-12    { color:            #5c5cff; }
   .ansi-38-5-13    { color:            #ff00ff; }
   .ansi-38-5-14    { color:            #00ffff; }
   .ansi-38-5-15    { color:            #ffffff; }
   
   /* XTERM colors - 256 color mode */
   .ansi-38-5-16    { color:            #000000; }
   .ansi-38-5-17    { color:            #00005f; }
   .ansi-38-5-18    { color:            #000087; }
   .ansi-38-5-19    { color:            #0000af; }
   .ansi-38-5-20    { color:            #0000d7; }
   .ansi-38-5-21    { color:            #0000ff; }
   .ansi-38-5-22    { color:            #005f00; }
   .ansi-38-5-23    { color:            #005f5f; }
   .ansi-38-5-24    { color:            #005f87; }
   .ansi-38-5-25    { color:            #005faf; }
   .ansi-38-5-26    { color:            #005fd7; }
   .ansi-38-5-27    { color:            #005fff; }
   .ansi-38-5-28    { color:            #008700; }
   .ansi-38-5-29    { color:            #00875f; }
   .ansi-38-5-30    { color:            #008787; }
   .ansi-38-5-31    { color:            #0087af; }
   .ansi-38-5-32    { color:            #0087d7; }
   .ansi-38-5-33    { color:            #0087ff; }
   .ansi-38-5-34    { color:            #00af00; }
   .ansi-38-5-35    { color:            #00af5f; }
   .ansi-38-5-36    { color:            #00af87; }
   .ansi-38-5-37    { color:            #00afaf; }
   .ansi-38-5-38    { color:            #00afd7; }
   .ansi-38-5-39    { color:            #00afff; }
   .ansi-38-5-40    { color:            #00d700; }
   .ansi-38-5-41    { color:            #00d75f; }
   .ansi-38-5-42    { color:            #00d787; }
   .ansi-38-5-43    { color:            #00d7af; }
   .ansi-38-5-44    { color:            #00d7d7; }
   .ansi-38-5-45    { color:            #00d7ff; }
   .ansi-38-5-46    { color:            #00ff00; }
   .ansi-38-5-47    { color:            #00ff5f; }
   .ansi-38-5-48    { color:            #00ff87; }
   .ansi-38-5-49    { color:            #00ffaf; }
   .ansi-38-5-50    { color:            #00ffd7; }
   .ansi-38-5-51    { color:            #00ffff; }
   .ansi-38-5-52    { color:            #5f0000; }
   .ansi-38-5-53    { color:            #5f005f; }
   .ansi-38-5-54    { color:            #5f0087; }
   .ansi-38-5-55    { color:            #5f00af; }
   .ansi-38-5-56    { color:            #5f00d7; }
   .ansi-38-5-57    { color:            #5f00ff; }
   .ansi-38-5-58    { color:            #5f5f00; }
   .ansi-38-5-59    { color:            #5f5f5f; }
   .ansi-38-5-60    { color:            #5f5f87; }
   .ansi-38-5-61    { color:            #5f5faf; }
   .ansi-38-5-62    { color:            #5f5fd7; }
   .ansi-38-5-63    { color:            #5f5fff; }
   .ansi-38-5-64    { color:            #5f8700; }
   .ansi-38-5-65    { color:            #5f875f; }
   .ansi-38-5-66    { color:            #5f8787; }
   .ansi-38-5-67    { color:            #5f87af; }
   .ansi-38-5-68    { color:            #5f87d7; }
   .ansi-38-5-69    { color:            #5f87ff; }
   .ansi-38-5-70    { color:            #5faf00; }
   .ansi-38-5-71    { color:            #5faf5f; }
   .ansi-38-5-72    { color:            #5faf87; }
   .ansi-38-5-73    { color:            #5fafaf; }
   .ansi-38-5-74    { color:            #5fafd7; }
   .ansi-38-5-75    { color:            #5fafff; }
   .ansi-38-5-76    { color:            #5fd700; }
   .ansi-38-5-77    { color:            #5fd75f; }
   .ansi-38-5-78    { color:            #5fd787; }
   .ansi-38-5-79    { color:            #5fd7af; }
   .ansi-38-5-80    { color:            #5fd7d7; }
   .ansi-38-5-81    { color:            #5fd7ff; }
   .ansi-38-5-82    { color:            #5fff00; }
   .ansi-38-5-83    { color:            #5fff5f; }
   .ansi-38-5-84    { color:            #5fff87; }
   .ansi-38-5-85    { color:            #5fffaf; }
   .ansi-38-5-86    { color:            #5fffd7; }
   .ansi-38-5-87    { color:            #5fffff; }
   .ansi-38-5-88    { color:            #870000; }
   .ansi-38-5-89    { color:            #87005f; }
   .ansi-38-5-90    { color:            #870087; }
   .ansi-38-5-91    { color:            #8700af; }
   .ansi-38-5-92    { color:            #8700d7; }
   .ansi-38-5-93    { color:            #8700ff; }
   .ansi-38-5-94    { color:            #875f00; }
   .ansi-38-5-95    { color:            #875f5f; }
   .ansi-38-5-96    { color:            #875f87; }
   .ansi-38-5-97    { color:            #875faf; }
   .ansi-38-5-98    { color:            #875fd7; }
   .ansi-38-5-99    { color:            #875fff; }
   .ansi-38-5-100   { color:            #878700; }
   .ansi-38-5-101   { color:            #87875f; }
   .ansi-38-5-102   { color:            #878787; }
   .ansi-38-5-103   { color:            #8787af; }
   .ansi-38-5-104   { color:            #8787d7; }
   .ansi-38-5-105   { color:            #8787ff; }
   .ansi-38-5-106   { color:            #87af00; }
   .ansi-38-5-107   { color:            #87af5f; }
   .ansi-38-5-108   { color:            #87af87; }
   .ansi-38-5-109   { color:            #87afaf; }
   .ansi-38-5-110   { color:            #87afd7; }
   .ansi-38-5-111   { color:            #87afff; }
   .ansi-38-5-112   { color:            #87d700; }
   .ansi-38-5-113   { color:            #87d75f; }
   .ansi-38-5-114   { color:            #87d787; }
   .ansi-38-5-115   { color:            #87d7af; }
   .ansi-38-5-116   { color:            #87d7d7; }
   .ansi-38-5-117   { color:            #87d7ff; }
   .ansi-38-5-118   { color:            #87ff00; }
   .ansi-38-5-119   { color:            #87ff5f; }
   .ansi-38-5-120   { color:            #87ff87; }
   .ansi-38-5-121   { color:            #87ffaf; }
   .ansi-38-5-122   { color:            #87ffd7; }
   .ansi-38-5-123   { color:            #87ffff; }
   .ansi-38-5-124   { color:            #af0000; }
   .ansi-38-5-125   { color:            #af005f; }
   .ansi-38-5-126   { color:            #af0087; }
   .ansi-38-5-127   { color:            #af00af; }
   .ansi-38-5-128   { color:            #af00d7; }
   .ansi-38-5-129   { color:            #af00ff; }
   .ansi-38-5-130   { color:            #af5f00; }
   .ansi-38-5-131   { color:            #af5f5f; }
   .ansi-38-5-132   { color:            #af5f87; }
   .ansi-38-5-133   { color:            #af5faf; }
   .ansi-38-5-134   { color:            #af5fd7; }
   .ansi-38-5-135   { color:            #af5fff; }
   .ansi-38-5-136   { color:            #af8700; }
   .ansi-38-5-137   { color:            #af875f; }
   .ansi-38-5-138   { color:            #af8787; }
   .ansi-38-5-139   { color:            #af87af; }
   .ansi-38-5-140   { color:            #af87d7; }
   .ansi-38-5-141   { color:            #af87ff; }
   .ansi-38-5-142   { color:            #afaf00; }
   .ansi-38-5-143   { color:            #afaf5f; }
   .ansi-38-5-144   { color:            #afaf87; }
   .ansi-38-5-145   { color:            #afafaf; }
   .ansi-38-5-146   { color:            #afafd7; }
   .ansi-38-5-147   { color:            #afafff; }
   .ansi-38-5-148   { color:            #afd700; }
   .ansi-38-5-149   { color:            #afd75f; }
   .ansi-38-5-150   { color:            #afd787; }
   .ansi-38-5-151   { color:            #afd7af; }
   .ansi-38-5-152   { color:            #afd7d7; }
   .ansi-38-5-153   { color:            #afd7ff; }
   .ansi-38-5-154   { color:            #afff00; }
   .ansi-38-5-155   { color:            #afff5f; }
   .ansi-38-5-156   { color:            #afff87; }
   .ansi-38-5-157   { color:            #afffaf; }
   .ansi-38-5-158   { color:            #afffd7; }
   .ansi-38-5-159   { color:            #afffff; }
   .ansi-38-5-160   { color:            #d70000; }
   .ansi-38-5-161   { color:            #d7005f; }
   .ansi-38-5-162   { color:            #d70087; }
   .ansi-38-5-163   { color:            #d700af; }
   .ansi-38-5-164   { color:            #d700d7; }
   .ansi-38-5-165   { color:            #d700ff; }
   .ansi-38-5-166   { color:            #d75f00; }
   .ansi-38-5-167   { color:            #d75f5f; }
   .ansi-38-5-168   { color:            #d75f87; }
   .ansi-38-5-169   { color:            #d75faf; }
   .ansi-38-5-170   { color:            #d75fd7; }
   .ansi-38-5-171   { color:            #d75fff; }
   .ansi-38-5-172   { color:            #d78700; }
   .ansi-38-5-173   { color:            #d7875f; }
   .ansi-38-5-174   { color:            #d78787; }
   .ansi-38-5-175   { color:            #d787af; }
   .ansi-38-5-176   { color:            #d787d7; }
   .ansi-38-5-177   { color:            #d787ff; }
   .ansi-38-5-178   { color:            #d7af00; }
   .ansi-38-5-179   { color:            #d7af5f; }
   .ansi-38-5-180   { color:            #d7af87; }
   .ansi-38-5-181   { color:            #d7afaf; }
   .ansi-38-5-182   { color:            #d7afd7; }
   .ansi-38-5-183   { color:            #d7afff; }
   .ansi-38-5-184   { color:            #d7d700; }
   .ansi-38-5-185   { color:            #d7d75f; }
   .ansi-38-5-186   { color:            #d7d787; }
   .ansi-38-5-187   { color:            #d7d7af; }
   .ansi-38-5-188   { color:            #d7d7d7; }
   .ansi-38-5-189   { color:            #d7d7ff; }
   .ansi-38-5-190   { color:            #d7ff00; }
   .ansi-38-5-191   { color:            #d7ff5f; }
   .ansi-38-5-192   { color:            #d7ff87; }
   .ansi-38-5-193   { color:            #d7ffaf; }
   .ansi-38-5-194   { color:            #d7ffd7; }
   .ansi-38-5-195   { color:            #d7ffff; }
   .ansi-38-5-196   { color:            #ff0000; }
   .ansi-38-5-197   { color:            #ff005f; }
   .ansi-38-5-198   { color:            #ff0087; }
   .ansi-38-5-199   { color:            #ff00af; }
   .ansi-38-5-200   { color:            #ff00d7; }
   .ansi-38-5-201   { color:            #ff00ff; }
   .ansi-38-5-202   { color:            #ff5f00; }
   .ansi-38-5-203   { color:            #ff5f5f; }
   .ansi-38-5-204   { color:            #ff5f87; }
   .ansi-38-5-205   { color:            #ff5faf; }
   .ansi-38-5-206   { color:            #ff5fd7; }
   .ansi-38-5-207   { color:            #ff5fff; }
   .ansi-38-5-208   { color:            #ff8700; }
   .ansi-38-5-209   { color:            #ff875f; }
   .ansi-38-5-210   { color:            #ff8787; }
   .ansi-38-5-211   { color:            #ff87af; }
   .ansi-38-5-212   { color:            #ff87d7; }
   .ansi-38-5-213   { color:            #ff87ff; }
   .ansi-38-5-214   { color:            #ffaf00; }
   .ansi-38-5-215   { color:            #ffaf5f; }
   .ansi-38-5-216   { color:            #ffaf87; }
   .ansi-38-5-217   { color:            #ffafaf; }
   .ansi-38-5-218   { color:            #ffafd7; }
   .ansi-38-5-219   { color:            #ffafff; }
   .ansi-38-5-220   { color:            #ffd700; }
   .ansi-38-5-221   { color:            #ffd75f; }
   .ansi-38-5-222   { color:            #ffd787; }
   .ansi-38-5-223   { color:            #ffd7af; }
   .ansi-38-5-224   { color:            #ffd7d7; }
   .ansi-38-5-225   { color:            #ffd7ff; }
   .ansi-38-5-226   { color:            #ffff00; }
   .ansi-38-5-227   { color:            #ffff5f; }
   .ansi-38-5-228   { color:            #ffff87; }
   .ansi-38-5-229   { color:            #ffffaf; }
   .ansi-38-5-230   { color:            #ffffd7; }
   .ansi-38-5-231   { color:            #ffffff; }
   .ansi-38-5-232   { color:            #080808; }
   .ansi-38-5-233   { color:            #121212; }
   .ansi-38-5-234   { color:            #1c1c1c; }
   .ansi-38-5-235   { color:            #262626; }
   .ansi-38-5-236   { color:            #303030; }
   .ansi-38-5-237   { color:            #3a3a3a; }
   .ansi-38-5-238   { color:            #444444; }
   .ansi-38-5-239   { color:            #4e4e4e; }
   .ansi-38-5-240   { color:            #585858; }
   .ansi-38-5-241   { color:            #626262; }
   .ansi-38-5-242   { color:            #6c6c6c; }
   .ansi-38-5-243   { color:            #767676; }
   .ansi-38-5-244   { color:            #808080; }
   .ansi-38-5-245   { color:            #8a8a8a; }
   .ansi-38-5-246   { color:            #949494; }
   .ansi-38-5-247   { color:            #9e9e9e; }
   .ansi-38-5-248   { color:            #a8a8a8; }
   .ansi-38-5-249   { color:            #b2b2b2; }
   .ansi-38-5-250   { color:            #bcbcbc; }
   .ansi-38-5-251   { color:            #c6c6c6; }
   .ansi-38-5-252   { color:            #d0d0d0; }
   .ansi-38-5-253   { color:            #dadada; }
   .ansi-38-5-254   { color:            #e4e4e4; }
   .ansi-38-5-255   { color:            #eeeeee; }
   
   /* SYSTEM colors */
   
   .ansi-48-5-0   { background-color: #000000; }
   .ansi-48-5-1   { background-color: #cd0000; }
   .ansi-48-5-2   { background-color: #00cd00; }
   .ansi-48-5-3   { background-color: #cdcd00; }
   .ansi-48-5-4   { background-color: #0000ee; }
   .ansi-48-5-5   { background-color: #cd00cd; }
   .ansi-48-5-6   { background-color: #00cdcd; }
   .ansi-48-5-7   { background-color: #e5e5e5; }
   .ansi-48-5-8   { background-color: #7f7f7f; }
   .ansi-48-5-9   { background-color: #ff0000; }
   .ansi-48-5-10  { background-color: #00ff00; }
   .ansi-48-5-11  { background-color: #e8e800; }
   .ansi-48-5-12  { background-color: #5c5cff; }
   .ansi-48-5-13  { background-color: #ff00ff; }
   .ansi-48-5-14  { background-color: #00ffff; }
   .ansi-48-5-15  { background-color: #ffffff; }
   
   /* XTERM colors - 256 color mode */
   .ansi-48-5-16  { background-color: #000000; }
   .ansi-48-5-17  { background-color: #00005f; }
   .ansi-48-5-18  { background-color: #000087; }
   .ansi-48-5-19  { background-color: #0000af; }
   .ansi-48-5-20  { background-color: #0000d7; }
   .ansi-48-5-21  { background-color: #0000ff; }
   .ansi-48-5-22  { background-color: #005f00; }
   .ansi-48-5-23  { background-color: #005f5f; }
   .ansi-48-5-24  { background-color: #005f87; }
   .ansi-48-5-25  { background-color: #005faf; }
   .ansi-48-5-26  { background-color: #005fd7; }
   .ansi-48-5-27  { background-color: #005fff; }
   .ansi-48-5-28  { background-color: #008700; }
   .ansi-48-5-29  { background-color: #00875f; }
   .ansi-48-5-30  { background-color: #008787; }
   .ansi-48-5-31  { background-color: #0087af; }
   .ansi-48-5-32  { background-color: #0087d7; }
   .ansi-48-5-33  { background-color: #0087ff; }
   .ansi-48-5-34  { background-color: #00af00; }
   .ansi-48-5-35  { background-color: #00af5f; }
   .ansi-48-5-36  { background-color: #00af87; }
   .ansi-48-5-37  { background-color: #00afaf; }
   .ansi-48-5-38  { background-color: #00afd7; }
   .ansi-48-5-39  { background-color: #00afff; }
   .ansi-48-5-40  { background-color: #00d700; }
   .ansi-48-5-41  { background-color: #00d75f; }
   .ansi-48-5-42  { background-color: #00d787; }
   .ansi-48-5-43  { background-color: #00d7af; }
   .ansi-48-5-44  { background-color: #00d7d7; }
   .ansi-48-5-45  { background-color: #00d7ff; }
   .ansi-48-5-46  { background-color: #00ff00; }
   .ansi-48-5-47  { background-color: #00ff5f; }
   .ansi-48-5-48  { background-color: #00ff87; }
   .ansi-48-5-49  { background-color: #00ffaf; }
   .ansi-48-5-50  { background-color: #00ffd7; }
   .ansi-48-5-51  { background-color: #00ffff; }
   .ansi-48-5-52  { background-color: #5f0000; }
   .ansi-48-5-53  { background-color: #5f005f; }
   .ansi-48-5-54  { background-color: #5f0087; }
   .ansi-48-5-55  { background-color: #5f00af; }
   .ansi-48-5-56  { background-color: #5f00d7; }
   .ansi-48-5-57  { background-color: #5f00ff; }
   .ansi-48-5-58  { background-color: #5f5f00; }
   .ansi-48-5-59  { background-color: #5f5f5f; }
   .ansi-48-5-60  { background-color: #5f5f87; }
   .ansi-48-5-61  { background-color: #5f5faf; }
   .ansi-48-5-62  { background-color: #5f5fd7; }
   .ansi-48-5-63  { background-color: #5f5fff; }
   .ansi-48-5-64  { background-color: #5f8700; }
   .ansi-48-5-65  { background-color: #5f875f; }
   .ansi-48-5-66  { background-color: #5f8787; }
   .ansi-48-5-67  { background-color: #5f87af; }
   .ansi-48-5-68  { background-color: #5f87d7; }
   .ansi-48-5-69  { background-color: #5f87ff; }
   .ansi-48-5-70  { background-color: #5faf00; }
   .ansi-48-5-71  { background-color: #5faf5f; }
   .ansi-48-5-72  { background-color: #5faf87; }
   .ansi-48-5-73  { background-color: #5fafaf; }
   .ansi-48-5-74  { background-color: #5fafd7; }
   .ansi-48-5-75  { background-color: #5fafff; }
   .ansi-48-5-76  { background-color: #5fd700; }
   .ansi-48-5-77  { background-color: #5fd75f; }
   .ansi-48-5-78  { background-color: #5fd787; }
   .ansi-48-5-79  { background-color: #5fd7af; }
   .ansi-48-5-80  { background-color: #5fd7d7; }
   .ansi-48-5-81  { background-color: #5fd7ff; }
   .ansi-48-5-82  { background-color: #5fff00; }
   .ansi-48-5-83  { background-color: #5fff5f; }
   .ansi-48-5-84  { background-color: #5fff87; }
   .ansi-48-5-85  { background-color: #5fffaf; }
   .ansi-48-5-86  { background-color: #5fffd7; }
   .ansi-48-5-87  { background-color: #5fffff; }
   .ansi-48-5-88  { background-color: #870000; }
   .ansi-48-5-89  { background-color: #87005f; }
   .ansi-48-5-90  { background-color: #870087; }
   .ansi-48-5-91  { background-color: #8700af; }
   .ansi-48-5-92  { background-color: #8700d7; }
   .ansi-48-5-93  { background-color: #8700ff; }
   .ansi-48-5-94  { background-color: #875f00; }
   .ansi-48-5-95  { background-color: #875f5f; }
   .ansi-48-5-96  { background-color: #875f87; }
   .ansi-48-5-97  { background-color: #875faf; }
   .ansi-48-5-98  { background-color: #875fd7; }
   .ansi-48-5-99  { background-color: #875fff; }
   .ansi-48-5-100 { background-color: #878700; }
   .ansi-48-5-101 { background-color: #87875f; }
   .ansi-48-5-102 { background-color: #878787; }
   .ansi-48-5-103 { background-color: #8787af; }
   .ansi-48-5-104 { background-color: #8787d7; }
   .ansi-48-5-105 { background-color: #8787ff; }
   .ansi-48-5-106 { background-color: #87af00; }
   .ansi-48-5-107 { background-color: #87af5f; }
   .ansi-48-5-108 { background-color: #87af87; }
   .ansi-48-5-109 { background-color: #87afaf; }
   .ansi-48-5-110 { background-color: #87afd7; }
   .ansi-48-5-111 { background-color: #87afff; }
   .ansi-48-5-112 { background-color: #87d700; }
   .ansi-48-5-113 { background-color: #87d75f; }
   .ansi-48-5-114 { background-color: #87d787; }
   .ansi-48-5-115 { background-color: #87d7af; }
   .ansi-48-5-116 { background-color: #87d7d7; }
   .ansi-48-5-117 { background-color: #87d7ff; }
   .ansi-48-5-118 { background-color: #87ff00; }
   .ansi-48-5-119 { background-color: #87ff5f; }
   .ansi-48-5-120 { background-color: #87ff87; }
   .ansi-48-5-121 { background-color: #87ffaf; }
   .ansi-48-5-122 { background-color: #87ffd7; }
   .ansi-48-5-123 { background-color: #87ffff; }
   .ansi-48-5-124 { background-color: #af0000; }
   .ansi-48-5-125 { background-color: #af005f; }
   .ansi-48-5-126 { background-color: #af0087; }
   .ansi-48-5-127 { background-color: #af00af; }
   .ansi-48-5-128 { background-color: #af00d7; }
   .ansi-48-5-129 { background-color: #af00ff; }
   .ansi-48-5-130 { background-color: #af5f00; }
   .ansi-48-5-131 { background-color: #af5f5f; }
   .ansi-48-5-132 { background-color: #af5f87; }
   .ansi-48-5-133 { background-color: #af5faf; }
   .ansi-48-5-134 { background-color: #af5fd7; }
   .ansi-48-5-135 { background-color: #af5fff; }
   .ansi-48-5-136 { background-color: #af8700; }
   .ansi-48-5-137 { background-color: #af875f; }
   .ansi-48-5-138 { background-color: #af8787; }
   .ansi-48-5-139 { background-color: #af87af; }
   .ansi-48-5-140 { background-color: #af87d7; }
   .ansi-48-5-141 { background-color: #af87ff; }
   .ansi-48-5-142 { background-color: #afaf00; }
   .ansi-48-5-143 { background-color: #afaf5f; }
   .ansi-48-5-144 { background-color: #afaf87; }
   .ansi-48-5-145 { background-color: #afafaf; }
   .ansi-48-5-146 { background-color: #afafd7; }
   .ansi-48-5-147 { background-color: #afafff; }
   .ansi-48-5-148 { background-color: #afd700; }
   .ansi-48-5-149 { background-color: #afd75f; }
   .ansi-48-5-150 { background-color: #afd787; }
   .ansi-48-5-151 { background-color: #afd7af; }
   .ansi-48-5-152 { background-color: #afd7d7; }
   .ansi-48-5-153 { background-color: #afd7ff; }
   .ansi-48-5-154 { background-color: #afff00; }
   .ansi-48-5-155 { background-color: #afff5f; }
   .ansi-48-5-156 { background-color: #afff87; }
   .ansi-48-5-157 { background-color: #afffaf; }
   .ansi-48-5-158 { background-color: #afffd7; }
   .ansi-48-5-159 { background-color: #afffff; }
   .ansi-48-5-160 { background-color: #d70000; }
   .ansi-48-5-161 { background-color: #d7005f; }
   .ansi-48-5-162 { background-color: #d70087; }
   .ansi-48-5-163 { background-color: #d700af; }
   .ansi-48-5-164 { background-color: #d700d7; }
   .ansi-48-5-165 { background-color: #d700ff; }
   .ansi-48-5-166 { background-color: #d75f00; }
   .ansi-48-5-167 { background-color: #d75f5f; }
   .ansi-48-5-168 { background-color: #d75f87; }
   .ansi-48-5-169 { background-color: #d75faf; }
   .ansi-48-5-170 { background-color: #d75fd7; }
   .ansi-48-5-171 { background-color: #d75fff; }
   .ansi-48-5-172 { background-color: #d78700; }
   .ansi-48-5-173 { background-color: #d7875f; }
   .ansi-48-5-174 { background-color: #d78787; }
   .ansi-48-5-175 { background-color: #d787af; }
   .ansi-48-5-176 { background-color: #d787d7; }
   .ansi-48-5-177 { background-color: #d787ff; }
   .ansi-48-5-178 { background-color: #d7af00; }
   .ansi-48-5-179 { background-color: #d7af5f; }
   .ansi-48-5-180 { background-color: #d7af87; }
   .ansi-48-5-181 { background-color: #d7afaf; }
   .ansi-48-5-182 { background-color: #d7afd7; }
   .ansi-48-5-183 { background-color: #d7afff; }
   .ansi-48-5-184 { background-color: #d7d700; }
   .ansi-48-5-185 { background-color: #d7d75f; }
   .ansi-48-5-186 { background-color: #d7d787; }
   .ansi-48-5-187 { background-color: #d7d7af; }
   .ansi-48-5-188 { background-color: #d7d7d7; }
   .ansi-48-5-189 { background-color: #d7d7ff; }
   .ansi-48-5-190 { background-color: #d7ff00; }
   .ansi-48-5-191 { background-color: #d7ff5f; }
   .ansi-48-5-192 { background-color: #d7ff87; }
   .ansi-48-5-193 { background-color: #d7ffaf; }
   .ansi-48-5-194 { background-color: #d7ffd7; }
   .ansi-48-5-195 { background-color: #d7ffff; }
   .ansi-48-5-196 { background-color: #ff0000; }
   .ansi-48-5-197 { background-color: #ff005f; }
   .ansi-48-5-198 { background-color: #ff0087; }
   .ansi-48-5-199 { background-color: #ff00af; }
   .ansi-48-5-200 { background-color: #ff00d7; }
   .ansi-48-5-201 { background-color: #ff00ff; }
   .ansi-48-5-202 { background-color: #ff5f00; }
   .ansi-48-5-203 { background-color: #ff5f5f; }
   .ansi-48-5-204 { background-color: #ff5f87; }
   .ansi-48-5-205 { background-color: #ff5faf; }
   .ansi-48-5-206 { background-color: #ff5fd7; }
   .ansi-48-5-207 { background-color: #ff5fff; }
   .ansi-48-5-208 { background-color: #ff8700; }
   .ansi-48-5-209 { background-color: #ff875f; }
   .ansi-48-5-210 { background-color: #ff8787; }
   .ansi-48-5-211 { background-color: #ff87af; }
   .ansi-48-5-212 { background-color: #ff87d7; }
   .ansi-48-5-213 { background-color: #ff87ff; }
   .ansi-48-5-214 { background-color: #ffaf00; }
   .ansi-48-5-215 { background-color: #ffaf5f; }
   .ansi-48-5-216 { background-color: #ffaf87; }
   .ansi-48-5-217 { background-color: #ffafaf; }
   .ansi-48-5-218 { background-color: #ffafd7; }
   .ansi-48-5-219 { background-color: #ffafff; }
   .ansi-48-5-220 { background-color: #ffd700; }
   .ansi-48-5-221 { background-color: #ffd75f; }
   .ansi-48-5-222 { background-color: #ffd787; }
   .ansi-48-5-223 { background-color: #ffd7af; }
   .ansi-48-5-224 { background-color: #ffd7d7; }
   .ansi-48-5-225 { background-color: #ffd7ff; }
   .ansi-48-5-226 { background-color: #ffff00; }
   .ansi-48-5-227 { background-color: #ffff5f; }
   .ansi-48-5-228 { background-color: #ffff87; }
   .ansi-48-5-229 { background-color: #ffffaf; }
   .ansi-48-5-230 { background-color: #ffffd7; }
   .ansi-48-5-231 { background-color: #ffffff; }
   .ansi-48-5-232 { background-color: #080808; }
   .ansi-48-5-233 { background-color: #121212; }
   .ansi-48-5-234 { background-color: #1c1c1c; }
   .ansi-48-5-235 { background-color: #262626; }
   .ansi-48-5-236 { background-color: #303030; }
   .ansi-48-5-237 { background-color: #3a3a3a; }
   .ansi-48-5-238 { background-color: #444444; }
   .ansi-48-5-239 { background-color: #4e4e4e; }
   .ansi-48-5-240 { background-color: #585858; }
   .ansi-48-5-241 { background-color: #626262; }
   .ansi-48-5-242 { background-color: #6c6c6c; }
   .ansi-48-5-243 { background-color: #767676; }
   .ansi-48-5-244 { background-color: #808080; }
   .ansi-48-5-245 { background-color: #8a8a8a; }
   .ansi-48-5-246 { background-color: #949494; }
   .ansi-48-5-247 { background-color: #9e9e9e; }
   .ansi-48-5-248 { background-color: #a8a8a8; }
   .ansi-48-5-249 { background-color: #b2b2b2; }
   .ansi-48-5-250 { background-color: #bcbcbc; }
   .ansi-48-5-251 { background-color: #c6c6c6; }
   .ansi-48-5-252 { background-color: #d0d0d0; }
   .ansi-48-5-253 { background-color: #dadada; }
   .ansi-48-5-254 { background-color: #e4e4e4; }
   .ansi-48-5-255 { background-color: #eeeeee; }
__ANSI__

   @http_data{"orig_muddler_dark_ansi.css"}=<<__ANSI__;
   .ansi-4 { text-decoration: underline; }
   
   /* blinking text */
   .ansi-5 {
       -webkit-animation: blink .75s linear infinite;
       -moz-animation: blink .75s linear infinite;
       -ms-animation: blink .75s linear infinite;
       -o-animation: blink .75s linear infinite;
       animation: blink .75s linear infinite;
   }
   
   /* standard 16 foreground colors */
   .ansi-30 { color: black; }
   .ansi-1-30 { color: gray; }
   .ansi-31 { color: maroon; }
   .ansi-1-31 { color: red; }
   .ansi-32 { color: green; }
   .ansi-1-32 { color: lime; }
   .ansi-33 { color: olive; }
   .ansi-1-33 { color: yellow; }
   .ansi-34 { color: navy; }
   .ansi-1-34 { color: blue; }
   .ansi-35 { color: purple; }
   .ansi-1-35 { color: fuchsia; }
   .ansi-36 { color: teal; }
   .ansi-1-36 { color: aqua; }
   .ansi-37 { color: black; }
   .ansi-1-37 { color: white; }
   
   /* standard 16 background colors */
   .ansi-40 { background-color: black; }
   .ansi-1-40 { background-color: gray; }
   .ansi-41 { background-color: maroon; }
   .ansi-1-41 { background-color: red; }
   .ansi-42 { background-color: green; }
   .ansi-1-42 { background-color: lime; }
   .ansi-43 { background-color: olive; }
   .ansi-1-43 { background-color: yellow; }
   .ansi-44 { background-color: navy; }
   .ansi-1-44 { background-color: blue; }
   .ansi-45 { background-color: purple; }
   .ansi-1-45 { background-color: fuchsia; }
   .ansi-46 { background-color: teal; }
   .ansi-1-46 { background-color: aqua; }
   .ansi-47 { background-color: silver; }
   .ansi-1-47 { background-color: white; }
   
   /* xterm256 foreground colors */
   .ansi-38-5-0 { color: #000000; }
   .ansi-38-5-1 { color: #800000; }
   .ansi-38-5-2 { color: #008000; }
   .ansi-38-5-3 { color: #808000; }
   .ansi-38-5-4 { color: #000080; }
   .ansi-38-5-5 { color: #800080; }
   .ansi-38-5-6 { color: #008080; }
   .ansi-38-5-7 { color: #c0c0c0; }
   .ansi-38-5-8 { color: #808080; }
   .ansi-38-5-9 { color: #ff0000; }
   .ansi-38-5-10 { color: #00ff00; }
   .ansi-38-5-11 { color: #ffff00; }
   .ansi-38-5-12 { color: #0000ff; }
   .ansi-38-5-13 { color: #ff00ff; }
   .ansi-38-5-14 { color: #00ffff; }
   .ansi-38-5-15 { color: #ffffff; }
   .ansi-38-5-16 { color: #000000; }
   .ansi-38-5-17 { color: #00005f; }
   .ansi-38-5-18 { color: #000087; }
   .ansi-38-5-19 { color: #0000af; }
   .ansi-38-5-20 { color: #0000d7; }
   .ansi-38-5-21 { color: #0000ff; }
   .ansi-38-5-22 { color: #005f00; }
   .ansi-38-5-23 { color: #005f5f; }
   .ansi-38-5-24 { color: #005f87; }
   .ansi-38-5-25 { color: #005faf; }
   .ansi-38-5-26 { color: #005fd7; }
   .ansi-38-5-27 { color: #005fff; }
   .ansi-38-5-28 { color: #008700; }
   .ansi-38-5-29 { color: #00875f; }
   .ansi-38-5-30 { color: #008787; }
   .ansi-38-5-31 { color: #0087af; }
   .ansi-38-5-32 { color: #0087d7; }
   .ansi-38-5-33 { color: #0087ff; }
   .ansi-38-5-34 { color: #00af00; }
   .ansi-38-5-35 { color: #00af5f; }
   .ansi-38-5-36 { color: #00af87; }
   .ansi-38-5-37 { color: #00afaf; }
   .ansi-38-5-38 { color: #00afd7; }
   .ansi-38-5-39 { color: #00afff; }
   .ansi-38-5-40 { color: #00d700; }
   .ansi-38-5-41 { color: #00d75f; }
   .ansi-38-5-42 { color: #00d787; }
   .ansi-38-5-43 { color: #00d7af; }
   .ansi-38-5-44 { color: #00d7d7; }
   .ansi-38-5-45 { color: #00d7ff; }
   .ansi-38-5-46 { color: #00ff00; }
   .ansi-38-5-47 { color: #00ff5f; }
   .ansi-38-5-48 { color: #00ff87; }
   .ansi-38-5-49 { color: #00ffaf; }
   .ansi-38-5-50 { color: #00ffd7; }
   .ansi-38-5-51 { color: #00ffff; }
   .ansi-38-5-52 { color: #5f0000; }
   .ansi-38-5-53 { color: #5f005f; }
   .ansi-38-5-54 { color: #5f0087; }
   .ansi-38-5-55 { color: #5f00af; }
   .ansi-38-5-56 { color: #5f00d7; }
   .ansi-38-5-57 { color: #5f00ff; }
   .ansi-38-5-58 { color: #5f5f00; }
   .ansi-38-5-59 { color: #5f5f5f; }
   .ansi-38-5-60 { color: #5f5f87; }
   .ansi-38-5-61 { color: #5f5faf; }
   .ansi-38-5-62 { color: #5f5fd7; }
   .ansi-38-5-63 { color: #5f5fff; }
   .ansi-38-5-64 { color: #5f8700; }
   .ansi-38-5-65 { color: #5f875f; }
   .ansi-38-5-66 { color: #5f8787; }
   .ansi-38-5-67 { color: #5f87af; }
   .ansi-38-5-68 { color: #5f87d7; }
   .ansi-38-5-69 { color: #5f87ff; }
   .ansi-38-5-70 { color: #5faf00; }
   .ansi-38-5-71 { color: #5faf5f; }
   .ansi-38-5-72 { color: #5faf87; }
   .ansi-38-5-73 { color: #5fafaf; }
   .ansi-38-5-74 { color: #5fafd7; }
   .ansi-38-5-75 { color: #5fafff; }
   .ansi-38-5-76 { color: #5fd700; }
   .ansi-38-5-77 { color: #5fd75f; }
   .ansi-38-5-78 { color: #5fd787; }
   .ansi-38-5-79 { color: #5fd7af; }
   .ansi-38-5-80 { color: #5fd7d7; }
   .ansi-38-5-81 { color: #5fd7ff; }
   .ansi-38-5-82 { color: #5fff00; }
   .ansi-38-5-83 { color: #5fff5f; }
   .ansi-38-5-84 { color: #5fff87; }
   .ansi-38-5-85 { color: #5fffaf; }
   .ansi-38-5-86 { color: #5fffd7; }
   .ansi-38-5-87 { color: #5fffff; }
   .ansi-38-5-88 { color: #870000; }
   .ansi-38-5-89 { color: #87005f; }
   .ansi-38-5-90 { color: #870087; }
   .ansi-38-5-91 { color: #8700af; }
   .ansi-38-5-92 { color: #8700d7; }
   .ansi-38-5-93 { color: #8700ff; }
   .ansi-38-5-94 { color: #875f00; }
   .ansi-38-5-95 { color: #875f5f; }
   .ansi-38-5-96 { color: #875f87; }
   .ansi-38-5-97 { color: #875faf; }
   .ansi-38-5-98 { color: #875fd7; }
   .ansi-38-5-99 { color: #875fff; }
   .ansi-38-5-100 { color: #878700; }
   .ansi-38-5-101 { color: #87875f; }
   .ansi-38-5-102 { color: #878787; }
   .ansi-38-5-103 { color: #8787af; }
   .ansi-38-5-104 { color: #8787d7; }
   .ansi-38-5-105 { color: #8787ff; }
   .ansi-38-5-106 { color: #87af00; }
   .ansi-38-5-107 { color: #87af5f; }
   .ansi-38-5-108 { color: #87af87; }
   .ansi-38-5-109 { color: #87afaf; }
   .ansi-38-5-110 { color: #87afd7; }
   .ansi-38-5-111 { color: #87afff; }
   .ansi-38-5-112 { color: #87d700; }
   .ansi-38-5-113 { color: #87d75f; }
   .ansi-38-5-114 { color: #87d787; }
   .ansi-38-5-115 { color: #87d7af; }
   .ansi-38-5-116 { color: #87d7d7; }
   .ansi-38-5-117 { color: #87d7ff; }
   .ansi-38-5-118 { color: #87ff00; }
   .ansi-38-5-119 { color: #87ff5f; }
   .ansi-38-5-120 { color: #87ff87; }
   .ansi-38-5-121 { color: #87ffaf; }
   .ansi-38-5-122 { color: #87ffd7; }
   .ansi-38-5-123 { color: #87ffff; }
   .ansi-38-5-124 { color: #af0000; }
   .ansi-38-5-125 { color: #af005f; }
   .ansi-38-5-126 { color: #af0087; }
   .ansi-38-5-127 { color: #af00af; }
   .ansi-38-5-128 { color: #af00d7; }
   .ansi-38-5-129 { color: #af00ff; }
   .ansi-38-5-130 { color: #af5f00; }
   .ansi-38-5-131 { color: #af5f5f; }
   .ansi-38-5-132 { color: #af5f87; }
   .ansi-38-5-133 { color: #af5faf; }
   .ansi-38-5-134 { color: #af5fd7; }
   .ansi-38-5-135 { color: #af5fff; }
   .ansi-38-5-136 { color: #af8700; }
   .ansi-38-5-137 { color: #af875f; }
   .ansi-38-5-138 { color: #af8787; }
   .ansi-38-5-139 { color: #af87af; }
   .ansi-38-5-140 { color: #af87d7; }
   .ansi-38-5-141 { color: #af87ff; }
   .ansi-38-5-142 { color: #afaf00; }
   .ansi-38-5-143 { color: #afaf5f; }
   .ansi-38-5-144 { color: #afaf87; }
   .ansi-38-5-145 { color: #afafaf; }
   .ansi-38-5-146 { color: #afafd7; }
   .ansi-38-5-147 { color: #afafff; }
   .ansi-38-5-148 { color: #afd700; }
   .ansi-38-5-149 { color: #afd75f; }
   .ansi-38-5-150 { color: #afd787; }
   .ansi-38-5-151 { color: #afd7af; }
   .ansi-38-5-152 { color: #afd7d7; }
   .ansi-38-5-153 { color: #afd7ff; }
   .ansi-38-5-154 { color: #afff00; }
   .ansi-38-5-155 { color: #afff5f; }
   .ansi-38-5-156 { color: #afff87; }
   .ansi-38-5-157 { color: #afffaf; }
   .ansi-38-5-158 { color: #afffd7; }
   .ansi-38-5-159 { color: #afffff; }
   .ansi-38-5-160 { color: #d70000; }
   .ansi-38-5-161 { color: #d7005f; }
   .ansi-38-5-162 { color: #d70087; }
   .ansi-38-5-163 { color: #d700af; }
   .ansi-38-5-164 { color: #d700d7; }
   .ansi-38-5-165 { color: #d700ff; }
   .ansi-38-5-166 { color: #d75f00; }
   .ansi-38-5-167 { color: #d75f5f; }
   .ansi-38-5-168 { color: #d75f87; }
   .ansi-38-5-169 { color: #d75faf; }
   .ansi-38-5-170 { color: #d75fd7; }
   .ansi-38-5-171 { color: #d75fff; }
   .ansi-38-5-172 { color: #d78700; }
   .ansi-38-5-173 { color: #d7875f; }
   .ansi-38-5-174 { color: #d78787; }
   .ansi-38-5-175 { color: #d787af; }
   .ansi-38-5-176 { color: #d787d7; }
   .ansi-38-5-177 { color: #d787ff; }
   .ansi-38-5-178 { color: #d7af00; }
   .ansi-38-5-179 { color: #d7af5f; }
   .ansi-38-5-180 { color: #d7af87; }
   .ansi-38-5-181 { color: #d7afaf; }
   .ansi-38-5-182 { color: #d7afd7; }
   .ansi-38-5-183 { color: #d7afff; }
   .ansi-38-5-184 { color: #d7d700; }
   .ansi-38-5-185 { color: #d7d75f; }
   .ansi-38-5-186 { color: #d7d787; }
   .ansi-38-5-187 { color: #d7d7af; }
   .ansi-38-5-188 { color: #d7d7d7; }
   .ansi-38-5-189 { color: #d7d7ff; }
   .ansi-38-5-190 { color: #d7ff00; }
   .ansi-38-5-191 { color: #d7ff5f; }
   .ansi-38-5-192 { color: #d7ff87; }
   .ansi-38-5-193 { color: #d7ffaf; }
   .ansi-38-5-194 { color: #d7ffd7; }
   .ansi-38-5-195 { color: #d7ffff; }
   .ansi-38-5-196 { color: #ff0000; }
   .ansi-38-5-197 { color: #ff005f; }
   .ansi-38-5-198 { color: #ff0087; }
   .ansi-38-5-199 { color: #ff00af; }
   .ansi-38-5-200 { color: #ff00d7; }
   .ansi-38-5-201 { color: #ff00ff; }
   .ansi-38-5-202 { color: #ff5f00; }
   .ansi-38-5-203 { color: #ff5f5f; }
   .ansi-38-5-204 { color: #ff5f87; }
   .ansi-38-5-205 { color: #ff5faf; }
   .ansi-38-5-206 { color: #ff5fd7; }
   .ansi-38-5-207 { color: #ff5fff; }
   .ansi-38-5-208 { color: #ff8700; }
   .ansi-38-5-209 { color: #ff875f; }
   .ansi-38-5-210 { color: #ff8787; }
   .ansi-38-5-211 { color: #ff87af; }
   .ansi-38-5-212 { color: #ff87d7; }
   .ansi-38-5-213 { color: #ff87ff; }
   .ansi-38-5-214 { color: #ffaf00; }
   .ansi-38-5-215 { color: #ffaf5f; }
   .ansi-38-5-216 { color: #ffaf87; }
   .ansi-38-5-217 { color: #ffafaf; }
   .ansi-38-5-218 { color: #ffafd7; }
   .ansi-38-5-219 { color: #ffafff; }
   .ansi-38-5-220 { color: #ffd700; }
   .ansi-38-5-221 { color: #ffd75f; }
   .ansi-38-5-222 { color: #ffd787; }
   .ansi-38-5-223 { color: #ffd7af; }
   .ansi-38-5-224 { color: #ffd7d7; }
   .ansi-38-5-225 { color: #ffd7ff; }
   .ansi-38-5-226 { color: #ffff00; }
   .ansi-38-5-227 { color: #ffff5f; }
   .ansi-38-5-228 { color: #ffff87; }
   .ansi-38-5-229 { color: #ffffaf; }
   .ansi-38-5-230 { color: #ffffd7; }
   .ansi-38-5-231 { color: #ffffff; }
   .ansi-38-5-232 { color: #080808; }
   .ansi-38-5-233 { color: #121212; }
   .ansi-38-5-234 { color: #1c1c1c; }
   .ansi-38-5-235 { color: #262626; }
   .ansi-38-5-236 { color: #303030; }
   .ansi-38-5-237 { color: #3a3a3a; }
   .ansi-38-5-238 { color: #444444; }
   .ansi-38-5-239 { color: #4e4e4e; }
   .ansi-38-5-240 { color: #585858; }
   .ansi-38-5-241 { color: #626262; }
   .ansi-38-5-242 { color: #6c6c6c; }
   .ansi-38-5-243 { color: #767676; }
   .ansi-38-5-244 { color: #808080; }
   .ansi-38-5-245 { color: #8a8a8a; }
   .ansi-38-5-246 { color: #949494; }
   .ansi-38-5-247 { color: #9e9e9e; }
   .ansi-38-5-248 { color: #a8a8a8; }
   .ansi-38-5-249 { color: #b2b2b2; }
   .ansi-38-5-250 { color: #bcbcbc; }
   .ansi-38-5-251 { color: #c6c6c6; }
   .ansi-38-5-252 { color: #d0d0d0; }
   .ansi-38-5-253 { color: #dadada; }
   .ansi-38-5-254 { color: #e4e4e4; }
   .ansi-38-5-255 { color: #eeeeee; }
   
   /* xterm256 background colors */
   .ansi-48-5-0 { background-color: #000000; }
   .ansi-48-5-1 { background-color: #800000; }
   .ansi-48-5-2 { background-color: #008000; }
   .ansi-48-5-3 { background-color: #808000; }
   .ansi-48-5-4 { background-color: #000080; }
   .ansi-48-5-5 { background-color: #800080; }
   .ansi-48-5-6 { background-color: #008080; }
   .ansi-48-5-7 { background-color: #c0c0c0; }
   .ansi-48-5-8 { background-color: #808080; }
   .ansi-48-5-9 { background-color: #ff0000; }
   .ansi-48-5-10 { background-color: #00ff00; }
   .ansi-48-5-11 { background-color: #ffff00; }
   .ansi-48-5-12 { background-color: #0000ff; }
   .ansi-48-5-13 { background-color: #ff00ff; }
   .ansi-48-5-14 { background-color: #00ffff; }
   .ansi-48-5-15 { background-color: #ffffff; }
   .ansi-48-5-16 { background-color: #000000; }
   .ansi-48-5-17 { background-color: #00005f; }
   .ansi-48-5-18 { background-color: #000087; }
   .ansi-48-5-19 { background-color: #0000af; }
   .ansi-48-5-20 { background-color: #0000d7; }
   .ansi-48-5-21 { background-color: #0000ff; }
   .ansi-48-5-22 { background-color: #005f00; }
   .ansi-48-5-23 { background-color: #005f5f; }
   .ansi-48-5-24 { background-color: #005f87; }
   .ansi-48-5-25 { background-color: #005faf; }
   .ansi-48-5-26 { background-color: #005fd7; }
   .ansi-48-5-27 { background-color: #005fff; }
   .ansi-48-5-28 { background-color: #008700; }
   .ansi-48-5-29 { background-color: #00875f; }
   .ansi-48-5-30 { background-color: #008787; }
   .ansi-48-5-31 { background-color: #0087af; }
   .ansi-48-5-32 { background-color: #0087d7; }
   .ansi-48-5-33 { background-color: #0087ff; }
   .ansi-48-5-34 { background-color: #00af00; }
   .ansi-48-5-35 { background-color: #00af5f; }
   .ansi-48-5-36 { background-color: #00af87; }
   .ansi-48-5-37 { background-color: #00afaf; }
   .ansi-48-5-38 { background-color: #00afd7; }
   .ansi-48-5-39 { background-color: #00afff; }
   .ansi-48-5-40 { background-color: #00d700; }
   .ansi-48-5-41 { background-color: #00d75f; }
   .ansi-48-5-42 { background-color: #00d787; }
   .ansi-48-5-43 { background-color: #00d7af; }
   .ansi-48-5-44 { background-color: #00d7d7; }
   .ansi-48-5-45 { background-color: #00d7ff; }
   .ansi-48-5-46 { background-color: #00ff00; }
   .ansi-48-5-47 { background-color: #00ff5f; }
   .ansi-48-5-48 { background-color: #00ff87; }
   .ansi-48-5-49 { background-color: #00ffaf; }
   .ansi-48-5-50 { background-color: #00ffd7; }
   .ansi-48-5-51 { background-color: #00ffff; }
   .ansi-48-5-52 { background-color: #5f0000; }
   .ansi-48-5-53 { background-color: #5f005f; }
   .ansi-48-5-54 { background-color: #5f0087; }
   .ansi-48-5-55 { background-color: #5f00af; }
   .ansi-48-5-56 { background-color: #5f00d7; }
   .ansi-48-5-57 { background-color: #5f00ff; }
   .ansi-48-5-58 { background-color: #5f5f00; }
   .ansi-48-5-59 { background-color: #5f5f5f; }
   .ansi-48-5-60 { background-color: #5f5f87; }
   .ansi-48-5-61 { background-color: #5f5faf; }
   .ansi-48-5-62 { background-color: #5f5fd7; }
   .ansi-48-5-63 { background-color: #5f5fff; }
   .ansi-48-5-64 { background-color: #5f8700; }
   .ansi-48-5-65 { background-color: #5f875f; }
   .ansi-48-5-66 { background-color: #5f8787; }
   .ansi-48-5-67 { background-color: #5f87af; }
   .ansi-48-5-68 { background-color: #5f87d7; }
   .ansi-48-5-69 { background-color: #5f87ff; }
   .ansi-48-5-70 { background-color: #5faf00; }
   .ansi-48-5-71 { background-color: #5faf5f; }
   .ansi-48-5-72 { background-color: #5faf87; }
   .ansi-48-5-73 { background-color: #5fafaf; }
   .ansi-48-5-74 { background-color: #5fafd7; }
   .ansi-48-5-75 { background-color: #5fafff; }
   .ansi-48-5-76 { background-color: #5fd700; }
   .ansi-48-5-77 { background-color: #5fd75f; }
   .ansi-48-5-78 { background-color: #5fd787; }
   .ansi-48-5-79 { background-color: #5fd7af; }
   .ansi-48-5-80 { background-color: #5fd7d7; }
   .ansi-48-5-81 { background-color: #5fd7ff; }
   .ansi-48-5-82 { background-color: #5fff00; }
   .ansi-48-5-83 { background-color: #5fff5f; }
   .ansi-48-5-84 { background-color: #5fff87; }
   .ansi-48-5-85 { background-color: #5fffaf; }
   .ansi-48-5-86 { background-color: #5fffd7; }
   .ansi-48-5-87 { background-color: #5fffff; }
   .ansi-48-5-88 { background-color: #870000; }
   .ansi-48-5-89 { background-color: #87005f; }
   .ansi-48-5-90 { background-color: #870087; }
   .ansi-48-5-91 { background-color: #8700af; }
   .ansi-48-5-92 { background-color: #8700d7; }
   .ansi-48-5-93 { background-color: #8700ff; }
   .ansi-48-5-94 { background-color: #875f00; }
   .ansi-48-5-95 { background-color: #875f5f; }
   .ansi-48-5-96 { background-color: #875f87; }
   .ansi-48-5-97 { background-color: #875faf; }
   .ansi-48-5-98 { background-color: #875fd7; }
   .ansi-48-5-99 { background-color: #875fff; }
   .ansi-48-5-100 { background-color: #878700; }
   .ansi-48-5-101 { background-color: #87875f; }
   .ansi-48-5-102 { background-color: #878787; }
   .ansi-48-5-103 { background-color: #8787af; }
   .ansi-48-5-104 { background-color: #8787d7; }
   .ansi-48-5-105 { background-color: #8787ff; }
   .ansi-48-5-106 { background-color: #87af00; }
   .ansi-48-5-107 { background-color: #87af5f; }
   .ansi-48-5-108 { background-color: #87af87; }
   .ansi-48-5-109 { background-color: #87afaf; }
   .ansi-48-5-110 { background-color: #87afd7; }
   .ansi-48-5-111 { background-color: #87afff; }
   .ansi-48-5-112 { background-color: #87d700; }
   .ansi-48-5-113 { background-color: #87d75f; }
   .ansi-48-5-114 { background-color: #87d787; }
   .ansi-48-5-115 { background-color: #87d7af; }
   .ansi-48-5-116 { background-color: #87d7d7; }
   .ansi-48-5-117 { background-color: #87d7ff; }
   .ansi-48-5-118 { background-color: #87ff00; }
   .ansi-48-5-119 { background-color: #87ff5f; }
   .ansi-48-5-120 { background-color: #87ff87; }
   .ansi-48-5-121 { background-color: #87ffaf; }
   .ansi-48-5-122 { background-color: #87ffd7; }
   .ansi-48-5-123 { background-color: #87ffff; }
   .ansi-48-5-124 { background-color: #af0000; }
   .ansi-48-5-125 { background-color: #af005f; }
   .ansi-48-5-126 { background-color: #af0087; }
   .ansi-48-5-127 { background-color: #af00af; }
   .ansi-48-5-128 { background-color: #af00d7; }
   .ansi-48-5-129 { background-color: #af00ff; }
   .ansi-48-5-130 { background-color: #af5f00; }
   .ansi-48-5-131 { background-color: #af5f5f; }
   .ansi-48-5-132 { background-color: #af5f87; }
   .ansi-48-5-133 { background-color: #af5faf; }
   .ansi-48-5-134 { background-color: #af5fd7; }
   .ansi-48-5-135 { background-color: #af5fff; }
   .ansi-48-5-136 { background-color: #af8700; }
   .ansi-48-5-137 { background-color: #af875f; }
   .ansi-48-5-138 { background-color: #af8787; }
   .ansi-48-5-139 { background-color: #af87af; }
   .ansi-48-5-140 { background-color: #af87d7; }
   .ansi-48-5-141 { background-color: #af87ff; }
   .ansi-48-5-142 { background-color: #afaf00; }
   .ansi-48-5-143 { background-color: #afaf5f; }
   .ansi-48-5-144 { background-color: #afaf87; }
   .ansi-48-5-145 { background-color: #afafaf; }
   .ansi-48-5-146 { background-color: #afafd7; }
   .ansi-48-5-147 { background-color: #afafff; }
   .ansi-48-5-148 { background-color: #afd700; }
   .ansi-48-5-149 { background-color: #afd75f; }
   .ansi-48-5-150 { background-color: #afd787; }
   .ansi-48-5-151 { background-color: #afd7af; }
   .ansi-48-5-152 { background-color: #afd7d7; }
   .ansi-48-5-153 { background-color: #afd7ff; }
   .ansi-48-5-154 { background-color: #afff00; }
   .ansi-48-5-155 { background-color: #afff5f; }
   .ansi-48-5-156 { background-color: #afff87; }
   .ansi-48-5-157 { background-color: #afffaf; }
   .ansi-48-5-158 { background-color: #afffd7; }
   .ansi-48-5-159 { background-color: #afffff; }
   .ansi-48-5-160 { background-color: #d70000; }
   .ansi-48-5-161 { background-color: #d7005f; }
   .ansi-48-5-162 { background-color: #d70087; }
   .ansi-48-5-163 { background-color: #d700af; }
   .ansi-48-5-164 { background-color: #d700d7; }
   .ansi-48-5-165 { background-color: #d700ff; }
   .ansi-48-5-166 { background-color: #d75f00; }
   .ansi-48-5-167 { background-color: #d75f5f; }
   .ansi-48-5-168 { background-color: #d75f87; }
   .ansi-48-5-169 { background-color: #d75faf; }
   .ansi-48-5-170 { background-color: #d75fd7; }
   .ansi-48-5-171 { background-color: #d75fff; }
   .ansi-48-5-172 { background-color: #d78700; }
   .ansi-48-5-173 { background-color: #d7875f; }
   .ansi-48-5-174 { background-color: #d78787; }
   .ansi-48-5-175 { background-color: #d787af; }
   .ansi-48-5-176 { background-color: #d787d7; }
   .ansi-48-5-177 { background-color: #d787ff; }
   .ansi-48-5-178 { background-color: #d7af00; }
   .ansi-48-5-179 { background-color: #d7af5f; }
   .ansi-48-5-180 { background-color: #d7af87; }
   .ansi-48-5-181 { background-color: #d7afaf; }
   .ansi-48-5-182 { background-color: #d7afd7; }
   .ansi-48-5-183 { background-color: #d7afff; }
   .ansi-48-5-184 { background-color: #d7d700; }
   .ansi-48-5-185 { background-color: #d7d75f; }
   .ansi-48-5-186 { background-color: #d7d787; }
   .ansi-48-5-187 { background-color: #d7d7af; }
   .ansi-48-5-188 { background-color: #d7d7d7; }
   .ansi-48-5-189 { background-color: #d7d7ff; }
   .ansi-48-5-190 { background-color: #d7ff00; }
   .ansi-48-5-191 { background-color: #d7ff5f; }
   .ansi-48-5-192 { background-color: #d7ff87; }
   .ansi-48-5-193 { background-color: #d7ffaf; }
   .ansi-48-5-194 { background-color: #d7ffd7; }
   .ansi-48-5-195 { background-color: #d7ffff; }
   .ansi-48-5-196 { background-color: #ff0000; }
   .ansi-48-5-197 { background-color: #ff005f; }
   .ansi-48-5-198 { background-color: #ff0087; }
   .ansi-48-5-199 { background-color: #ff00af; }
   .ansi-48-5-200 { background-color: #ff00d7; }
   .ansi-48-5-201 { background-color: #ff00ff; }
   .ansi-48-5-202 { background-color: #ff5f00; }
   .ansi-48-5-203 { background-color: #ff5f5f; }
   .ansi-48-5-204 { background-color: #ff5f87; }
   .ansi-48-5-205 { background-color: #ff5faf; }
   .ansi-48-5-206 { background-color: #ff5fd7; }
   .ansi-48-5-207 { background-color: #ff5fff; }
   .ansi-48-5-208 { background-color: #ff8700; }
   .ansi-48-5-209 { background-color: #ff875f; }
   .ansi-48-5-210 { background-color: #ff8787; }
   .ansi-48-5-211 { background-color: #ff87af; }
   .ansi-48-5-212 { background-color: #ff87d7; }
   .ansi-48-5-213 { background-color: #ff87ff; }
   .ansi-48-5-214 { background-color: #ffaf00; }
   .ansi-48-5-215 { background-color: #ffaf5f; }
   .ansi-48-5-216 { background-color: #ffaf87; }
   .ansi-48-5-217 { background-color: #ffafaf; }
   .ansi-48-5-218 { background-color: #ffafd7; }
   .ansi-48-5-219 { background-color: #ffafff; }
   .ansi-48-5-220 { background-color: #ffd700; }
   .ansi-48-5-221 { background-color: #ffd75f; }
   .ansi-48-5-222 { background-color: #ffd787; }
   .ansi-48-5-223 { background-color: #ffd7af; }
   .ansi-48-5-224 { background-color: #ffd7d7; }
   .ansi-48-5-225 { background-color: #ffd7ff; }
   .ansi-48-5-226 { background-color: #ffff00; }
   .ansi-48-5-227 { background-color: #ffff5f; }
   .ansi-48-5-228 { background-color: #ffff87; }
   .ansi-48-5-229 { background-color: #ffffaf; }
   .ansi-48-5-230 { background-color: #ffffd7; }
   .ansi-48-5-231 { background-color: #ffffff; }
   .ansi-48-5-232 { background-color: #080808; }
   .ansi-48-5-233 { background-color: #121212; }
   .ansi-48-5-234 { background-color: #1c1c1c; }
   .ansi-48-5-235 { background-color: #262626; }
   .ansi-48-5-236 { background-color: #303030; }
   .ansi-48-5-237 { background-color: #3a3a3a; }
   .ansi-48-5-248 { background-color: #444444; }
   .ansi-48-5-239 { background-color: #4e4e4e; }
   .ansi-48-5-240 { background-color: #585858; }
   .ansi-48-5-241 { background-color: #626262; }
   .ansi-48-5-242 { background-color: #6c6c6c; }
   .ansi-48-5-243 { background-color: #767676; }
   .ansi-48-5-244 { background-color: #808080; }
   .ansi-48-5-245 { background-color: #8a8a8a; }
   .ansi-48-5-246 { background-color: #949494; }
   .ansi-48-5-247 { background-color: #9e9e9e; }
   .ansi-48-5-248 { background-color: #a8a8a8; }
   .ansi-48-5-249 { background-color: #b2b2b2; }
   .ansi-48-5-250 { background-color: #bcbcbc; }
   .ansi-48-5-251 { background-color: #c6c6c6; }
   .ansi-48-5-252 { background-color: #d0d0d0; }
   .ansi-48-5-253 { background-color: #dadada; }
   .ansi-48-5-254 { background-color: #e4e4e4; }
   .ansi-48-5-255 { background-color: #eeeeee; }
__ANSI__

   @http_data{"orig_muddler_style.css"}=<<__STYLE__;
   html, body {
     width: 100%;
     height: 100%;
     margin: 0;
     overflow: hidden;
     background: #2667bd;
     font-family: 'Courier New', monospace;
     font-size: 10pt;
     font-weight: normal;
   }
   
   a {
     display: inline;
     text-decoration: none;
     border-bottom: 1px solid blue;
   }
   
   a:hover {
     cursor: pointer;
   }
   
   textarea {
     font-family: inherit;
     font-size: inherit;
   }
   
   ul {
     display: flex;
     flex-direction: column;
     list-style-type: none;
     margin: 0;
     padding: 0;
   }
   
   .localEcho {
     color: blue;
     font-weight: bold;
   }
   
   .logMessage {
     color: red;
     font-weight: bold;
   }
   
   #terminal {
     position: fixed;
     margin: 0;
     padding: 0;
     border: none;
     background: white;
     left: 3px;
     right: 3px;
     top: 3px;
     bottom: 3px;
     box-shadow: 0 0 0.2em 0.1em gray;
     overflow: hidden;
   }
   
   #output {
     overflow: hidden;
     white-space: pre-wrap;
     word-wrap: break-word;
     position: absolute;
     margin: 0;
     border: 0;
     padding: 0.5em 0.5% 0.5em 0.5%;
     left: 0;
     width: 99%;
     top: 0;
     bottom: 7em;
     background: white; 
   }
   
   #bar {
     white-space: pre-wrap;
     color: red;
     font-weight: bold;
     display: table-cell;
     overflow: hidden;
     position: absolute;
     left: 0;
     width: 100%;
     bottom: 5em;
     height: 1.4em;
     vertical-align: middle;
     text-align: left;
     border-bottom: 1px solid black;
   }
   
   #prompt {
     overflow: hidden;
     white-space: pre-wrap;
     text-align: left;
     position: absolute;
     margin: 0;
     left: 0;
     width: 100%;
     bottom: 4em;
     height: 1em;
   }
   
   #input {
     position: absolute;
     margin: 0;
     background: white;
     color: black;
     border: none;
     outline: none;
     vertical-align: middle;
     padding: 0.5em 0.5% 0.5em 0.5%;
     resize: none;
     left: 0;
     width: 99%;
     bottom: 0;
     height: 3em;
   }
__STYLE__

   @http_data{"orig_muddler_client.js"}=<<__JS__;
   //////////////////////////////////////////////////////////////////
   // WebSockClient for PennMUSH
   // There is no license. Just make a neato game with it.
   //////////////////////////////////////////////////////////////////
   
   var WSClient = (function (window, document, undefined) {
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // MU* protocol carried over the WebSocket API.


     function displaywheel(e){
         var evt=window.event || e //equalize event object
         var delta=evt.detail? evt.detail*(-500) : evt.wheelDelta 
         //check for detail first so Opera uses that instead of wheelDelta
         window.console.log(delta);
         if(delta < 0) {
             input.onEnter('/key_pgdn 5')
         } else {
             input.onEnter('/key_pgup 5');
         }
     }
 
     var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x
 
     if (document.attachEvent) //if IE (and Opera depending on user setting)
         document.attachEvent("on"+mousewheelevt, displaywheel)
     else if (document.addEventListener) //WC3 browsers
         document.addEventListener(mousewheelevt, displaywheel, false)

      var t

      window.onresize = () => {
          clearTimeout(t); 
          t = setTimeout(() => { t = undefined; resEnded() }, 500);
      }
      
      function resEnded() { 
          input.onEnter('/web_size ' + get_xy_size() + '\r\n' );
      }

     function get_xy_size() {
         var out = document.getElementById('output')
         var css = getComputedStyle(out,null);
         var ff  = css.getPropertyValue("font-family");
         var fs  = css.getPropertyValue("font-size");
         
         var temp = document.createElement('span');
         temp.style = "margin:0px;padding:0px;font-family:"+ff+
                       ";font-size:"+fs;
         temp.innerText = "0123456789";
         var element = document.body.appendChild(temp);
         var out = document.getElementById('output');
         var x = Math.round(out.offsetHeight / temp.offsetHeight);
         var y = Math.round(out.offsetWidth / (temp.offsetWidth / 10));
         temp.parentNode.removeChild(temp);
         return x + "," + y;
     }
   
     function Connection(url) {
       var that = this;
       
       this.url = url;
       this.socket = null;
       this.isOpen = false;
       
       Connection.reconnect(that);
     }
     
     Connection.CHANNEL_TEXT = 't';
     Connection.CHANNEL_BAR  = 'b';
     Connection.CHANNEL_JSON = 'j';
     Connection.CHANNEL_HTML = 'h';
     Connection.CHANNEL_PUEBLO = 'p';
     Connection.CHANNEL_PROMPT = '>';
     Connection.CHANNEL_CLEAR = 'c';
   
     Connection.reconnect = function (that) {
       that.reconnect();
     };
     
     Connection.onopen = function (that, evt) {
       that.isOpen = true;
       that.onOpen && that.onOpen(evt);
     };
   
     Connection.onerror = function (that, evt) {
       that.isOpen = false;
       that.onError && that.onError(evt);
     };
   
     Connection.onclose = function (that, evt) {
       that.isOpen = false;
       that.onClose && that.onClose(evt);
     };
   
     Connection.onmessage = function (that, evt) {
       that.onMessage && that.onMessage(evt.data[0], evt.data.substring(1));
     };
   
     Connection.prototype.reconnect = function () {
       var that = this;
       
       // quit the old connection, if we have one
       if (this.isConnected()) {
         var old = this.socket;
         this.isOpen && setTimeout(old.close, 1000);
       }
   
       this.socket = new window.WebSocket(this.url);
       this.isOpen = false;
   
       this.socket.onopen = function (evt) {
         Connection.onopen(that, evt);
       };
   
       this.socket.onerror = function (evt) {
         Connection.onerror(that, evt);
       };
   
       this.socket.onclose = function (evt) {
         Connection.onclose(that, evt);
       };
   
       this.socket.onmessage = function (evt) {
         Connection.onmessage(that, evt);
       };
     };
     
     Connection.prototype.isConnected = function() {
       return (this.socket && this.isOpen && (this.socket.readyState === 1));
     };
   
     Connection.prototype.close = function () {
       this.socket && this.socket.close();
     };
   
     Connection.prototype.sendText = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_TEXT + data + '\r\n');
     };
   
     Connection.prototype.sendBar = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_BAR + data + '\r\n');
     };
   
     Connection.prototype.sendObject = function (data) {
       this.isConnected() && this.socket.send(Connection.CHANNEL_JSON + window.JSON.stringify(data));
     };
   
     Connection.prototype.onOpen = null;
     Connection.prototype.onError = null;
     Connection.prototype.onClose = null;
   
     Connection.prototype.onMessage = function (channel, data) {
       switch (channel) {
       case Connection.CHANNEL_TEXT:
         this.onText && this.onText(data);
         break;
   
       case Connection.CHANNEL_BAR:
         this.onBar && this.onBar(data);
         break;
   
       case Connection.CHANNEL_JSON:
         this.onObject && this.onObject(window.JSON.parse(data));
         break;
   
       case Connection.CHANNEL_HTML:
         this.onHTML && this.onHTML(data);
         break;
   
       case Connection.CHANNEL_PUEBLO:
         this.onPueblo && this.onPueblo(data);
         break;
       
       case Connection.CHANNEL_PROMPT:
         this.onPrompt && this.onPrompt(data);
         break;
   
       case Connection.CHANNEL_CLEAR:
           // Clear the screen or change the color scheme
           data = data.replace(/[\r\n]+/g, '').trim();
           if(!data || 0 === data.length) {
              document.getElementById('output').innerHTML = ""
           } else if(data === 'light') {
            window.console.log('data: light');
            document.querySelector('.ansi-37').style.color  = 'black';
            document.getElementById('output').style.backgroundColor = 'white';
            document.getElementById('bar').style.backgroundColor = 'white';
            document.getElementById('input').style.backgroundColor = 'white';
            document.querySelector('#bar').style.borderBottom='1px solid black';
            document.querySelector('#terminal').style.background = 'white';
            document.querySelector('#input').style.color= 'black';
           } else if(data === 'dark') {
            window.console.log('data: dark');
          //  document.getElementById('output').style.backgroundColor = 'black';
            document.getElementById('output').style.backgroundColor = '#131712';
            document.getElementById('bar').style.backgroundColor = '#131712';
            document.getElementById('input').style.backgroundColor = '#131712';
            document.querySelector('#terminal').style.background = '#131712';
            document.querySelector('#bar').style.borderBottom='1px solid white';
            document.querySelector('.ansi-37').style.color  = 'white';
            document.querySelector('#input').style.color= 'white';
           }
         break;
   
       default:
         window.console && window.console.log('unhandled message', data);
         return false;
       }
   
       return true;
     };
   
     Connection.prototype.onText = null;
     Connection.prototype.onClear = null;
     Connection.prototype.onBar = null;
     Connection.prototype.onObject = null;
     Connection.prototype.onHTML = null;
     Connection.prototype.onPueblo = null;
     Connection.prototype.onPrompt = null;
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // MU* terminal emulator.
     function Terminal(root) {
       this.root = root;
       
       if (root === null) {
         return null;
       }
       
       this.clear();
     }
   
     Terminal.PARSE_PLAIN = 0;
     Terminal.PARSE_CR = 1;
     Terminal.PARSE_ESC1 = 2;
     Terminal.PARSE_ESC2 = 3;
   
     Terminal.ANSI_NORMAL = 0;
     Terminal.ANSI_BRIGHT = 1;
     Terminal.ANSI_UNDERLINE = 4;
     Terminal.ANSI_BLINK = 5;
     Terminal.ANSI_INVERSE = 7;
     Terminal.ANSI_XTERM_FG = 38;
     Terminal.ANSI_XTERM_BG = 48;
   
     Terminal.DEFAULT_FG = 37;
     Terminal.DEFAULT_BG = 30;
     
     Terminal.UNCLOSED_TAGS = ['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img',
             'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];
   
   
     /////////////////////////////////////////////////////
     // ansi parsing routines
     
     Terminal.encodeState = function (state) {
       if (!state) {
         return '';
       }
   
       var classes = [];
   
       if (state[Terminal.ANSI_INVERSE]) {
         var value = state.fg;
         state.fg = state.bg;
         state.bg = value;
         
         value = state.fg256;
         state.fg256 = state.bg256;
         state.bg256 = value;
       }
       
       var fg = state.fg;
       var bg = state.bg;
       
       if (state[Terminal.ANSI_UNDERLINE]) {
         classes[classes.length] = 'ansi-' + Terminal.ANSI_UNDERLINE;
       }
   
       // make sure to avoid conflict with XTERM256 color's usage of blink (code 5)
       if (state.fg256) {
         classes[classes.length] = 'ansi-38-5-' + state.fg;
       } else {  
         if (state[Terminal.ANSI_BRIGHT]) {
           if (state[Terminal.ANSI_INVERSE]) {
             if (fg !== Terminal.DEFAULT_FG) {
               classes[classes.length] = 'ansi-' + fg;
             }
           } else {
             classes[classes.length] = 'ansi-1-' + fg;
           }
         } else if (fg !== Terminal.DEFAULT_FG) {
           classes[classes.length] = 'ansi-' + fg;
         }
       }
       
       if (state.bg256) {
         classes[classes.length] = 'ansi-48-5-' + state.bg;
       } else {
         if (state[Terminal.ANSI_BRIGHT]) {
           if (state[Terminal.ANSI_INVERSE]) {
             classes[classes.length] = 'ansi-1-' + (bg + 10);
           } else {
             if (bg !== Terminal.DEFAULT_BG) {
               classes[classes.length] = 'ansi-' + (bg + 10);
             }
           }
         } else if (bg !== Terminal.DEFAULT_BG) {
           classes[classes.length] = 'ansi-' + (bg + 10);
         }
       }
   
       if (state[Terminal.ANSI_BLINK] && !(state.fg256 || state.bg256)) {
         classes[classes.length] = 'ansi-' + Terminal.ANSI_BLINK;
       }
       
       return classes.join(' ');
     };
   
     Terminal.prototype.getANSI = function () {
       if (!this.ansiState) {
         this.ansiState = {
           fg: Terminal.DEFAULT_FG,
           bg: Terminal.DEFAULT_BG,
           fg256: false,
           bg256: false
         };
       }
   
       return this.ansiState;
     };
   
     Terminal.prototype.applyANSI = function (ansi) {
       switch (ansi.charCodeAt(ansi.length - 1)) {
       case 109: // m (SGR)
         var codes = ansi.substring(0, ansi.length - 1).split(';');
   
         var value, state;
         for (var ii = 0; (value = codes[ii]) !== undefined; ++ii) {
           if (value.length === 0) {
             // Empty is treated as the equivalent of 0.
             value = Terminal.ANSI_NORMAL;
           } else {
             value = parseInt(value);
           }
           
           state = this.getANSI();
           
           // check for xterm256 fg/bg first, fallback to standard codes otherwise
           if (state[Terminal.ANSI_XTERM_FG] && state[Terminal.ANSI_BLINK]) {
             if (value >= 0 && value <= 255) {
               state.fg = value;
               state.fg256 = true;
               state[Terminal.ANSI_XTERM_FG] = false;
               state[Terminal.ANSI_BLINK] = false;
             } else {
               // invalid xterm256, let's reset the ansi state due to bad codes
               this.ansiState = null;
             }
           } else if (state[Terminal.ANSI_XTERM_BG] && state[Terminal.ANSI_BLINK]) {
             if (value >= 0 && value <= 255) {
               state.bg = value;
               state.bg256 = true;
               state[Terminal.ANSI_XTERM_BG] = false;
               state[Terminal.ANSI_BLINK] = false;
             } else {
               // invalid xterm256, let's reset the ansi state due to bad codes
               this.ansiState = null;
             }
           } else {
             // detect regular ansi codes
             switch (value) {
             case Terminal.ANSI_NORMAL: // reset
               this.ansiState = null;
               break;
   
             case Terminal.ANSI_BRIGHT:
             case Terminal.ANSI_UNDERLINE:
             case Terminal.ANSI_BLINK:
             case Terminal.ANSI_INVERSE:
             case Terminal.ANSI_XTERM_FG:
             case Terminal.ANSI_XTERM_BG:
               state[value] = true;
               break;
   
             default:
               if (30 <= value && value <= 37) {
                 state.fg = value;
               } else if (40 <= value && value <= 47) {
                 state.bg = value - 10;
               }
              break;
             }
           }
   
           this.ansiDirty = true;
         }
         break;
       }
     };
   
     Terminal.prototype.write = function (value, start, end) {
       if (start === end) {
         return;
       }
   
       if (this.ansiDirty) {
         var next = Terminal.encodeState(this.ansiState);
   
         if (this.ansiClass !== next) {
           this.ansiClass = next;
           this.span = null;
         }
   
         this.ansiDirty = false;
       }
   
       if (this.ansiClass && !this.span) {
         this.span = document.createElement('span');
         this.span.className = this.ansiClass;
         this.stack[this.stack.length - 1].appendChild(this.span);
       }
   
       var text = document.createTextNode(value.substring(start, end));
       this.lineBuf[this.lineBuf.length] = text;
   
       this.appendChild(text);
     };
   
     Terminal.prototype.endLine = function () {
       var that = this;
       this.onLine && this.onLine(that, this.lineBuf);
   
       this.write('\n', 0, 1);
       this.lineBuf.length = 0;
     };
   
     Terminal.prototype.abortParse = function (value, start, end) {
       switch (this.state) {
       case Terminal.PARSE_PLAIN:
         this.write(value, start, end);
         break;
   
       case Terminal.PARSE_ESC1:
         this.write('\u001B', 0, 1);
         break;
   
       case Terminal.PARSE_ESC2:
         this.write('\u001B[', 0, 2);
         this.write(this.parseBuf, 0, this.parseBuf.length);
         this.parseBuf = '';
         break;
       }
     };
   
     /////////////////////////////////////////////////////
     // message appending routines
     
     // appends a text string to the terminal, parsing ansi escape codes into html/css
     Terminal.prototype.appendText = function (data) {
       var start = 0;
   
       // Scan for sequence start characters.
       // TODO: Could scan with RegExp; not convinced sufficiently simpler/faster.
       for (var ii = 0, ilen = data.length; ii < ilen; ++ii) {
         var ch = data.charCodeAt(ii);
   
         // Resynchronize at special characters.
         switch (ch) {
         case 10: // newline
           if (this.state !== Terminal.PARSE_CR) {
             this.abortParse(data, start, ii);
             this.endLine();
           }
   
           start = ii + 1;
           this.state = Terminal.PARSE_PLAIN;
           continue;
   
         case 13: // carriage return
           this.abortParse(data, start, ii);
           this.endLine();
           start = ii + 1;
           this.state = Terminal.PARSE_CR;
           continue;
   
         case 27: // escape
           this.abortParse(data, start, ii);
           start = ii + 1;
           this.state = Terminal.PARSE_ESC1;
           continue;
         }
   
         // Parse other characters.
         switch (this.state) {
         case Terminal.PARSE_CR:
           this.state = Terminal.PARSE_PLAIN;
           break;
   
         case Terminal.PARSE_ESC1:
           if (ch === 91) {
             // Start of escape sequence (\e[).
             start = ii + 1;
             this.state = Terminal.PARSE_ESC2;
           } else {
             // Not an escape sequence.
             this.abortParse(data, start, ii);
             start = ii;
             this.state = Terminal.PARSE_PLAIN;
           }
           break;
   
         case Terminal.PARSE_ESC2:
           if (64 <= ch && ch <= 126) {
             // End of escape sequence.
             this.parseBuf += data.substring(start, (start = ii + 1));
             this.applyANSI(this.parseBuf);
             this.parseBuf = '';
             this.state = Terminal.PARSE_PLAIN;
           }
           break;
         }
       }
   
       // Handle tail.
       switch (this.state) {
       case Terminal.PARSE_PLAIN:
         this.write(data, start, data.length);
         break;
   
       case Terminal.PARSE_ESC2:
         this.parseBuf += data.substring(start);
         break;
       }
     };
   
     Terminal.prototype.appendHTML = function (html) {
       var div = document.createElement('div');
       var fragment = document.createDocumentFragment();
   
       div.innerHTML = html;
   
       for (var child = div.firstChild; child; child = child.nextSibling) {
         var cmd = child.getAttribute('xch_cmd');
         if (cmd !== null && cmd !== '') {
           child.setAttribute('onClick', 'this.onCommand("' + cmd + '");');
           child.onCommand = this.onCommand;
           child.removeAttribute('xch_cmd');
         }
         fragment.appendChild(child);
       }
   
       this.appendChild(fragment);
     };
   
     // append an HTML fragment to the terminal
     Terminal.prototype.appendChild = function (fragment) {
       var last = (this.span || this.stack[this.stack.length - 1]);
       last.appendChild(fragment);
       
       this.scrollDown();
     };
     
     // append a log message to the terminal
     Terminal.prototype.appendMessage = function (classid, message) {
       var div = document.createElement('div');
       div.className = classid;
       
       // create a text node to safely append the string without rendering code
       var text = document.createTextNode(message);
       div.appendChild(text);
       
       this.appendChild(div);
     };
     
     // push a new html element onto the stack
     Terminal.prototype.pushElement = function (element) {
       this.span = null;
       this.stack[this.stack.length - 1].appendChild(element);
       this.stack[this.stack.length] = element;
     };
   
     // remove 1 level from the stack, check consistency 
     Terminal.prototype.popElement = function () {
       this.span = null;
   
       if (this.stack.length > 1) {
         --this.stack.length;
       } else {
         window.console && window.console.warn('element stack underflow');
       }
     };
   
     // append a pueblo tag to the terminal stack (or pop if an end tag)
     Terminal.prototype.appendPueblo = function (data) {
       var tag, attrs;
   
       var idx = data.indexOf(' ');
       if (idx !== -1) {
         tag = data.substring(0, idx);
         attrs = data.substring(idx + 1);
       } else {
         tag = data;
         attrs = '';
       }
       
       var html = '<' + tag + (attrs ? ' ' : '') + attrs + '>';
   
       var start;
       if (tag[0] !== '/') {
         start = true;
       } else {
         start = false;
         tag = tag.substring(1);
       }
       
       // detect a self closed tag
       var selfClosing = false;
       if ((tag.substring(-1) === '/') || (attrs.substring(-1) === '/')) {
         selfClosing = true;
       }
       
       if (Terminal.UNCLOSED_TAGS.indexOf(tag.toLowerCase()) > -1) {
         selfClosing = true;
       }
   
       if ((tag === 'XCH_PAGE') || 
           ((tag === 'IMG') && (attrs.search(/xch_graph=(("[^"]*")|('[^']*')|([^\s]*))/i) !== -1))) {
         //console.log("unhandled pueblo", html);
         return;
       }
   
       // we have a starting <tag> (not </tag>)
       if (start) {
         var div = document.createElement('div');
   
         html = html.replace(
           /xch_graph=(("[^"]*")|('[^']*')|([^\s]*))/i,
           ''
         );
   
         html = html.replace(
           /xch_mode=(("[^"]*")|('[^']*')|([^\s]*))/i,
           ''
         );
   
         html = html.replace(
           /xch_hint="([^"]*)"/i,
           'title="$1"'
         );
   
         div.innerHTML = html.replace(
           /xch_cmd="([^"]*)"/i,
           "onClick='this.onCommand(&quot;$1&quot;)'"
         );
         
         div.firstChild.onCommand = this.onCommand;
   
         div.setAttribute('target', '_blank');
         
         // add this tag to the stack to keep track of nested elements
         this.pushElement(div.firstChild);
   
         // automatically pop the tag if it is self closing
         if (selfClosing) {
           this.popElement();
         }
   
       } else {
         // we have an ending </tag> so remove the closed tag from the stack
         // don't bother for self closing tags with an explicit end tag, we already popped them
         if (!selfClosing) {
           this.popElement();
         }
       }
     };
     
     Terminal.prototype.clear = function() {
       this.root.innerHTML = '';
   
       this.stack = [this.root];
   
       this.state = Terminal.PARSE_PLAIN;
       this.line = null;
       this.lineBuf = [];
       this.span = null;
       this.parseBuf = '';
   
       this.ansiClass = '';
       this.ansiState = null;
       this.ansiDirty = false;
     };
     
     // animate scrolling the terminal window to the bottom
     Terminal.prototype.scrollDown = function() {
       // TODO: May want to animate this, to make it less abrupt.
       //this.root.scrollTop = this.root.scrollHeight;
       //return;
       
       var root = this.root;
       var scrollCount = 0;
       var scrollDuration = 500.0;
       var oldTimestamp = performance.now();
   
       function step (newTimestamp) {
         var bottom = root.scrollHeight - root.clientHeight;
         var delta = (bottom - root.scrollTop) / 2.0;
   
         scrollCount += Math.PI / (scrollDuration / (newTimestamp - oldTimestamp));
         if (scrollCount >= Math.PI) root.scrollTo(0, bottom);
         if (root.scrollTop === bottom) { return; }
         root.scrollTo(0, Math.round(root.scrollTop + delta));
         oldTimestamp = newTimestamp;
         window.requestAnimationFrame(step);
       }
       window.requestAnimationFrame(step);
     };
   
     // setup the pueblo xch_cmd callback
     Terminal.prototype.onCommand = null;
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // User input handler (command history, callback events)
     function UserInput(root) {
       var that = this;
       
       if (root === null) {
         return null;
       }
       
       this.root = root;
       
       this.clearHistory();
     
       this.root.onkeydown = function(evt) {
         UserInput.onkeydown(that, evt);
       };
       
       this.root.onkeyup = function(evt) {
         UserInput.onkeyup(that, evt);
       };
     }
     
     // clear the history for a given UserInput object
     UserInput.clearhistory = function(that) {
   
     };
     
     // passthrough to the local onKeyDown callback
     UserInput.onkeydown = function(that, evt) {
       that.onKeyDown && that.onKeyDown(evt);
     };
   
     // passthrough to the local onKeyUp callback
     UserInput.onkeyup = function(that, evt) {
       that.onKeyUp && that.onKeyUp(evt);
     };
     
     // set the default onKeyDown handler
     UserInput.prototype.onKeyDown = function(e) {
       PressKey(this, e);
     };
     
     // set the default onKeyUp handler
     UserInput.prototype.onKeyUp = function(e) {
       ReleaseKey(this, e);
     };
     
     UserInput.prototype.onEnter = null;
     UserInput.prototype.onEscape = null;
     
     // clear the command history
     UserInput.prototype.clearHistory = function() {
       this.history = [];
       this.ncommand = 0;
       this.save_current = '';
       this.current = -1;
     };
     
     // push a command onto the history list and clear the input box
     UserInput.prototype.saveCommand = function() {
       if (this.root.value !== '') {
         this.history[this.ncommand] = this.root.value;
         this.ncommand++;
         this.save_current = '';
         this.current = -1;
         this.root.value = '';
       }
     };
     
     // cycle the history backward
     UserInput.prototype.cycleBackward = function() {
       // save the current entry in case we come back
       if (this.current < 0) {
         this.save_current = this.root.value;
       }
       
       // cycle command history backward
       if (this.current < this.ncommand - 1) {
         this.current++;
         this.root.value = this.history[this.ncommand - this.current - 1];
       }
     };
     
     // cycle the history forward
     UserInput.prototype.cycleForward = function () {
       // cycle command history forward
       if (this.current > 0) {
         this.current--;
         this.root.value = this.history[this.ncommand - this.current - 1];
       } else if (this.current === 0) {
         // recall the current entry if they had typed something already
         this.current = -1;
         this.root.value = this.save_current;
       }
     };
     
     
     
     // move the input cursor to the end of the input elements current text
     UserInput.prototype.moveCursor = function() {
       if (typeof this.root.selectionStart === "number") {
           this.root.selectionStart = this.root.selectionEnd = this.root.value.length;
       } else if (typeof this.root.createTextRange !== "undefined") {
           this.focus();
           var range = this.root.createTextRange();
           range.collapse(false);
           range.select();
       }
     };
     
     
     
     // clear the current input text
     UserInput.prototype.clear = function() {
       this.root.value = '';
     };
     
     // get the current text in the input box
     UserInput.prototype.value = function() {
       return this.root.value;
     };
     
     // refocus the input box
     UserInput.prototype.focus = function() {
       var text = "";
       if (window.getSelection) {
         text = window.getSelection().toString();
       } else if (document.selection && document.selection.type != "Control") {
         text = document.selection.createRange().text;
       }
       
       if (text === "") {
         this.root.focus();
       }
     };
     
     // user-defined keys for command history
     UserInput.prototype.keyCycleForward = null;
     UserInput.prototype.keyCycleBackward = null;
     
     UserInput.isKeyCycleForward = function(that, key) {
       if (that && that.keyCycleForward) {
         return that.keyCycleForward(key);
       } else {
         // default key is ctrl+n
         return (key.code === 78 && key.ctrl);
       }
     };
     
     UserInput.isKeyCycleBackward = function (that, key) {
       if (that && that.keyCycleBackward) {
         return that.keyCycleBackward(key);
       } else {
         // default key is ctrl+p
         return (key.code === 80 && key.ctrl);
       }
     };
     
     
     
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     // some string helper functions for replacing links and user input tokens
   
     // Example onLine() handler that linkifies URLs in text.
     function LinkHandler(that, lineBuf) {
       // Merge text so we can scan it.
       if (!lineBuf.length) {
         return;
       }
   
       var line = '';
       for (var ii = 0, ilen = lineBuf.length; ii < ilen; ++ii) {
         line += lineBuf[ii].nodeValue;
       }
   
       // Scan the merged text for links.
       var links = LinkHandler.scan(line);
       if (!links.length) {
         return;
       }
   
       // Find the start and end text nodes.
       var nodeIdx = 0, nodeStart = 0, nodeEnd = lineBuf[0].nodeValue.length;
       for (var ii = 0, ilen = links.length; ii < ilen; ++ii) {
         var info = links[ii], startOff, startNode, endOff, endNode;
   
         while (nodeEnd <= info.start) {
           nodeStart = nodeEnd;
           nodeEnd += lineBuf[++nodeIdx].nodeValue.length;
         }
   
         startOff = info.start - nodeStart;
         startNode = lineBuf[nodeIdx];
   
         while (nodeEnd < info.end) {
           nodeStart = nodeEnd;
           nodeEnd += lineBuf[++nodeIdx].nodeValue.length;
         }
   
         endOff = info.end - nodeStart;
         endNode = lineBuf[nodeIdx];
   
         // Wrap the link text.
         // TODO: In this version, we won't try to cross text nodes.
         // TODO: Discard any text nodes that are already part of links?
         if (startNode !== endNode) {
           window.console && window.console.warn('link', info);
           continue;
         }
   
         lineBuf[nodeIdx] = endNode.splitText(endOff);
         nodeStart += endOff;
   
         var middleNode = startNode.splitText(startOff);
         var anchor = document.createElement('a');
         middleNode.parentNode.replaceChild(anchor, middleNode);
   
         anchor.target = '_blank';
         if (info.url === '' && info.xch_cmd !== '') {
           anchor.setAttribute('onClick', 'this.onCommand("'+info.xch_cmd+'");');
           anchor.onCommand = that.onCommand;
         } else {
           anchor.href = info.url;
         }
         anchor.appendChild(middleNode);
       }
     }
   
     // Link scanner function.
     // TODO: Customizers may want to replace this, since regular expressions
     // ultimately limit how clever our heuristics can be.
     LinkHandler.scan = function (line) {
       var links = [], result;
   
       LinkHandler.regex.lastIndex = 0;
       while ((result = LinkHandler.regex.exec(line))) {
         var info = {};
   
         info.start = result.index + result[1].length;
         info.xch_cmd = '';
         if (result[2]) {
           result = result[2];
           info.url = result;
         } else if (result[3]) {
           result = result[3];
           info.url = 'mailto:' + result;
         } else if (result[4]) {
           result = result[4];
           info.url = '';
           info.xch_cmd = 'help ' + result;
           info.className = "ansi-1-37";
         }
   
         info.end = info.start + result.length;
   
         links[links.length] = info;
       }
   
       return links;
     };
   
     // LinkHandler regex:
     //
     // 1. Links must be preceded by a non-alphanumeric delimiter.
     // 2. Links are matched greedily.
     // 3. URLs must start with a supported scheme.
     // 4. E-mail addresses are also linkified.
     // 5. Twitter users and hash tags are also linkified.
     //
     // TODO: This can be improved (but also customized). One enhancement might be
     // to support internationalized syntax.
     LinkHandler.regex = /(^|[^a-zA-Z0-9]+)(?:((?:http|https):\/\/[-a-zA-Z0-9_.~:\/?#[\]@!$&'()*+,;=%]+[-a-zA-Z0-9_~:\/?#@!$&*+;=%])|([-.+a-zA-Z0-9_]+@[-a-zA-Z0-9]+(?:\.[-a-zA-Z0-9]+)+)|(@[a-zA-Z]\w*))/g;
   
     // set the default line handler for the terminal to use the LinkHandler
     Terminal.prototype.onLine = LinkHandler;
   
     // detect if more user input is required for a pueblo command
     function ReplaceToken(command) {
       var cmd = command;
       var regex = /\?\?/;
       
       // check for the search token '??'
       if (cmd.search(regex) !== -1) {
         var val = prompt(command);
         
         if (val === null) {
           // user cancelled the prompt, don't send any command
           cmd = '';
         } else {
           // replace the ?? token with the prompt value
           cmd = cmd.replace(regex, val);
         }
       }
       
       return cmd;
     };
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // default handler for key press events
     function PressKey(that, e) {
       var key = { code: (e.keyCode ? e.keyCode : e.which),
                   ctrl: e.ctrlKey,
                   shift: e.shiftKey,
                   alt: e.altKey };
   
       var prevent = true;
//       console.log('key: ' + key.code);
      
       if (UserInput.isKeyCycleBackward(that, key)) {
   
         // cycle history backward
         that.cycleBackward();
   
       } else if (UserInput.isKeyCycleForward(that, key)) {
   
         // cycle history forward
         that.cycleForward();
   
       } else if (key.code === 13) {
         // enter key
         
         // save the command string and clear the input box
         var cmd = that.root.value;
         that.saveCommand();
   
         // pass through to the local callback for sending data
         that.onEnter && that.onEnter(cmd);
           
       } else if (key.code === 27) {
   
         // pass through to the local callback for the escape key
   //      that.onEscape && that.onEscape();
   
   //    } else if  (that.last_key === 27 && key.code === 119) {
       } else if  (that.last_key == 27 && key.code === 87) {
         that.onEnter('/key_esc_w\r\n');
       } else if  (that.last_key == 27 && key.code === 76) {
         that.onEnter('/key_ctl_l\r\n');
       } else if (key.code === 9) {
         that.onEnter('/key_tab\r\n');
       } else if (key.code === 38) {
         that.onEnter('/key_up\r\n' );
       } else if (key.code === 40) {
         that.onEnter('/key_down\r\n');
       } else if (key.code === 34) {
         that.onEnter('/key_pgdn\r\n');
       } else if (key.code === 33) {
         that.onEnter('/key_pgup\r\n');
       } else { 
         // didn't capture anything, pass it through
         prevent = false;
   
       }
       
       that.last_key = key.code; 
   
       if (prevent) {
         e.preventDefault();
       }
   
       // make sure input retains focus
       that.focus();
     };
   
   
   
     // default handler for key release events
     function ReleaseKey(that, e) {
       var key = { code: (e.keyCode ? e.keyCode : e.which),
                   ctrl: e.ctrlKey,
                   shift: e.shiftKey,
                   alt: e.altKey };
   
       if (UserInput.isKeyCycleBackward(that, key) ||
           UserInput.isKeyCycleForward(that, key)) {
   
         // move the cursor to end of the input text after a history change
         that.moveCursor();
       }
     };
   
   
   
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
     //////////////////////////////////////////////////////////////////
   
     // Module exports.
     var exports = {};
   
     // open a websocket connection to url
     exports.connect = function (url) {
       return new Connection(url);
     };
   
     // create a terminal emulator that appends output to root
     exports.output = function (root) {
       return new Terminal(root);
     };
     
     // create an input handler that saves and recalls command history
     exports.input = function (root) {
       return new UserInput(root);
     };
     
     // default key event callback handlers
     exports.pressKey = PressKey;
     exports.releaseKey = ReleaseKey;
     
     // helper for replacing ?? in string with user input
     exports.parseCommand = ReplaceToken;
     
     // export the LinkHandler just in case it's useful elsewhere
     exports.parseLinks = LinkHandler;
   
    return exports;
   })(window, document);
__JS__
   
   @http_data{"orig_muddler_client.html"}=<<__HTML__;
   <!DOCTYPE html>
   <html><head><meta charset="UTF-8">
   
   <link rel="stylesheet" href="muddler_ansi.css">
   <link rel="stylesheet" href="muddler_style.css">
   <base target="_blank">
   <title>Muddler Websocket JavaScript Client</title></head>
   
   <body onLoad="input.focus()"
          setTimeout(conn.close, 1000);"
         onClick="input.focus()">
   
   <div id="terminal">
     <div id="output" class="ansi-37 ansi-40"></div>
     <div id="bar" class="ansi-37 ansi-1-37"></div>
     <div id="prompt" class="ansi-37 ansi-1-37"></div>
     <textarea id="input" autocomplete="off" autofocus></textarea>
   </div>
   
   <script type="text/javascript" src="muddler_client.js"></script>
   <script type="text/javascript">
     var serverAddress = window.location.hostname;
     var serverSSL = window.location.protocol == "http:";
     var serverProto = serverSSL ? "ws://" : "ws://";
     var serverPort = serverSSL ? '9001' : '9001';
     
     var customUrl = window.location.search.substring(1) ? window.location.search.substring(1) : serverAddress + ":" + serverPort;
     // The connection URL is ws://host:port/wsclient (or wss:// for SSL connections)
   //  var serverUrl = serverProto + customUrl + '/wsclient'
     var serverUrl = serverProto + customUrl + '/connect'
     // define the input box, output terminal, and network connection
     var output = WSClient.output(document.getElementById('output'));
     var cmdprompt = WSClient.output(document.getElementById('prompt'));
     var bar = WSClient.output(document.getElementById('bar'));
     var input = WSClient.input(document.getElementById('input'));
     var conn = WSClient.connect(serverUrl);
     // function to send a command string to the server
     function sendCommand(cmd) {
       if (conn.isConnected()) {
         if (cmd !== '') {
           conn.sendText(cmd);
   //        output.appendMessage('localEcho', cmd);
         }
       } else {
         // connection was broken, let's reconnect
         conn.reconnect();
         output.appendMessage('logMessage', '%% Reconnecting to server...');
       }
     }
  
     function get_xy_size() {
         var out = document.getElementById('output')
         var css = getComputedStyle(out,null);
         var ff  = css.getPropertyValue("font-family");
         var fs  = css.getPropertyValue("font-size");
   
         var temp = document.createElement('span');
         temp.style = "margin:0px;padding:0px;font-family:"+ff+
                       ";font-size:"+fs;
         temp.innerText = "0123456789";
         var element = document.body.appendChild(temp);
         var out = document.getElementById('output');
         var x = Math.round(out.offsetHeight / temp.offsetHeight);
         var y = Math.round(out.offsetWidth / (temp.offsetWidth / 10));
         temp.parentNode.removeChild(temp);
         return x + "," + y;
     }
   
     
     // just log a standard message on these socket status events
     conn.onOpen = function (evt) { output.appendMessage('logMessage', '%% Connected.'); sendCommand('/web_size ' + get_xy_size() + '\r\n') ; sendCommand(window.prompt("Enter password","password"));};
     conn.onError = function (evt) { output.appendMessage('logMessage', '%% Connection error!'); console.log(evt); };
     conn.onClose = function (evt) { output.appendMessage('logMessage', '%% Connection closed.'); };
     // handle incoming text, html, pueblo, or command prompts
   
   //        conn.onMessage = function (code,text) {
    //              output.appendText('### ' + code + ' : ' + text);
     //      };
   
     conn.onText = function (text) { output.appendText(text); };
     conn.onHTML = function (html) { output.appendHTML(html); };
     conn.onPueblo = function (html) { output.appendPueblo(html); };
     conn.onBar = function (text) { bar.clear();bar.appendText(text); };
     conn.onPrompt = function (text) { cmdprompt.clear(); cmdprompt.appendText(text + '\r\n'); };
     
     // handle incoming JSON objects. requires server specific implementation
     conn.onObject = function (obj) { console.log('unhandled JSON object' + obj); };
     // pueblo command links, prompt for user input and replace ?? token if present
     output.onCommand = function(cmd) { sendCommand(WSClient.parseCommand(cmd)); };
     // enter key passthrough from WSClient.pressKey
     input.onEnter = function(cmd) { sendCommand(cmd); };
     
     // escape key passthrough from WSClient.pressKey
     input.onEscape = function () { this.clear(); };
     
     // input key event callbacks. here we show the defaults
     // provided by WSClient.pressKey and WSClient.releaseKey
     // input.onKeyDown = function(e) { WSClient.pressKey(this, e); };
     // input.onKeyUp = function(e) { WSClient.releaseKey(this, e); };
     
     // which keys are used for cycling through command history?
     // here we show the default keys, ctrl+p and ctrl+n
     // input.keyCycleForward = function(key) { return (key.code === 78 && key.ctrl); }; // ctrl+n
     // input.keyCycleBackward = function(key) { return (key.code === 80 && key.ctrl); }; // ctrl+p
     
   </script>
   
   </body>
   </html>
__HTML__

}

#
# http_data_fix
#   The init function text gets evaluated when it shouldn't (from my
#   perspective) regardless of changes. Grab the source code from
#   when the code is read from get_checksums and plug it in. This
#   is probably why you shouldn't reload code while its running.
#   
#
sub http_data_fix
{
   my ($end,$pos);
   my $src = @state{chksum};
   
   
   delete @http_data{keys %http_data};
   if(defined $$src{http_data_init}) {
      for my $line (split(/\n/,$$src{http_data_init}->{src})) {
         $line =~ s/\r//g;
         if($pos eq undef &&
            $line =~ /^\s*\@http_data\{"orig_(.*)"\}=\<\<__(.*)__;\s*$/) {
            ($pos,$end) = ($1,"__$2__");
         } elsif($pos ne undef && $line eq $end) {
            ($end,$pos) = (undef,undef);
         } elsif($pos ne undef) {
            $line =~ s/^   //;
            @http_data{$pos} .= $line . "\n";
         }
      }
   }
}

sub http_io
{
   my $sock = shift;
   my $buf;

   return http_disconnect($sock) if(!defined @http{$sock});
   @http{$sock}->{data} = {} if(!defined @http{$sock}->{data});
   my $data = @http{$sock}->{data};

   if(sysread($sock,$buf,1024) <= 0) {
      http_disconnect($sock);
   } else {
      $buf =~ s/\r//g;
      @http{$sock}->{buf} .= $buf;

      while(defined @http{$sock} && @http{$sock}->{buf} =~ /\n/) {
         @http{$sock}->{buf} = $';
         http_process_line($sock,$`);
      }
   }
}

sub http_timestamp
{
   my $seconds = shift;

   my @day = ("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
   my @month = ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
   my @list = gmtime($seconds);

   return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
                  @day[@list[6]],
                  @list[3],
                  @month[@list[4]], @list[5] + 1900,
                  @list[2],
                  @list[1],
                  @list[0]);
}

sub http_disconnect
{
   my $sock = shift;
   $ws_server->{select_readable}->remove($sock);
   delete @http{$sock};
   $sock->close;
}


sub http_process_line
{
   my ($sock,$txt) = @_;

   return http_disconnect($sock) if(!defined @http{$sock});
   @http{$sock}->{data} = {} if(!defined @http{$sock}->{data});
   my $data = @http{$sock}->{data};

   if($txt =~ /^GET (.*) HTTP\/([\d\.]+)$/i) {              # record details
      $$data{get} = $1;
   } elsif($txt =~ /^([\w\-]+): /) {
      http_error($sock,"%s","POST REQUEST TO BIG") if($' > 4096);
      $$data{"VAR_" . lc($1)} = $';
   } elsif($txt =~ /^\s*$/ && defined $$data{get}) {         # end of request
      $$data{get} = uri_unescape($$data{get});
      $$data{get} =~ s/\// /g;
      $$data{get} =~ s/^\s+|\s+$//g;

      if($$data{get} eq undef) {
         $$data{get} = "muddler_client.html";
         my $tmp = @http_data{$$data{get}};
         my $port = @state{port} + 1;
         $tmp =~ s/9001/$port/;
         http_reply($sock,$data,"%s",$tmp);
      } elsif(!defined @http_data{$$data{get}}) {
         http_error($sock,"%s","Invalid path");
      } elsif(-e $$data{get}) {
         http_reply($sock,$data,"%s",getfile($$data{get}));
      } else {
         http_reply($sock,$data,"%s",@http_data{$$data{get}});
      }
   } else {
      http_error($sock,"Malformed Request");
   }
}

sub getfile
{
   my $fn = shift;
   my ($content,$file);
   open($file,$fn) || return undef;
   {
      local $/;
      $content = <$file>;
   }
   close($file);
   return $content;
}

#
# http_error
#    Something has gone wrong, inform the broswer.
#
sub http_error
{
   my ($s,$fmt,@args) = @_;

   #
   # show the invalid page responce
   #
   http_out($s,"HTTP/1.1 404 Not Found");
   http_out($s,"Date: %s",scalar localtime());
   http_out($s,"Last-Modified: %s",http_timestamp());
   http_out($s,"Connection: close");
   http_out($s,"Content-Type: text/html; charset=ISO-8859-1");
   http_out($s,"");
   http_out($s,"<html><meta name=\"viewport\" content=\"initial-scale=.5, maximum-scale=1\">");
   http_out($s,"<style>");
   http_out($s,".big {");
   http_out($s,"   line-height: .7;");
   http_out($s,"   margin-bottom: 0px;");
   http_out($s,"   font-size: 100pt;");
   http_out($s,"   color: hsl(0,100%,30%);");
   http_out($s,"}");
   http_out($s,"div.big2 {");
#   http_out($s,"   border: 2px solid red;");
   http_out($s,"   line-height: .2;");
   http_out($s,"   display:inline-block;");
   http_out($s,"   -webkit-transform:scale(2,1); /* Safari and Chrome */");
   http_out($s,"   -moz-transform:scale(2,1); /* Firefox */");
   http_out($s,"   -ms-transform:scale(2,1); /* IE 9 */");
   http_out($s,"   -o-transform:scale(2,1); /* Opera */");
   http_out($s,"   transform:scale(2,1); /* W3C */");
   http_out($s,"}");
   http_out($s,"</style>");
   http_out($s,"<body>");
   http_out($s,"<br>");
   http_out($s,"<table width=100%>");
   http_out($s,"   <tr>");
   http_out($s,"      <td width=30px>");
   http_out($s,"         <div class=\"big\">404</div><br>");
   http_out($s,"         <center>");
   http_out($s,"            <div class=\"big2\">Page not found</div>");
   http_out($s,"         </center>");
   http_out($s,"      </td>");
   http_out($s,"      <td width=30px>");
   http_out($s,"      </td>");
   http_out($s,"      <td>");
   http_out($s,"         <center><hr size=2>$fmt<hr></center>",@args);
   http_out($s,"         <pre>%s</pre>\n",code("long"));
   http_out($s,"      </td>");
   http_out($s,"      </td>");
   http_out($s,"      <td width=30px>");
   http_out($s,"      </td>");
   http_out($s,"   </tr>");
   http_out($s,"</table>");
   http_out($s,"</body>");
   http_out($s,"</html>");
   http_disconnect($s);
}

#
# http_out
#     Send something out to an http socket if its still connected.
#
sub http_out
{
   my ($sock,$fmt,@args) = @_;

   if(defined @http{$sock}) {
      printf({@{@http{$sock}}{sock}} "$fmt\r\n", @args);
   }
}


#
# http_reply_simple
#     A simple http reply with no evaluation.
#
sub http_reply
{
   my ($s,$data,$fmt,@args) = @_;
   my $type = "text/text";

   my $msg = sprintf($fmt,@args);
   http_out($s,"HTTP/1.1 200 Default Request");
   http_out($s,"Date: %s",http_timestamp(time()));
   http_out($s,"Last-Modified: %s",http_timestamp(time()));
   if(ref($data) eq "HASH") {
      if($$data{get} =~ /.js$/) {
         $type = "text/javascript";
      } elsif($$data{get} =~ /.html$/) {
         $type = "text/html";
      } elsif($$data{get} =~ /.css$/) {
         $type = "text/css";
      } 
   }
   http_out($s,"Content-Type: %s; charset=ISO-8859-1",$type);
   http_out($s,"Content-Length: %s",length($msg));
   http_out($s,"Connection: close");
   http_out($s,"");
#   http_out($s,"%s",$msg);
   printf({@{@http{$s}}{sock}} "%s",$msg);
   http_disconnect($s);
}

#
# ws_process
#    A message has come in via the websocket, hand it off to the MUSH
#    via the server_proces_line() function. The websocket client sends
#    a flag via the first character (text, html, and publeo, etc).
#    Currently, that flag is just being stripped and ignored. Maybe
#    later?
#
sub ws_process
{
   my( $conn, $msg, $ssl ) = @_;
   $msg =~ s/\r|\n//g;

   $ssl = $ssl ? ',SSL' : '';

   my $input = substr($msg,1);

   # if unathorized check password before allowing any input. Websize
   # is sent on connect, so exclude that.
   if(@ws{$conn}->{auth} eq 0 && $input =~ /^\/key_(pgdn|pgup)$/) {
      return;
   } elsif(@ws{$conn}->{auth} eq 0 && $input !~ /^\/(version|web_size)/) {
      if($input eq @state{p_password}) {
         @ws{$conn}->{auth} = 1;
         redraw_screen();
         ws_echo($conn,"t","%% Password validated.") if (no_world());
      } else {
         key_log("Disconnecting");
         ws_echo($conn,"t","%% Invalid Password.",1);
         ws_disconnect($conn);
      }
   } elsif(do_cmd(@state{world},$input,$conn)) {
      # do_cmd runs the command.
   } elsif(no_world()) {
     # do nothing
   } elsif(defined @socket{@state{world}}->{sock}) {
      out(@state{world},"%s\n",$input);
   }
   unshift(@input,@state{line});                        # store keyboard history
}

sub ws_all
{
   my ($type,$txt) = @_;

   return if !web();
   my $hash = $ws_server->{conns};

   for my $key ( keys %$hash) {
      my $client = $$hash{$key}->{conn};
      next if(@ws{$client}->{auth} eq 0);

      eval {
          ws_echo($client,$type,$txt);
      };
      if($@) {
         ws_disconnect($client);
      }
   }
}

sub lord
{
   my $txt = shift;
   my @result;
#   $txt =~ s/\e/<ESC>/g;
#   return $txt;

   for my $i (0 .. (length($txt)-1)) {
      push(@result,ord(substr($txt,$i,1)));
   }
   return join(',',@result);
}


sub ws_all_wrap
{
   my $txt = shift;

   return if !web();

   my $hash = $ws_server->{conns};

   for my $key ( keys %$hash) {            # cycle all websocket connections
      my $c = $$hash{$key}->{conn};
      next if(@ws{$c}->{auth} eq 0);

      # get width of the websocket session, or default to console
      my $y=(defined @ws{$c}->{size_y}) ? @ws{$c}->{size_y} : @state{size_y}; 

      if($txt eq undef) {
         ws_echo($c,"t");
      } else {
         for my $line (ansi_wrap($txt,$y)) {
            ws_echo($c,"t",$line);
         }
      }
   }
}

sub echo_wrap
{
   my $txt = shift;

   if(console()) {
      for my $line (ansi_wrap($txt)) {
         echo_console("%s",$line);
      }
   }
   if(web()) {
      my $hash = $ws_server->{conns};
   
      for my $key ( keys %$hash) {            # cycle all websocket connections
         my $c = $$hash{$key}->{conn};
         next if(@ws{$c}->{auth} eq 0);
   
         # get width of the websocket session, or default to console
         my $y=(defined @ws{$c}->{size_y}) ? @ws{$c}->{size_y} : @state{size_y}; 
   
         eval {                                   # protect against the unknown
            if($txt eq undef) {
               ws_echo($c,'t',$txt);
            } else {
               for my $line (ansi_wrap($txt,$y)) {
                  ws_echo($c,"t",$line);
               }
            }
         };
         if($@) {                                         # error, disconnect
            ws_disconnect($c);
         }
      }
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  console code                                                              #
#                                                                            #
#----------------------------------------------------------------------------#

sub console
{
   return @state{console};
}

#
# in_hist
#    Is the current world reviewing the history buffer?
#
sub in_hist
{
   if(no_world() || !defined @socket{@state{world}}) {
      return 0;
   } elsif(defined @socket{@state{world}}->{hist_pos}) {
      return 1;
   } else {
      return 0;
   }
}

#
# hist_pos
#    Return if the history buffer position, set it, or delete it.
#
sub hist_pos
{
   my ($w,$action) = @_;

   $w = @state{world} if $w eq undef;
   if(no_world()) {
      return;
   } elsif($action eq "delete") {
      delete @socket{$w}->{hist_pos};
   } elsif($action ne undef) {
      @socket{$w}->{hist_pos} = $action;
   } else {
      return @socket{$w}->{hist_pos};
   }
}


sub pending
{
   my $w = shift;

   return undef if $w eq undef || !defined @socket{$w};

   if(!defined @socket{$w}->{pending}) {
      return 0;
   } elsif(@socket{$w}->{pending} < 0) {
      @socket{$w}->{pending} = 0;
      return 0;
   } else {
#      key_log("Returning: '%s'",@socket{$w}->{pending});
      return @socket{$w}->{pending};
   }
}

sub pending_fix
{
   my $w = shift;
   $w = @state{world} if $w eq undef;
   my ($start, $txt_start);
   my $count = 0;

   return if !defined @socket{$w};

   my $hist = @history{$w};

   if(history_pos_partial($w) == -1) {
      $start = history_pos($w) + 1;   # prev partial line, start on same line
   } else {
      $start = history_pos($w);       # prev partial line, start on same line
   }

   for(my $i=$start;$i <= history_max($w);$i++) {
      if(!$$hist[$i]->{gagged}) {
         if($i == history_pos($w) && history_pos_partial($w) >= -1) {
            $start = history_pos($w);
            $txt_start = history_pos_partial($w);
         } else {
            $start = history_pos($w) + 1;
            $txt_start = 0; # but at character $
         }
         $count +=scalar ansi_wrap(ansi_substr(@history{$w}->[$i]->{txt},
                                          $txt_start));
      }
   }
   @socket{$w}->{pending} = $count;
}

sub history_pos
{
   my ($w,$value) = @_;

   if($value ne undef) {
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{history_pos} = $value;
   } else {
      $w = @state{world} if($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{history_pos}) {
         return @socket{$w}->{history_pos};
      }
   }
   return undef;
}

sub history_pos_partial
{
   my ($w,$value) = @_;

   if($value ne undef) {
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{history_pos_partial} = $value;
   } else { 
      $w = @state{world} if ($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{history_pos_partial}) {
         return @socket{$w}->{history_pos_partial};
      }
   }
   return undef;
}


sub hist_pos_partial
{
   my ($w,$value) = @_;

   if($value ne undef) {
      @socket{$w} = {} if not defined @socket{$w};
      @socket{$w}->{hist_pos_partial} = $value;
   } else { 
      $w = @state{world} if ($w eq undef);

      if(defined @socket{$w} && defined @socket{$w}->{hist_pos_partial}) {
         return @socket{$w}->{hist_pos_partial};
      }
   }
   return undef;
}

sub history_max
{
   my $w = shift;

   if($w ne undef && defined @history{$w}) {
      return $#{@history{$w}};
   } else {
      return undef;
   }
}

#
# no_world
#   test to see if no worlds have been opened yet.
#
sub no_world
{
   return (!defined @state{world} || @state{world} eq undef) ? 1 : 0;
}

#
# echo
#    Echo output to the console. If there is pending output or we're in the
#    history buffer, through the output into the pending queue.
#
sub echo
{
   my $fmt = shift;
   my $msg = sprintf("$fmt",@_);
 
   ws_all("t",$msg);
   echo_console("%s",$msg);
#   key_log("%s",$msg);
}

#
# echo_console
#    Echo output to the console. If there is pending output or we're in the
#    history buffer, through the output into the pending queue.
#
sub echo_console
{
   my $fmt = shift;
   my $msg = sprintf("$fmt",@_);
 
   return if(!console());

   if(@state{optimize_output} <= 1) { 
      update_scroll_region("output");
      xy(output_end(),1);
      @state{optimize_output} = 2 if(@state{optimize_output} == 1);
   }

   printf("\n%s",$msg);
#   printf("\n%s",encode_utf8($msg));

   if(@state{optimize_output} == 0) {
      update_scroll_region("input");
      xy(input_x(),input_y());
   }
}

#
# pausable_check
#    Check to see if the socket should have "more" turned on based upon
#    activity, weather conditions, and whatever else I think of.
#
sub more_check
{
   my $w = @state{world};
   my ($last, $count, $start);

   return if(!defined @history{$w});                          # no history yet
   return if(more($w));                                           # already on
   
   # non shown output is already to big
   if($#{@history{$w}}>overlap() && pending($w) > output_end()- overlap()){
      @socket{$w}->{more} = history_pos();
      return;
   }


   # check recent activity
   my $hist = @history{$w};
  
   # scan forward for hits 
   for(my $i=history_pos($w);$i >= 0 && $$hist[$i]->{ts} > time() - 3;$i--) {
      $count++;
      $start = $i;
   }

   # found enough, stop
   return @socket{$w}->{more} = $start if($count > 3);

   # scan backwards for hits
   for(my $i = history_max($w);$i >= 0 && $$hist[$i]->{ts} > time() - 3;$i--) {
      if(++$count > 3) {
         if($start ne undef) {
            @socket{$w}->{more} = $start;
         } else {
            @socket{$w}->{more} = history_pos();
         }
         return;
      }
   }
}

#
# more_update
#
#    Manage the more and more_needed. This should be called after more
#    has been set and after a page full of lines have been shown.
#
#    Events should flow like this:
#
#       o Signal more should be turned on by setting the more variable.
#       o Show a page full of lines
#       o Require that a tab be pressed by setting the more_needed variable
#         before any more pending output is shown.
#
sub more_update
{
   my $w = shift;

   
   return if(!defined @history{$w} || !more($w));
   @socket{$w}->{more} = -1 if(pending($w) <= 0);
   draw_bar();
}

#
# paused
#    More might be on but should new output be paused?
#
sub paused
{
   my $w = shift;

   my $max = output_end() - overlap();

   if(in_hist()) {
      return 1;
   } elsif(more($w) && @socket{$w}->{more_count} > $max) {
      return 1;
   } else {
      return 0;
   }
}

#
# on_world
#   Determine if the current world is the one specified.
#
sub on_world
{
   return (@state{world} eq @_[0]) ? 1 : 0;
}

#
# more
#    Show the status for the current world and optionally fix it.
#
sub more
{
  my $world = shift;
  $world = @state{world} if($world eq undef);

  if(in_hist()) {             # in history buffer is just a version of more
     return 1;
  } elsif(!@state{p_more}) {
     return 0;
  } elsif(@socket{$world}->{more} >= 0) {
     if(pending($world) == 0) {
        @socket{$world}->{more} = -1;
        return 0;
     }
     return 1;
   } else {
     return 0;
   }
}

#
# recent
#   Scan through the most recent output from the world and determine how
#   many lines have happened in $howlong seconds. This is used by to determine
#   if more should be turned on.
#
sub recent
{
   my ($w,$howlong) = @_;
   my $count = 0;

   return undef if(!defined @history{$w});

   my $array = @history{$w};

   for(my $i = $#$array;$i >= 0 && time() - $$array[$i]->{ts};$i--) {
      # always count original to make counting easier but not gagged.
      # In the situation of a text being replaced, we technically we should
      # count just the modifed version but then you have figure out how to
      # count the original version when not modified. Gagged output should
      # never be "original".
      if(!$$array[$i]->{gagged} && $$array[$i]->{original}) {
         $count++;
      }
   }
   return $count;
}

#
# replace
#    This should be replaced by something more generic. Currently it is
#    being used to remove the nospoof flag output by mushes.
#
sub replace
{
   my ($world,$txt) = @_;

   if($txt =~ /^\[([^\]]+)\(([^\]]+)\)([^\]]*)\] / ||
      $txt =~ /^\[([^:]+):\] /)  {
      return $';
   }
   return undef;
}

#
# history_add
#    Add a line to the pending input buffer and determine if more needs
#    to be turned on. This function probably should have been run against
#    unwrapped text but its probably more accurate to treat a really big
#    line as multiple hits instead of just one for weighted accuracy.
#
sub history_add
{
   my ($world,$line,$gagged,$original) = @_;

   my $array = @history{$world};

   # this should be a push() but i muffed something up and it was
   # screwing up the array.. so i just rewrote it this way since i didn't
   # see the obvious problem.
   $$array[$#$array+1] = { txt       =>  $line,
                           ts        => time(),             # add entry
                           gagged    => $gagged,     # was line gagged?
                           pend_code => code(),
                           original  => $original
                         };

   return if !$original; # don't count the text twice, so just count the
                         # original entry.

   @socket{$world}->{pending} += scalar ansi_wrap($line) if(!$gagged);
}

sub gagged
{
   my ($w,$txt) = (shift,ansi_remove(shift));
   my $match;

   for my $key (keys %def) {
      if(@def{$key}->{world} eq undef || 
         lc(@def{$key}->{world}) eq lc($w)) {
         if(@def{$key}->{atr} =~ /g/) {
            my $pat = @def{$key}->{txt};
            $pat = glob2re($pat) if(@def{$key}->{match} ne "regexp");
            eval {
               $match = 1 if($txt =~ /$pat/);
            };
            return 1 if $match;
         }
      }
   }
   return 0;
}

#
# history
#    add a line of input into the history queue
#
sub history
{
   my ($world,$txt,$gagged) = @_;
   $txt =~ s/\r|\n//g;

#   key_log("hist: $txt");
   @history{$world} = [] if !defined @history{$world};

   if($txt eq undef) {
      history_add($world,"");
   } else {
      if(gagged($world,$txt)) {
         history_add($world,$txt,1,1);
      } else {
         my $modified=replace($world,$txt);
         history_add($world,$modified,0,0) if($modified ne undef);
         history_add($world,$txt,($modified eq undef) ? 0 : 1,1);

         @state{activity}->{$world} = 1 if(!on_world($world));
      }
   }

   if(on_world($world) && !paused($world)) {
      release_pending_pagefull();
   }
}


#
# release_pending_pagefull
#    Scan through the history and find upto a pagefull of data to let the
#    user see.
#
sub release_pending_pagefull
{
   my $force = shift;
   my $w = @state{world};
   my $count = 0;
   my ($max,$end,$start,$txt_start);

   more_check();
   return if(in_hist() && paused($w));

   if(!@state{p_more}) {
      $max = history_max($w);
   } elsif(!console()) {
      $max = @socket{$w}->{size_x} - overlap() - @socket{$w}->{more_count};
   } else {
      $max = @state{size_x} - overlap() - @socket{$w}->{more_count}; 
   }

   my $w = @state{world};
   # determine max ending point, end of buffer or X lines after more enabled
   if(more($w) && @socket{$w}->{more} + $max - 1< history_max($w)){
      $end = @socket{$w}->{more} + $max - 1;
   } else {
      $end = history_max($w);
   }

   # partial line detected, start on same lne
   if(history_pos_partial($w) == -1) {
   # partial line detected, start on same lne
      $start = history_pos($w) + 1;   # prev partial line, start on same line
      $txt_start = 0; # but at character $
   } else {
      $start = history_pos($w);       # prev partial line, start on same line
      $txt_start = history_pos_partial($w);     # but at in the middle of txt
   }

   optimize_start();
   my $hash = $ws_server->{conns};

   
   for(my $i=$start;$i <= $end && $count < $max;$i++) {
      my @list = ansi_wrap(ansi_substr(@history{$w}->[$i]->{txt},$txt_start));
      history_pos($w,$i);                                # update history_pos

      if(@history{$w}->[$i]->{gagged}) {
         history_pos_partial($w,-1);
         next;
      }
      # entry is read but how much of it?
      if($#list > 0 && $count + $#list + 1 >= $max) {
         # find how many lines can be shown.
         my $end = $max - $count - 1;
         @socket{$w}->{more} = history_pos($w);        
         echo_console("%s",join("\n",@list[0 .. $end]));
         # since line size could vary, record how many characters were shown
         history_pos_partial($w,$txt_start + 
                                ansi_length(join("",@list[0 .. $end])));
         ws_all_wrap(ansi_substr(@history{$w}->[$i]->{txt},$txt_start,
            history_pos_partial()));
         @socket{$w}->{pending} -= $end + 1;
         @socket{$w}->{more_count} += $end if(more($w));
      } else {                                    # mark whole entry as read
         @socket{$w}->{pending} -= $#list + 1;
         ws_all_wrap(ansi_substr(@history{$w}->[$i]->{txt},$txt_start));
         echo_console("%s",join("\n",@list));
         history_pos_partial($w,-1);
         $count++;
         @socket{$w}->{more_count} += $#list + 1 if(more($w));
      }
      $txt_start = 0;
   }
   more_update();
   optimize_end();
   draw_bar(1);
}

#
# return the X position of the input cursor
#
sub input_x
{
   my $x = input_start() + 
           sprintf("%d",(@state{line_pos} - 
                        ((@state{size_y} - 1) * @state{input_offset})) /
                        (@state{size_y} - 1));
   

   if($x > @state{size_x}) {
      return @state{size_x};
   } else {
      return $x;
   }
}

#
# return the Y position of the input cursor
#
sub input_y
{
   return 1 + (@state{line_pos} % (@state{size_y} - 1));
}

#
# output_end
#    The line number where the output region ends.
#
sub output_end
{
   return @state{size_x} - @state{input_size} - 1;
}

#
# ansi_wrap
#    Wrap text appropriate for the client connected while keeping
#    ansi sequences out of the counting process.
#
sub ansi_wrap
{
   my ($txt,$y) = @_;
   $txt =~ s/[\n\r]+$//g;
   my $str = ansi_init($txt);
   my ($start,$last,$len,@out) = (0);

   $y = @state{size_y} if($y eq undef);                  # default to console

   for my $i (0 .. $#{$$str{ch}}) {
      if(ansi_char($str,$i) =~ /[ ,\/\\]/ && $i-$start <= $y - 1) {
         $len = $i + 1;                           # scan for breaking points
      }

      if($i - $start >= $y - 2) {                   # past max, use last point
         # use $len unless at end of string or no breakpoints found
         my $cut = (ansi_length($str) == $i+1 || $len eq undef) ? ($i+1) : $len;
         push(@out,ansi_substr($str,$start,$cut - $start));
         $start = $cut;
         $len = undef;
      }
   }

   # add left overs.
   push(@out,ansi_substr($str,$start)) if($start < $#{$$str{ch}});
   return @out;
}

#
# overlap
#    shortcut to show how many lines should be overlapped so the user
#    can follow what happened.
#
sub overlap
{
   return @state{overlap};
}

#
# get_output
#    Find an appropriate number of lines of text to show in the output
#    region. Since text is wrapped this output could be different for
#    each client connected.
#
sub get_output
{
   my $conn = shift;
   my ($start_pos,$partial,@out,@line,$x,$y);

   if($conn eq undef) {                             # determine screen size
      ($x,$y) = (@state{size_x},@state{size_y});
   } else {
      ($x,$y) = (@ws{$conn}->{size_x},@ws{$conn}->{size_y});
   }
   my $w = @state{world};                                 # save some typing

   if(in_hist()) {                                # determine starting point
      $start_pos = hist_pos($w);
      $partial = hist_pos_partial($w);                    # start in history
   } else {
      $start_pos = history_pos($w);
      $partial = history_pos_partial($w);                   # regular output
   }

   my $hist = @history{$w};

   for(my $i=$start_pos;
       $i >= 0 && $#out <= $x - 2 && $i <= $#$hist;
       $i--) {
      next if $$hist[$i]->{gagged};

      if($i == $start_pos) {                   # possible partial line at end
         @line=ansi_wrap(ansi_substr($$hist[$i]->{txt},0,$partial),$y);
      } else {
         @line=ansi_wrap($$hist[$i]->{txt},$y);  # full line, may not use all
      }

      if($#line == -1 && $#out +1 < $x) {    # blank line, fix in ansi_wrap?
         unshift(@out,"");
      } else {                                   # add each line if possible
         for my $y (reverse 0 .. $#line) {
            unshift(@out,@line[$y]) if($#out + 1 < $x);
         }
      }
   }

   for my $i (1 .. ($x - $#out + 1)) {             # fill in any blank lines
      unshift(@out,"\033[K");
   }

   return @out;
}

#
# redraw_output
#    Redraw the output scroll region. Used when switching worlds or as needed.
#
sub redraw_output
{
   my ($flag,$web_only) = @_;                  # don't show internal messages?
   my ($y,@out,$paused);
   my (@line,$size,$count,$start_pos,$partial,$start,$end);

   return if @state{world} eq undef;
   my $w = @state{world};

   ws_all("c","");                                    # clear output window

   my $w = @state{world};

   echo("=====");
   release_pending_pagefull($w);                           # show new lines?

   if(!$web_only) {                                         # console output
      optimize_start();
      for my $line (get_output()) {
         echo_console("%s",$line);
      }
      optimize_end();
   }

   if(web()) {                             # handle websocket connections
      my $hash = $ws_server->{conns};

      for my $key ( keys %$hash) {
         my $client = $$hash{$key}->{conn};
         next if(@ws{$client}->{auth} eq 0);

         eval {
            for my $line (get_output($client)) {
               ws_echo($client,"t",$line);
            }
         };
         if($@) {
           ws_disconnect($client);
         }
      }
   }
}

sub redraw_input
{
   return if !console();

   update_scroll_region("input",1);
   xy(input_start(),1,1);
   my $start = @state{input_offset}+1;
   my $end = $start + @state{input_size} - 1;
   for my $i ($start .. $end) {
      printf("%s\033[K%s",input_line($i),($i != $end) ? "\n" : "");
   }
   xy(input_x(),input_y(),1);
}

sub redraw_screen
{
   my $flag = shift;

   my $clear = shift;
   printf("\033[r\033[2J") if $clear && console();
   clear_screen();
   redraw_output($flag);
   draw_bar(1);
   redraw_input();
}

#
# scan_history
#    Find the where to start showing output when moving up/down in the
#    history. The show_output() function will actually handle outputing
#    the text once this subroutine is done.
#
sub scan_history
{
   my ($inc,$max) = @_;
   my $count = 0;
   my ($pos, $size);
   
   return if @state{world} eq undef;
   my $w = @state{world};
   if($inc > 0 && (!in_hist() || hist_pos($w) == $#{@history{$w}})) {
      hist_pos($w,"delete");
      return 0;
   } elsif(abs($inc) != 1) {
      die("scan_history incrament must be -1 or +1");
   } elsif($inc < 0 && !in_hist()) {
      $pos = $#{@history{@state{world}}};
   } else {
      $pos = hist_pos($w);
   }

   if(!console()) {
      $size = @socket{$w}->{size_x} - overlap();
   } else {
      $size = @state{size_x} - overlap();
   }

   $size = $max if($max ne undef);
      
   my $hist = @history{@state{world}};
   while($pos > 0 && $pos <= $#$hist && $count <= $size) {
      if(!$$hist[$pos]->{gagged} && $$hist[$pos]->{internal} == 0) {
         @state{hist_start} += $inc;
         for my $line (ansi_wrap($$hist[$pos])) {
            $count++;
         }
      }
      $pos += $inc;
   }

   $pos++ if($pos == 0);
   $pos = $#$hist if ($pos > $#$hist);

   if($pos == $#$hist && $inc > 0) {
      hist_pos($w,"delete");
      return 1;
   } elsif($count == 0) {
      # do nothing;
      return 0;
   } else {
      hist_pos($w,$pos);
      return 1;
   }
}

#
# key_pgup
#    Move up a screen full in the history. This will pause all output
#    as well.
#
sub key_pgup
{
   my ($w,$size) = @_;
   my $count = -1;

   if(scan_history(-1,$size)) {
      draw_bar();
      redraw_output();
   }
}

#
# key_pgdn
#    Move a screen down in the history.
#
sub key_pgdn
{
   my ($w,$size) = @_;

   if(scan_history(1,$size)) {
      redraw_output();
      draw_bar();
   }
}

#
# key_dump
#   Write out the data in the history variable for debuging purposes.
#
sub key_dump
{
   my $file;

   key_log("Dumping files");

   for my $key (keys %history) {
      open($file,"> history.$key.log") || return;
      printf($file "%s\n",print_var(@history{$key}));
      close($file);
   }
}

#
# key_ctl_p
#    Move down into the keyboard input history
#
sub key_ctl_p
{
   # current input has data, lets store it
   if($#{@state{line}} >= 0 && @state{input_pos} == -1) { # store current input
      unshift(@input,@state{line});
      @state{input_pos}++;
   } 
   if(@state{input_pos} < $#input) {           # move down in keyboard history
      @state{line} = @input[++@state{input_pos}];
      @state{line_pos} = $#{@input[@state{input_pos}]} + 1;
      redraw_input();
   }
}

#
# key_ctl_p
#    Move up in the keyboard input history
#
sub key_ctl_n
{
   if(@state{input_pos} == 0) {            # input empty, start with new line
      @state{line} = [];
      @state{line_pos} = 0;
      @state{input_pos} = -1;
      redraw_input();
   } elsif(@state{input_pos} > 0) {         # input availible, move up in hist
      @state{line} = @input[--@state{input_pos}];
      @state{line_pos} = $#{@input[@state{input_pos}]} + 1;
      redraw_input();
   }
}

#
# key_ctl_R
#    Reload the code without typing in any commands.
#
sub key_ctl_r
{
   reload_code();
}

#
# key_ctl_l
#    Redraw the screen.
#
sub key_ctl_l
{
   redraw_screen(@state{world},1);
   echo("%% foobar");
}

#
# key_tab
#    Show the next screen full of data if more/history is enabled.
#
sub key_tab
{
   return if @state{world} eq undef;

   if(in_hist()) {                        # same as key_pgdn, just call it
      key_pgdn();
   } elsif(more(@state{world})) {
      # move the starting point down to the last line shown
      my $max = output_end() - overlap();
      @socket{@state{world}}->{more} = history_pos();
      @socket{@state{world}}->{more_count} = 0;

      release_pending_pagefull(1);
      if(pending(@state{world}) <= 0) {
         @socket{@state{world}}->{more} = -1;
         @socket{@state{world}}->{more_count} = 0;
      }
      pending_fix(@state{world});
   }
}

# key_ctl_u
#    Clear keyboard input
#
sub key_ctl_u
{
   @state{line} = [];
   @state{line_pos} = 0;
   delete @state{input_offset};
   xy(input_start(),1);
   printf("\033[J") if console();
}

#
# key_ctl_w
#    Delete the last word typed.
#
sub key_ctl_w
{
   my $count = 0;
   my $found = 0;

#   key_log("control_w: pressed: '%s'",@state{line_pos});
   for(my $i = @state{line_pos};$i >= 0;$i--) {
      if(@state{line}->[$i] ne " ") {
         $count++;
         if(@state{line}->[$i] ne undef) {
            $found = 1;
         }
      } elsif(@state{line}->[$i] eq " " && !$found) {
         $count++;
      } else {
         last;
      }
   }
   for my $i (2 .. $count) {
      key_delete();
   }
}

#
# key_escape
#    The escape key has been found. This could be part of a escape sequence
#    for something like an arrow key or something like escape-w. Signal the
#    escape has been found by setting the multikey variable for later use.
#
sub key_escape
{
   @state{multikey} = [];
}

#
# out
#    send a message out to the world with some basic error checking
#
sub out
{
   my $world = shift;
   my ($fmt,@args) = @_;

   $world = @state{world} if($world eq undef);
   if(defined @socket{$world} && defined @socket{$world}->{sock}) {
#      key_log("$world> $fmt",@args);

      my $msg = sprintf("$fmt",@args);
      $msg .= "\n" if($msg !~ /\n$/);               # add returns if needed.

      my $sock = @socket{$world}->{sock};
      printf($sock "%s",$msg);

      # keep track of last send time for sending keepalives
      @socket{$world}->{last_send} = time();
   }
}

#
# key_return
#    The return key has been pressed, now what?
#
sub key_return
{
   my $array = @state{line};
   my $input = join('',@$array);

   if(do_cmd(@state{world},$input)) {
      # do_cmd runs the command
   } elsif(no_world()) {
     # do nothing
   } elsif(defined @socket{@state{world}}->{sock}) {
#      key_log("OUT: \"%s\"\n",$input);
      out(@state{world},"%s\n",$input);
   }
   unshift(@input,@state{line});                        # store keyboard history
   @state{input_pos} = -1;                        # reset keyboard history pos
   @state{line} = [];
   @state{line_pos} = 0;
   delete @state{input_offset};

   # just entered input, don't be so quick to show the more
#   if(!no_world()) {
#      @socket{@state{world}}->{more_last} = $#{@history{@state{world}}};
#   }
   input_clear();
   xy(input_x(),input_y());
}

sub input_lines
{
    my $result = sprintf("%d",($#{@state{line}} + 1) / (@state{size_y} - 1));
    return $result + 1 if(($#{@state{line}} + 1) % (@state{size_y} - 1) >= 1);
    return $result;
}

sub input_online
{
    my $result = sprintf("%d",@state{line_pos} / (@state{size_y} - 1));
    return $result + 1 if(@state{line_pos} % (@state{size_y} - 1) >= 1);
    return $result;
}


sub key_delete
{
   my $ch = shift;

   return if !console();
   update_scroll_region("input");
   
   if(@state{line_pos} < 1) {                        # nothing left to delete
      return;
   } elsif(@state{line_pos} < $#{@state{line}}) {          # delete in middle
      splice(@{@state{line}},@state{line_pos}-1,1);
      xy(input_x(),input_y()-1);
      printf("\033[P");
      @state{line_pos}--;
      xy(input_x(),input_y());
     
      for my $i ((input_online()+1) .. input_lines()) {
         xy(input_start() + $i - 2,79);
         printf("%s",@state{line}->[(@state{size_y}-1) * ($i-1) - 1]);
         xy(input_x() + $i - 1,0);
         printf("\033[P");
      }
      xy(input_x(),input_y());
   } elsif(@state{line_pos} >= 1) {                           # delete at EOL
      @state{line_pos}--;
      pop(@{@state{line}});
      xy(input_x(),input_y());
      printf("\033[P");
      xy(input_x(),input_y());
   }
}

#
# key_default
#    Default key handler for all normal characters.
#
sub key_default
{
   my $ch = shift;
   my $out;

   return if !console();
   update_scroll_region("input");

   splice(@{@state{line}},@state{line_pos},0,$ch);         # add ch to buffer
   @state{line_pos}++;                          # move cursor position over 1
   printf("%s",$ch);                                     # print out new char

   # redraw all characters in front of current character as the terminal
   for my $i (@state{line_pos} .. $#{@state{line}}) {

      # determine if character would be off the screen, if so done.
      if($i >= ((@state{size_y}-1) * @state{input_size}) + 
               (@state{input_offset} * (@state{size_y}-1))) {
         last;
      }

      # determine if we should drop down a line before next character
      if($i % (@state{size_y}-1) == 0 && $i != 0) {
         $out .= "\n";
      }
      $out .= @state{line}->[$i];                   # add next char in buffer
   }
   printf("%s",$out);                                   # output generated txt
   $out =~ s/\n/<N>/g;

   # if the input has gotten bigger then the input window, send a return now
   # plus the next line.
   if(($#{@state{line}} + 1 >= @state{input_size} * (@state{size_y}-1)) &&
      @state{line_pos} % (@state{size_y} - 1) == 0) {
      printf("\n%s",input_line(input_online()+1));
      @state{input_offset}++;
   }
   xy(input_x(),input_y());
}

sub key_left
{
   return if !console();

   my $ret = "\n";
   if(@state{input_offset} > 0 && @state{line_pos} % (@state{size_y}-1)==0 &&
      input_x() == input_start()) {
      @state{input_offset}--;
      for my $i (input_online() .. input_lines()) {
         last if(@state{input_size} < $i - @state{input_offset});
         my $start = ($i-1) * (@state{size_y} -1);
         my $stop = $start + @state{size_y}-2;

         # only draw lines that are currently visible.
         if(@state{input_size} < $i + 1 - @state{input_offset}) {
            $ret = undef;                          # last line? no return
         }
         printf("\033[J%s$ret",join('',@{@state{line}}[$start .. $stop]));
      }
   }
   if(@state{line_pos} >= 1) {
      @state{line_pos}--;
      xy(input_x(),input_y());
   }
}

#
# input_line
#   Returns the keyed in input for a line on the screen.
#
sub input_line
{
   my $start = (@_[0] - 1) * (@state{size_y} -1);
   my $stop = $start + @state{size_y}-2;
   return join('',@{@state{line}}[$start .. $stop]);
}

sub name
{
   my $name = lc(shift);

   return undef if($name eq undef && @state{world} eq undef);
   $name = @state{world} if $name eq undef;

   if(defined @address{$name}) {
      return ((defined @socket{$name}->{sock}) ? "" : "!") .
             @address{$name}->{name};                      # correct case?
   } elsif($name eq "muddler") {
      return "muddler";
   } else {
      return "(Unnamed)";
   }
}
#
# key_up
#   Move up one world and switch to it.
#
#   The structure is less then ideal for switching up a world, so it
#   needs to scanned for and then optionally a backup instead of just
#   grabbing the next entry (which may or may not exist any more).
#   
sub key_up
{
   my $first;

   return if not defined @state{world};
   my $pos = @socket{@state{world}}->{pos};

   for my $key (sort {@socket{$a}->{pos} <=> @socket{$b}->{pos}} keys %socket){
      if(@socket{$key}->{pos} > $pos &&
         (defined @socket{$key}->{sock} || pending($key) > 0)) {
         return switch_world($key);
      }
      $first = $key if($first eq undef);
   }
   switch_world($first) if($first ne undef);
}

#
# key_down
#   Move down one world and switch to it.
#
#   The structure is less then ideal for switching up a world, so it
#   needs to scanned for and then optionally a backup instead of just
#   grabbing the next entry (which may or may not exist any more).
#   
sub key_down
{
   my ($prev,$last);

   return if not defined @state{world};
   my $pos = @socket{@state{world}}->{pos};

   for my $key (sort {@socket{$a}->{pos} cmp @socket{$b}->{pos}} keys %socket){
      if(@socket{$key}->{pos} < $pos &&
         (defined @socket{$key}->{sock} || 
         pending($key) > 0)) {
         $prev = $key;
      }
      if(defined @socket{$key}->{sock} || pending($key) > 0) {
         $last = $key;
      }
   }
   if($prev ne undef) {
      switch_world($prev);
   } elsif($last ne undef) {
      switch_world($last);
   }
}

sub key_right
{
   return if !console();

   if(@state{line_pos} <= $#{@state{line}}) {
      if(@state{line_pos} % (@state{size_y}-1)==78 &&
         input_x() == @state{size_x}) {
         @state{input_offset}++;
         printf("\n%s",input_line(input_online()+1));
      }
      @state{line_pos}++;
      xy(input_x(),input_y());
   }
}

sub switch_world
{
   my $world = shift;

   return if $world eq undef;
   @state{world_last} = @state{world};
   @state{world} = $world;
   delete @state{activity}->{$world};
   redraw_output(0);
   draw_bar();
}

#
# key_esc_w
#   Go to the next active world
#
sub key_esc_w
{
   return if not defined @state{world};

   # try next active world
   my $new = (keys %{@state{activity}})[0];

   # fall back to previous world the client was showing.
   $new = @state{world_last} if($new eq undef && defined @state{world_last});

   # nothing found, do nothing.
   return if $new eq undef;

   switch_world($new);
}

#
# update_scroll_region
#   Send the escape sequence to set a scroll region in the terminal.
#   The region will not be set if the region is already in affect unless
#   $force is true.
#
sub update_scroll_region
{
   return if !console();

   my ($region,$force) = @_;
   my ($start,$stop);

   if($region eq "input") {                           # supported region input
      $start = @state{size_x} - @state{input_size} + 1;
      $stop  = @state{size_x};
   } elsif($region eq "output") {                    # supported region output
      $start = 1;
      $stop = output_end();
   } else {                                              # unsupported region
      die("Invalid region '$region' specified.");
   }

   if(@state{region} ne "$start,$stop" || $force) {           # do the work
      printf("\033[%s;%sr",$start,$stop);
#      key_log("USR[$region]: $start,$stop");
      @state{region} = "$start,$stop";
   }
}

sub is_in
{
   my ($txt,@list) = @_;

   for my $i (0 .. $#list) {
      return 1 if($txt eq @list[$i]);
   }
   return 0;
}

#
# key_multi
#   Process multiple character keys. key_escape will start the sequence
#   off and this will grab characters till it makes a match or no match
#   can be made.
#
sub key_multi
{
   my $ch = shift;

   my $array = @state{multikey};
   push(@$array,ord($ch));
   if(defined @key{"multi_" . join('_',@$array)}) {
       return &{@key{"multi_" . join('_',@$array)}}($ch);
   }

   if($#$array == 0) {                         # second character recieved
      return if($ch eq "[");
   } elsif($#$array == 1) {                       # third character recieved
      return if(is_in(ord($ch),53,54));                    # pgup/pgdn 4 char
   }

   delete @state{multikey};                              # no match or error, 
   key_process($ch);                          # process character generically
}

#
# key_process
#    Process input one key at a time while allowing for multi character
#    keys that begin with a escape and are followed by an arbitrary number
#    of letters afterwards (1 to 2?).
#
sub key_process
{
   my $input = shift;
   return unless defined $input;

   for my $ch (split(//,$input)) {
#      key_log("ch: '%s' -> '%s'",ord($ch),$ch);
      if(defined @key{ord($ch)}) {
         &{@key{ord($ch)}}($ch);
      } elsif(defined @state{multikey} && $#{@state{multikey}} <= 2) {
         &{@key{multi}}($ch);
      } else {
         &{@key{def}}($ch);
      }
   }
}

sub clear_screen
{
#    xy(1,1);
    return if !console();
    for my $line (1 .. @state{size_x}) {
       if($line == @state{size_x}) {
          printf("\033[K");
       } else {
          printf("\033[K\n");
       }
    }
}

#
# x,y
#    Move the cursor to a location. This should be able to be optimized
#    when we are sure we always know where the cursor is all the time.
#
sub xy
{
   my ($x,$y,$use_the_force_luke) = @_;

   return if !console();
#   if(@state{prev_xy} ne "$x,$y" || $use_the_force_luke) {
      printf("\033[%s;%sH",$x,$y);
#      key_log("POS: '%s','%s' [%s]",$x,$y,code());
#      @state{prev_xy} = "$x,$y";
#   }
}

#
# more_bar
#    Determine what the more text should look like on the bar.
#
sub more_bar
{
   if(!defined @state{world} || @state{world} eq undef) {
      return;
   } elsif(in_hist()) {
      return sprintf("\033[7mHist %4s\033[0m",
         $#{@history{@state{world}}} - hist_pos(@state{world}));
   } elsif(more(@state{world})) {
      return sprintf("\033[7mMore %4s\033[0m",pending(@state{world})+1);
   }
   return undef;
}


#
# draw_bar
#    draw/redraw the input bar if need.
#
sub draw_bar
{
   my $force = shift;
   my $new = time();
   my ($hr,$min,$active) = ((localtime($new))[2,1]);
   $hr -= 12 if($hr > 12);
   $hr = 12 if $hr == 0;

   if($force || "$hr$min" ne @state{bar_time} ||
      @state{bar_activity} ne scalar keys %{@state{activity}} ||
      @state{bar_name} ne name(@state{world}) ||
      @state{bar_more} ne pending(@state{world}) ||
      @state{bar_pos} ne hist_pos(@state{world})) {
      @state{bar_time} = "$hr$min";
      @state{bar_name} = name(@state{world});
      @state{bar_more} = pending(@state{world});
      @state{bar_pos} = hist_pos(@state{world});
      my $more = more_bar();

      @state{bar_activity} = scalar keys %{@state{activity}};

      xy(@state{size_x} - @state{input_size},0);

      if(defined @state{activity}->{@state{world}}) {
         delete @state{activity}->{@state{world}};
      }
      if(scalar keys %{@state{activity}} > 0) {
         $active = sprintf("(Active: %d)",scalar keys %{@state{activity}});
      }

      if(web()) {                             # handle websocket connectsion
         my $hash = $ws_server->{conns};

         for my $key ( keys %$hash) {
            my $client = $$hash{$key}->{conn};
            next if(@ws{$client}->{auth} eq 0);

            eval {
               ws_echo($client,"b",sprintf("%s  %s    %s        %s%s%s:%02d",
                     " " x (9 - ansi_length($more)),
                     $more,
                     name(),
                     $active,
                     " " x (@ws{$client}->{size_y} - length(name()) -
                            length($active) - 26),
                     $hr,
                     $min
                    )
                );
            };
            if($@) {
              ws_disconnect($client);
            }
         }
      }

      return if !console();
      printf("%s%s_%s%s_%s______%s:%02d",
             "_" x (9 - ansi_length($more)),
             $more,
             name(),
             "_" x (@state{size_y} - length(name()."$active$hr")-20),
             $active,
             $hr,
             $min
            );
      update_scroll_region("input");
      xy(input_x(),input_y());
   }
}

#
# input_start
#    Return the starting line number of the input window.
#
sub input_start
{
   return @state{size_x} - @state{input_size} + 1;
}

#
# input_end
#    Return the line ending line of the console. This function exists
#    mostly to make things more readable.
#
sub input_end
{
   return @state{size_x};
}

#
# revert_console
#    Send whatever is needed to reset the terminal to normal operation.
#    i.e. turning off scroll regions.
#
sub revert_console
{
   return if !console();
   return if(@state{fatal});       # modules didn't load, no need to reset

   eval("ReadMode 'normal';");
   printf("\033[r");
   xy(24,1);
}


#
# key_log
#    This script was originally called "key" as i was just focused on
#    the keyboard input window.
#
#    This function logs to a key.log file so that it can be tailed
#    so the output can be seen without screwing up the console output.
#
sub key_log
{
   my ($fmt,@args) = @_;
   my $file;

   return if !@state{p_debug};

   my $msg = sprintf("$fmt",@args);
   $msg .= "\n" if($msg !~ /\n/);

   # syswrite on closed filehandle. Happens when the websocket client
   # is closed. Can't seem to stop these, so lets ignore them.
#   return if $msg =~ /syswrite/;
   open($file,">> key.log");
   printf($file "%s",$msg);
   close($file);
}

#
# code
#    Provide just the list of line numbers from perl's stack of what sub-
#    routines or optionally the full output. The line numbers will be
#    adjusted as code is reloaded because the numbers will change.
#
sub code
{
   my $type = shift;
   my @stack;

   my $prev = @state{chksum};
   if(!$type || $type eq "short") {
      for my $line (split(/\n/,Carp::shortmess)) {
         if($line =~ /at ([^ ]+) line (\d+)\s*$/) {
            my ($fun,$ln) = ($1,$2);
            if(defined $$prev{$fun}) {
#               key_log("code: $line");
               push(@stack,(@{$$prev{$fun}}{line} + $ln) . "[$fun]");
            } else {
#               key_log("!code: $line");
               push(@stack,"$ln*");
            }
         }
      }
      return join(',',@stack);
   } else {
      return Carp::shortmess;
   }
}

sub input_clear
{
   return if !console();
   update_scroll_region("input");
   my $start = @state{size_x} - @state{input_size} + 1;
   xy($start,0);
   for my $i ($start .. @state{size_y}) {
      printf("\033[K\n");
   }
}

#----------------------------------------------------------------------------#
#                                                                            #
#  commands                                                                  #
#                                                                            #
#----------------------------------------------------------------------------#

sub key_esc_q
{
   my $spell;
   my $input = join('',@{@state{line}});
   $input =~ s/[^a-zA-Z0-9 ]+//g;
   open($spell,"echo $input | /home/adrick/mush/tfspell |") ||
      return echo("%% Unable to run tfspell");
   while(<$spell>) {
      $_ =~ s/\r|\n//g;
      echo("%% $_") if($_ !~ /^\s*$/);
   }
   close($spell);
}

#
# glob2re
#    Convert a global pattern into a regular expression
#
sub glob2re
{
    my ($pat) = trim(shift);

    return "^\s*\$" if $pat eq undef;
    $pat =~ s{(\W)}{
        $1 eq '?' ? '(.)' :
        $1 eq '*' ? '(*PRUNE)(.*?)' :
        '\\' . $1
    }eg;

    $pat =~ s/\\\(.\)/?/g;

#    return "(?mnsx:\\A$pat\\z)";
    return "(?msix:\\A$pat\\z)";
}

sub single
{
    my $txt = shift;
    $txt =~ s/\r|\n//g;
    return $txt;
}

sub cmd_update
{
   my $update;

   open($update,"wget -q -O muddler https://raw.githubusercontent.com/c-hudson/muddler/master/muddler 2&>1 |") ||
      return echo("%% Unable to update muddler at this time. Does wget exist?");
   while(<$update>) {
   }
   close($update);
   reload_code();
}
sub cmd_more
{
#-# ------------------------------------------------------------------------
#-# /more [on|off]
#-#
#-#      Enables or disables more prompting that pauses the screen if
#-#      text is arriving to quickly.
#-#
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;

   if($txt =~ /^\s*(1|on)\s*$/) {
      save("p_more",1);
   } elsif($txt =~ /^\s*(0|off)\s*$/) {
      save("p_more",0);
   } elsif($txt =~ /^\s*$/) {
      echo("%% more is %s",(@state{p_more} eq 1) ? "on" : "off");
   } else {
      echo("% Invalid more syntax, syntax is: /more [on|off]");
   }
}
sub cmd_password
{
#-# ------------------------------------------------------------------------
#-# /password <password>
#-#
#-#      Set the password that is required when connecting to muddler via
#-#      the web.
#-#
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;

   @state{p_password} = trim($txt);
   echo("% Password has been updated to '%s'",$txt);
   save("p_password");
}

sub cmd_color
{
#-# ------------------------------------------------------------------------
#-# /color [dark|light]
#-#
#-#      Set the theme of muddler when used in the web to either dark or
#-#      light.
#-#
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;

   if($txt =~ /^\s*(dark|light)\s*$/) {
      ws_all("c",$txt);
      @state{p_color} = $txt;
      save("p_color");
   } else {
      echo("% color expects either dark or light.");
   }
}

sub cmd_keepalive
{
#-# ------------------------------------------------------------------------
#-# /keepalive <text>
#-#
#-#      Set what is sent to the current world when the socket is idle
#-#      to keep the connection from timing out.
#-#
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;

   if($txt eq undef) {
      for my $key (keys %socket) {
         if(defined @address{$key}->{keepalive}) {
             echo("%-15s   '%s'",$key,@address{$key}->{keepalive});
         }
      }
   } else {
      @address{$w}->{keepalive} = $txt;
      save($w,$w,1);
      echo("% Keepalive for $w set to: $txt");
   }
}

sub cmd_addworld
{
#-# ------------------------------------------------------------------------
#-# /addworld <name> [<user> <pass>] <host> <port>
#-#
#-#      Adds a world or overwrites an existing world.
#-#
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;

   my @field = split(/ /,$txt);
   my $append = 0;

   $append = 1 if(!defined @address{trim(lc(@field[0]))});

   if(trim(@field[0]) =~ /^p_/) {
      echo("%% World names may not start with 'p_' at this time");
   } elsif($#field == 2) {
      @address{trim(@field[0])} = { host => trim(@field[1]),
                                    port => trim(@field[2]),
                                    name => trim(@field[0]),
                                  };
   } elsif($#field == 5) {
      @address{trim(@field[0])} = { user => trim(@field[1]),
                                    pass => trim(@field[2]),
                                    port => trim(@field[3]),
                                    name => trim(@field[0]),
                                    host => trim(@field[4])
                                  };
   } elsif($#field == 6) {
      @address{trim(@field[0])} = { user => trim(@field[2]),
                                    pass => trim(@field[3]),
                                    port => trim(@field[4]),
                                    name => trim(@field[0]),
                                    host => trim(@field[5])
                                  };
   } else {
      return cmd_help($w,"addworld");
   }
   save(trim(lc(@field[0])));
}

#
# save
#    Save muddlers address and settings to .muddler
#
sub save
{
   my ($item,$value) = @_;
   my $append = 0;
   my $file;


   # redefining a world will cause a full dump of the file
   $append = 1 if(defined @address{$item});

   open($file,($append ? ">>" : ">") . " .muddler") ||
      return echo("%% Unable to open .muddler for writing.");

   for my $world (keys %address) {
      if(!$append || ($append && $world eq $item)) {
         printf($file "%s {\n",$world);
         printf($file "   type:address\n",$world);
         for my $key (keys %{@address{$world}}) {
            printf($file "   %s:%s\n",$key,single(@address{$world}->{$key}));
         }
         printf($file "}\n");
      }
   }

   for my $key (keys %state) {
      if(!$append || ($append && $key eq $item)) {
         printf($file "state:%s:%s\n",$key,trim($value));
      }
   }
   close($file);

   echo("%% %s worlds written to .muddler",scalar keys %address) if(!$append);
}

sub load
{
   my $quiet = shift;
   my ($file,$name,$data);

   if(!open($file,".muddler")) {
      return echo("%% Unable to open .muddler for reading") if(!$quiet);
   }

   while(<$file>) {
      s/\r|\n//g;
      if(/^\s*state:([^:]+):/) {                    # state variable values
         @state{$1} = $';
      } elsif(/^\s*([^ ]+)\s*{\s*$/) {                   # start of segment
         $name = $1;
         delete @$data{keys %$data};
      } elsif(/^\s*([^:]+)\s*:\s*/) {                      # segment value
         if($name eq undef) {
            return echo("% Corrupted .muddler file found on line $.");
         }
         $$data{$1} = $';
      } elsif(/^\s*}\s*$/) {                             # end of segment
         if($$data{type} eq "address") {          # segment was an address
            @address{$name} = { %$data };
         }
         $name = undef;
      } else {
        return echo("% Corrupted .muddler file found on line $.");
      }
   }
   close($file);
}

sub cmd_null
{
#-# ------------------------------------------------------------------------
#-# /null
#-#      Do nothing
#-# ------------------------------------------------------------------------
   # do nothing for now
}

sub cmd_listdef
{
#-# ------------------------------------------------------------------------
#-# /listdef <pattern>
#-#
#-#      Lists all defines or any matching <pattern>
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;
   my $opt = {};
   my $pat;

   my $str = getopt("sSm:t:b:B:E:T:h:a:P:iI");

   history($w,sprintf("%-15s %4s %-8s %s","NAME","ATTR","WORLD","STRING"));

   $pat = glob2re($txt) if($txt ne undef);
   
   for my $key (keys %def) {
      next if @def{$key}->{atr} !~ /g/;
      my $count = 0;

      if($pat eq undef || $key =~ /^$pat$/i) {
        for my $line (ansi_wrap(@def{$key}->{txt},49)) {
           if($count++ == 0) {
               history($w,sprintf("%-15s %4s %-8s %s",
                    $key,
                    @def{$key}->{atr},
                    @def{$key}->{world},
                    $line
                   ));
            } else {
               history($w,sprintf("%-15s %4s %-8s %s",
                    "",
                    "",
                    "",
                    $line
                   ));
            }
         }
      }
   }
}

sub cmd_listworlds
{
#-# ------------------------------------------------------------------------
#-# /listworlds <pattern>
#-#
#-#      Lists all worlds or any matching <pattern>
#-# ------------------------------------------------------------------------
   my ($w,$txt) = (shift,trim(@_));
   $w = @state{world} if $w eq undef;
   my $pat;
#   my $opt = {};

#   my $str = getopt("sSm:t:b:B:E:T:h:a:P:iI");

   key_log("List: called: %s",scalar keys %address);
   history($w,sprintf("%-15s %33s %6s %s","NAME","HOST","PORT","CHARACTER"));

   $pat = glob2re($txt) if($txt ne undef);
   for my $key (keys %address) {
      if($txt eq undef || $key =~ /$pat/) {
         history($w,sprintf("%-15s %33s %6s %s",
                            $key,
                            @address{$key}->{host},
                            @address{$key}->{port},
                            @address{$key}->{user},
                            @address{$key}->{pass}
                           )
                );
      }
   }
}

sub cmd_def
{
#-# ------------------------------------------------------------------------
#-# /def <options> <name>
#-#
#-#      Options
#-#      -a<attributes>   Specifies what should happen when the text is
#-#                       matched.
#-#
#-#                       Attributes:
#-#                          g      : Text will be not be shown when
#-#                                   matched.
#-#
#-#      -w<world>        Match will be limited to a specific world
#-#      -t"text"         Text to match. May include wild cards.
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;
   my $opt = {};

   my $str = getopt("m:n:E:t:h:b:B:p:c:w:T:Fa:P:fiIq1",$txt,$opt);

   @def{trim($str)} = { atr   => $$opt{a},
                        txt   => $$opt{t},
                        world => $$opt{w},
                        match => $$opt{m},
                      };
}

sub first
{
   my $str = shift;

   return $1 if(/^\s*([^ ]+)/);
}

#
# cmd_ps
#    List all running processes
#
sub cmd_ps
{
#-# ------------------------------------------------------------------------
#-# /ps
#-#    List any running processes such as /repeat.
#-#
#-# ------------------------------------------------------------------------
   echo("%-5s %-8s %-11s %-8s %8s %s","PID","NEXT","WORLD","PTIME","COUNT",
        "COMMAND"
       );
   for my $i (keys %pid) {
      my $tl = @pid{$i}->{last} + @pid{$i}->{tick} - time();
      $tl = 0 if($tl <= 0);
      echo("%-5s %-8s %-11s %-8s %8s %s",
           $i,
           to_hhmmss($tl),
           @pid{$i}->{world},
           to_hhmmss(@pid{$i}->{tick}),
           @pid{$i}->{count},
           @pid{$i}->{cmd},
          );
   }
}

sub cmd_kill
{
#-# ------------------------------------------------------------------------
#-# /kill <pid>
#-#    Kill a running process listed in /ps.
#-#
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;
   if($txt =~ /^\s*(\d+)\s*$/) {
      if(defined @pid{$1}) {
         delete @pid{$1};
      } else {
         echo("% KILL: no process %s",$1);
      }
   } else {
      echo("% KILL: invalid or missing numeric arguement");
   }
}

sub cmd_echo
{
#-# ------------------------------------------------------------------------
#-# /echo <message>
#-#    Echo <message> to the screen
#-#
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;

   echo($txt);
}
sub cmd_repeat
{
#-# ------------------------------------------------------------------------
#-# /repeat <options> <time> <command>
#-#    <time> A time between commands should be specified in hour, minute,
#-#    second format using -00:00:00.
#-#
#-#    -0          Sepecify seconds between commands.
#-#    -00:00      Sepecify hours minutes between commands.
#-#    -00:00:00   Sepecify hours, minutes, seconds  between commands.
#-#
#-#    <command>   The command that will be sent to the world.
#-#
#-#    <options>
#-#      -w<world>   Which would should the commands be run on.
#-#
#-# ------------------------------------------------------------------------
   my ($world,$txt) = @_;
   my ($count,$sec,$min,$hr);
   my $opt = {};
   my $orig = $txt;

   if($txt =~ /(^| )\-(\d+)( |$)/) {
      $sec = $2;
      $txt = "$` $'";
   } elsif($txt =~ /(^| )\-(\d+):(\d+)( |$)/) {
      ($hr,$min) = ($2,$3);
      $txt = "$` $'";
   } elsif($txt =~ /(^| )\-(\d+):(\d+):(\d+)( |$)/) {
      ($hr,$min,$sec) = ($2,$3,$4);
      $txt = "$` $'";
   }
   my $txt = getopt("w:nSP",$txt,$opt);

   if($txt =~ /^\s*(\d+)\s*/ && $1 > 0 && $1 < 20) {
      $count = $1;
      $txt = $';
   } else {
      echo("%% Invalid repeat count (%s)",first($txt));
   }

   my $tick = $sec + ($min * 60) + ($hr * 3600);
   $tick = 1 if($tick <= 1);

   @pid{++@state{pid}} = { cmd   => $txt,
                           count => $count,
                           last  => time() - $tick - $tick,
                           tick  => $tick,
                           world => ($$opt{w} eq undef) ? @state{world} : 
                                    $$opt{w},
                         };
}

sub to_hhmmss
{
   my $secs = shift;
   my ($hr,$min);

   if($secs >= 3600) {
      $hr = sprintf("%d",$secs / 3600);
      $secs = $secs - ($hr * 3600);
   }
   if($secs >= 60) {
      $min = sprintf("%d",$secs / 60);
      $secs = $secs - ($min * 60);
   }

   return sprintf("%02d:%02d:%02d",$hr,$min,$secs);
}

sub run_pid
{
   my $id = shift;

   if(defined @pid{$id}) {
      if(@pid{$id}->{count} <= 0) {                       # done, don't run
         delete @pid{$id};
      } else {
         @pid{$id}->{last} = time();
         @pid{$id}->{count}--;
         do_cmd(@pid{$id}->{world},@pid{$id}->{cmd});
      }
   }
}
      
sub do_cmd
{
   my ($world,$input,$conn) = @_;

   if($input =~ /^\/([^ ]+)\s*/) {
      if(defined @command{lc($1)}) {
         &{@command{lc($1)}}($world,$',$conn);
         return 1;
      } else {
         echo("%% %s: no such command or macro",lc($1));
         return 0;
      }
  }
  return 0;
}

#
# cmd_web_size
#    Set tell muddler the size of the websocket connection.
#
sub cmd_web_size
{
#-# ------------------------------------------------------------------------
#-# /web_size <height>,<width>
#-#
#-#      Sets the height and width of the browser in number of characters
#-#      that can be displayed. This is used internally and should not be
#-#      needed to be set by the user.
#-#
#-# ------------------------------------------------------------------------
   my ($world,$txt,$conn) = @_;

   if($conn ne undef) {
      my (@size) = split(',',$txt);

      if(@size[0] =~ /^\s*(\d+)\s*$/) {
         @ws{$conn}->{size_x} = $1;
      }
      if(@size[1] =~ /^\s*(\d+)\s*$/) {
         @ws{$conn}->{size_y} = $1 - 3;
      }
   }
   redraw_output(0,1);
}

sub cmd_port
{
#-# ------------------------------------------------------------------------
#-# /port <port>
#-#      Sets the port to be used by the web server. To connect to muddler
#-#      via the web use: http://localhost:<port>. Remember to turn web
#-#      use on via '/web on'.
#-#
#-#  Note: The websocket port will be at <port> + 1, but this is only
#-#        important for configuration of your firewall if needed.

#-# ------------------------------------------------------------------------
   my ($w,$port) = (shift,trim(shift));

   if($port =~ /^\d+$/) {
      save("p_port",$port);
   } else {
      echo("%% Websocket port must be numeric.");
   }
}

sub cmd_web
{
#-# ------------------------------------------------------------------------
#-# /web [on|off]
#-#      Turns on or off the web/websocket server for the mud client.
#-# ------------------------------------------------------------------------
   my ($w,$status) = @_;

   if(!module_enabled("Net::WebSocket::Server")) {
      return echo("%% Web/Websocket disabled due to missing module");
   } elsif($status =~ /^\s*on\s*$/i) {
      echo("%% Web enabled, connect via: http://localhost:@state{port}");
      echo("%%    Password: @state{p_password}");
      if(@state{p_web} == 0) {
         ws_init();
         save("p_web",1);
     }
   } elsif($status =~ /^\s*off\s*$/i) {
      save("p_web",0);
      if(@state{web} == 1000) {
         echo("%% Web/Websocket server is already disabled.");
      } else {
         echo("%% Web/Websocket server has been disabled.");
         for my $key (keys %http) {
            @http{$key}->{sock}->close;
         }
         $http_listen->close();
         @state{web} = 0;
         eval {
            $ws_server->shutdown();
         };
      }
   }
}

sub cmd_help
{
#-# ------------------------------------------------------------------------
#-# /help [<command>]
#-#      Shows the help for the specified command.
#-#
#-# Availible commands:
#-# ------------------------------------------------------------------------
   my ($w,$cmd) = @_;
   

   if(!defined @state{help}) {
      echo("% No help loaded.");
   } elsif(trim($cmd) eq undef) {
      echo("\n%s",@state{help}->{cmd_help});
      for my $line (ansi_wrap(join(", ",grep {!/key_/} keys %command),
         @state{size_y}-5)) {
         echo("   %s",trim($line));
      }
   } elsif(defined @state{help}->{"cmd_" . lc(trim($cmd))}) {
      echo("\n%s",@state{help}->{"cmd_" . lc(trim($cmd))});
   } else {
      echo("%% Help on subject %s not found.",lc(trim($cmd)));
   }
}

sub cmd_version
{
   my ($w,$txt,$conn) = @_;
#-# ------------------------------------------------------------------------
#-# /version
#-#      Shows the current version at startup of muddler. This is currently
#-#      not refreshed when the code is reloaded.
#-# ------------------------------------------------------------------------
   for my $line (split(/\n/,@state{version})) {
      ws_echo($conn,center($line));
#      echo("%s",center($line),1);
   }
}


sub remove_quotes
{
   my $txt = shift;

   if($txt =~ /^('|")(.*)('|")$/) {
      return $2;
   } else {
      return $txt;
   }
}

sub get_segment_end
{
   my $txt = shift;
   my ($in_single, $in_double);

   for(my $i=0;$i <= length($txt);$i++) {
      my $ch = substr($txt,$i,1);

      if($ch eq "\\") {
         $ch++;
      } elsif($ch eq "\"" && !$in_single) {
         $in_double = !$in_double;
      } elsif($ch eq "\'" && !$in_double) {
         $in_single = !$in_single;
      } elsif($ch eq " " && !$in_single && !$in_double) {
         return $i;                                          # done
      }
   }
   return length($txt);
}

sub getopt
{
   my ($opts,$txt,$result) = @_;
   my ($in_arg,%lookfor,$prev,$end);

   for(my $i = 0;$i < length($opts);$i++) {     # determine what to look for
      my $ch = substr($opts,$i,1);
      if($ch eq ":") {
         @lookfor{$prev} = 2 if($prev ne undef); # populate hash with details
      } else {
         @lookfor{$ch} = 1;
      }
      $prev = $ch;
   }
      
   for(my $i = 0;$i <= length($txt);$i++) {         # take apart $txt string
      my $ch = substr($txt,$i,1);

      if($ch eq "\\") {                                       # escaped char
         $i++;
      } elsif($ch eq "-" && !$in_arg) {                  # start of   option 
         $in_arg = 1;
      } elsif($in_arg and $ch eq " ") {                      # end of option
         $in_arg = 0;
      } elsif($in_arg) {                                   # option contents
         if(defined @lookfor{$ch}) {
            if(@lookfor{$ch} == 1) {                         # simple option
               $$result{$ch} = 1;
            } elsif(@lookfor{$ch} == 2) {                   # option w/value
               $end = get_segment_end(substr($txt,$i+1));      # scan to end
               if($end eq undef) {                           # nothing found
                  $$result{$ch} = "";
               } else {                                    # found something
                  $$result{$ch} = remove_quotes(substr($txt,$i+1,$end)); 
                  $i += $end;
               }
            }
         } else {
           # invalid option, probably should die/error out here
         }
      } else {                                  # store string minus options
         return substr($txt,$i);
      }
   }
}

sub cmd_recall
{
#-# ------------------------------------------------------------------------
#-# /recall [<count>] <pattern>
#-#      Does a recall of ten lines from the current world's history
#-#      buffer that matches pattern. The amount of lines can be
#-#      changed by specifying a count.
#-#
#-# Patterns:
#-#      Patterns may contain text that will be matched as is but also
#-#      May contain * as a wild card or ? to match a single character.   
#-#
#-# Example:
#-#      /recall *pages*
#-# ------------------------------------------------------------------------
   my ($w,$txt) = @_;
   my ($count,$pat,@out,$gagged) = 10;
   my $opt = {};

   return echo("%% Not connected to a world.") if(no_world());
   $txt = getopt("a:",$txt,$opt);

   if($txt =~ /^\s*(\d+)\s*/) {
      $count = $1;
      $pat = $';
   } elsif($txt =~ /^\s*\/(\d+)\s*/) {
      $count = $1;
      $pat = $';
   } else {
      $pat = $txt;
   }

   # include gagged content?
   if($$opt{a} =~ /g/) {
      $gagged = 1;
   } else {
      $gagged = 0;
   }

   $pat = glob2re($pat);
   for(my $i=$#{@history{@state{world}}};$i >= 0 && $count > 0;$i--) {
      eval {
         if(((!$gagged && !@history{@state{world}}->[$i]->{gagged}) || 
            $gagged) &&
            ansi_remove(@history{@state{world}}->[$i]->{txt}) =~ /$pat/) {

            # order will be backwards, so store.
            unshift(@out,@history{@state{world}}->[$i]->{txt});

            $count--;
         }
      };
   }
   for my $i (0 .. $#out) {
      echo_wrap(@out[$i]);                       # output in correct order
   }
}

sub cmd_listsockets
{
#-# ------------------------------------------------------------------------
#-# /list_sockets
#-#      Shows all open connections and some minimal data about them.
#-# ------------------------------------------------------------------------
   echo("%-16s %-26s %-5s","NAME","HOST","PORT");
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock}) {
         echo("%-16s %-26s %-5s", @address{$w}->{name}, @address{$w}->{host},
             @address{$w}->{port});
      }
   }
}
sub cmd_quit
{
#-# ------------------------------------------------------------------------
#-# /quit
#-#      Exits out of muddler
#-# ------------------------------------------------------------------------
   revert_console();
   exit(1);
}

sub cmd_reload
{
#-# ------------------------------------------------------------------------
#-# /reload
#-#      Reloads the perl code for muddler without dropping connections.
#-#      As long as no new variables are set, there is a 80% chance
#-#      that the client will continue and not have issues.
#-# ------------------------------------------------------------------------
   reload_code();
}

sub cmd_world
{
#-# ------------------------------------------------------------------------
#-# /world <world>
#-#      Connects to the specified world if not connected or switches over
#-#      to that world if it is connected.
#-#
#-# Ex: /world puggy
#-# ------------------------------------------------------------------------
   my ($w,$txt) = (shift,lc(trim(shift)));

   if(!defined @address{$txt}) {
      return echo("% CONNECT: no such world '%s'",$txt);
   } elsif(defined @socket{$txt} && defined @socket{$txt}->{sock}) {
      switch_world($txt);
   } else {
      socket_connect(@address{$txt}->{name},
                     @address{$txt}->{host},
                     @address{$txt}->{port},
                    );
   }
}


#----------------------------------------------------------------------------#
#                                                                            #
#  misc code                                                                 #
#                                                                            #
#----------------------------------------------------------------------------#

END {
  if(module_enabled("Term::ReadKey")) {
     revert_console();
  }
}

sub center
{
    my $txt = shift;

    return sprintf("%s%s",(" " x ((@state{size_y} - length($txt)-1) / 2)),$txt);
}

sub optimize_start
{
   @state{optimize_output} = 1;
}

sub optimize_end
{
   @state{optimize_output} = 0;
   update_scroll_region("input");
   xy(input_x(),input_y());
}

sub show_banner
{
   open(PROG,$0) || return;

   optimize_start();
   while(<PROG>) {
      s/\n|\r//g;
      if($. > 24) {                                  # read only 24 lines
         last;
      } elsif(/^#-#   /) {
         @state{version} .= "$'\n";
         echo("%s",center($'));
      } elsif($. > 100) {                              # read only 50 lines
         last;
      }
   }

   @state{version} =~ s/\n$//g;
   close(PROG);
   for my $i (0 .. 2) {
      echo("%s","");
   }
   optimize_end();
}

sub read_tfworlds
{
   my ($fn,$quiet) = @_;
   my ($file, $bad);

   if(!open($file,$fn)) {
      echo("%% Unable to open '%s' for reading",$fn) if (!$quiet);
      return;
   }

   while(<$file>) {
      s/\r|\n//g;
      if(/^\/test addworld\((.*)\)$/) {
         my @data = quotewords(',',0,$1);
         @address{lc(trim(@data[0]))} = {};
         @address{lc(trim(@data[0]))}->{host} = trim(@data[2]);
         @address{lc(trim(@data[0]))}->{port} = trim(@data[3]);;
         @address{lc(trim(@data[0]))}->{user} = trim(@data[4]);;
         @address{lc(trim(@data[0]))}->{pass} = trim(@data[5]);;
         @address{lc(trim(@data[0]))}->{name} = trim(@data[0]);
      } else {
         $bad++;
         echo("%% Unknown data: '%s'",$_);
      }
   }
   close($file);
   echo("%% %d worlds read from tfworlds file.",scalar keys %address);
}

sub read_tfrc
{
   my $fn = shift;
   my ($file, $prev);

   open($file,$fn) || return;

   while(<$file>) {
      s/\r|\n//g;
      if(/^\s*;/) {
         # comment;
      } elsif(/\s*\\\s*$/) {
         $prev .= $`;
      } else {
         do_cmd(undef,$prev . $_);
         $prev = undef;
      }
   }
   close($file);
}

sub get_checksums
{
   my ($file,$pos,%data);
   my $ln = 1;

   return if(!module_enabled("Digest::MD5"));
      
   open($file,$0) ||
     return echo("%% Unable to read source file, /reload will be disabled");

   for my $line (<$file>) {
      if($pos eq undef && $line =~ /^sub\s+([^ \n\r]+)\s*$/) {
         $pos = $1;
         @data{$pos} = { chk => Digest::MD5->new };
         @data{$pos}->{chk}->add($line);
         @data{$pos}->{src} .= qq[#line 0 "$pos"\n] . $line;
         @data{$pos}->{line} = $ln;
         if($pos =~ /^cmd_/) {
            @state{help} = {} if not defined @state{help};
            delete @state{help}->{$pos} if defined @state{help}->{$pos};
         }
      } elsif($pos ne undef && $line =~ /^}\s*$/) {
         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk}->add($line);
         @data{$pos}->{chk} = @data{$pos}->{chk}->hexdigest;
         @data{$pos}->{done} = 1;
         if($pos =~ /cmd_/) {
            @state{help}->{$pos} =~ s/\n$//;
         }
         $pos = undef;
      } elsif($pos ne undef) {
         if($pos =~ /cmd_/) {
            if($line =~ /^#-# -+$/) {
               # header ignored
            } elsif($line =~ /^#-# {0,1}/) {
               @state{help}->{$pos} .= $';
            }
         }

         @data{$pos}->{src} .= $line;
         @data{$pos}->{chk}->add($line);
      }
      $ln++;
   }
   close($file);

   for my $pos (keys %data) {
      if(!defined @data{$pos}->{done}) {
         echo("% Warning: Did not find end to %s",$pos);
      }
   }
   return \%data;
}

#
# reload_code
#    As long as the global variables do not change, the code can be
#    reloaded without dropping any connections.
#
sub reload_code
{
   my $count = 0;
   my $new = get_checksums();
   my $old = @state{chksum};
   $old = {} if $old eq undef;

   if(!module_enabled("Digest::MD5")) {
      return echo("%% Missing Digest::MD5 module, reloading code disabled");
   }

   for my $key (keys %$new) {
      if((@state{state} eq "init" || 
         (!defined $$old{$key} || $$old{$key}->{chk} ne $$new{$key}->{chk}))) {
         
         key_log("%% Reloading: %s",$key) if @state{state} ne "init";
#         echo("%% Reloading: %s",$key) if @state{state} ne "init";
         eval($$new{$key}->{src});
         $count++;
         if($@) {
            echo("%% Error reloading $key: %s",$@);
            $$new{$key}->{chk} = -1;
         } else {
            echo("%% Reloading: %s [done]",$key) if @state{state} ne "init";
         }
      }
   }
   @state{chksum} = $new;
   command_init();
   key_init();
   http_data_fix();

   if($count == 0) {
      echo("%% No changes found to reload.");
   }
}

#
# ignoreit
#    Ignore certain hash key entries at all depths or just the specified
#    depth.
#
sub ignoreit
{
   my ($skip,$key,$depth) = @_;


   if(!defined $$skip{$key}) {
      return 0;
   } elsif($$skip{$key} < 0 || ($$skip{$key} >= 0 && $$skip{$key} == $depth)) {
     return 1;
   } else {
     return 0;
   }
}

#
# print_var
#    Return a "text" printable version of a HASH / Array
#
sub print_var
{
   my ($var,$depth,$name,$skip,$recursive) = @_;
   my ($PL,$PR) = ('{','}');
   my $out;

   if($depth > 4) {
       return (" " x ($depth * 2)) .  " -> TO_BIG\n";
   }
   $depth = 0 if $depth eq "";
   $out .= (" " x ($depth * 2)) . (($name eq undef) ? "UNDEFINED" : $name) .
           " $PL\n" if(!$recursive);
   $depth++;

   for my $key (sort ((ref($var) eq "HASH") ? keys %$var : 0 .. $#$var)) {

      my $data = (ref($var) eq "HASH") ? $$var{$key} : $$var[$key];

      if((ref($data) eq "HASH" || ref($data) eq "ARRAY") &&
         !ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s $PL\n"," " x ($depth*2),$key);
         $out .= print_var($data,$depth+1,$key,$skip,1);
         $out .= sprintf("%s$PR\n"," " x ($depth*2));
      } elsif(!ignoreit($skip,$key,$depth)) {
         $out .= sprintf("%s%s = %s\n"," " x ($depth*2),$key,$data);
      }
   }

   $out .= (" " x (($depth-1)*2)) . "$PR\n" if(!$recursive);
   return $out;
}


#
# remove any space at the begining or end of a string
#
sub trim
{
   my $txt = shift;

   $txt =~ s/^\s+|\s+$//g;
   return $txt;
}

sub tick
{
   for my $w (keys %socket) {
      if(defined @socket{$w}->{sock} && time()-@socket{$w}->{last_send} > 300){
         if(defined @address{$w}->{keepalive}) {
            out($w,@address{$w}->{keepalive} . "\n");
         } else {
            out($w,"@@ idle\n");
         }
      }
   }

   if(web()) {
      for my $key (keys %ws) {
         if(@ws{$key}->{auth} eq 0 && time() - @ws{$key}->{start} > 60) {
            ws_echo(@ws{$key}->{conn},"t","%% Password entry timed out",1);
            ws_disconnect(@ws{$key}->{conn});
         }
      }
   }
 
   for my $id (keys %pid) {
      if(@pid{$id}->{last} + @pid{$id}->{tick} <= time()) {
         run_pid($id);
      }
   }

   my $prev = "@state{size_y},@state{size_x}";
   (@state{size_y},@state{size_x}) = GetTerminalSize();
   if($prev ne "@state{size_y},@state{size_x}") {
      pending_fix();
      redraw_screen();
   }
}

sub read_file
{
   my $fn =shift;
   my $file;

   open($file,$fn) || 
      die("Could not open '$fn' for reading");
   my $result = join("",<$file>);
   close($file);
   return $result;
}

#
# muddler_init: run once type stuff
#
sub muddler_init
{
   # for temporay viewport for output before a connected world
   @history{muddler} = [];
   @socket{muddler} = { name        => "muddler",
                        more        => -1,
                        more_count  => 0,
                        last_read   => -1,
                        history_pos => -1,
                        history_pos_partial => -1,
                      };

   @state{state} = "init";
   (@state{size_y},@state{size_x}) = GetTerminalSize();

   `del key.log`;
   @state{activity} = {};
   @state{chksum} = get_checksums();
   key_log("### START ###");

   if(console()) {
      $| = 1;                                                  # unbuffer stdout
      eval ("ReadMode 'cbreak';");
   }
   key_init();
   command_init();
   redraw_screen();
   show_banner();
   load(1);

   read_tfworlds("@ENV{HOME}/.tfworlds",1) if(!-e ".muddler");
   read_tfrc("@ENV{HOME}/.tfrc",1);
   reload_code();
#   Monitor::monitor(@pending{alpha}, "array");
   @state{state} = "post-init";
}

#
# muddler
#    Contents of the main loop, seperated so it can be reloaded since
#    the main loop should not be.
#
sub muddler
{
   local $SIG{ALRM} = sub {
      delete @pid{keys %pid};
      key_log("### Fatal ### Alarm timeout");
      key_log(code("long"));
      die("alarm\n");
   };
   alarm(15);

   socket_handle_input();
   ws_io();
   key_process(ReadKey(0.25));
   if($@) {
      key_log("Crash? $@");
   }
   draw_bar();

   if(time() - @state{tick_last} >= 1) {
      tick();
      @state{tick_last} = time();
   }
   alarm(0);
}

sub sig_hup
{
   delete @pid{keys %pid};
   reload_code();
}

# allow for reloading of the code via a signal.
$SIG{HUP} = sub { sig_hup(); };

for my $i (0 .. $#ARGV) {
   if(@ARGV[$i] eq "--noconsole") {
      @state{console} = 0;
   } elsif(@ARGV[$i] =~ /^--port=(\d+)$/) {
      @state{port} = $1;
   } elsif(@ARGV[$i] =~ /^--password=(.*)$/  ||
           @ARGV[$i] =~ /^--pass=(.*)$/) {
      save("p_password",$1);
   } else {
     die("Invalid Option: '@ARGV[$i]'");
   }
}

load_modules();
ws_init() if !console();

muddler_init();

if(defined @state{modules}) {
   for my $i (0 .. $#{@state{modules}}) {
      echo("%s",@state{modules}->[$i]);
   }
}
# keep the main loop small.
while(1) {
   eval { muddler(); };
   key_log("Fatal: $@ -> %s",code()) if($@);
}


